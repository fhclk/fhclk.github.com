<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fhclk.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="拾荒者">
<meta property="og:url" content="http://fhclk.github.io/page/15/index.html">
<meta property="og:site_name" content="拾荒者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fhclk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fhclk.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>拾荒者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拾荒者</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">昨夜西风凋碧树，独上高楼，望尽天涯路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/29/CSS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/29/CSS3/" class="post-title-link" itemprop="url">CSS3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-29 20:37:19" itemprop="dateCreated datePublished" datetime="2017-10-29T20:37:19+08:00">2017-10-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><p><code>border-radius</code></p>
<p>每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的。</p>
<h4 id="盒阴影"><a href="#盒阴影" class="headerlink" title="盒阴影"></a>盒阴影</h4><p><code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>
<p>boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。  </p>
<ul>
<li>h-shadow	必需的。水平阴影的位置。允许负值   </li>
<li>v-shadow	必需的。垂直阴影的位置。允许负值</li>
<li>blur	可选。模糊距离</li>
<li>spread	可选。阴影的大小</li>
<li>color	可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表</li>
<li>inset	可选。从外层的阴影（开始时）改变阴影内侧阴影</li>
</ul>
<h4 id="边框图像"><a href="#边框图像" class="headerlink" title="边框图像"></a>边框图像</h4><p><code>border-image: source slice width outset repeat;</code></p>
<ul>
<li>border-image-source	用于指定要用于绘制边框的图像的位置</li>
<li>border-image-slice	图像边界向内偏移</li>
<li>border-image-width	图像边界的宽度</li>
<li>border-image-outset	用于指定在边框外部绘制 border-image-area 的量</li>
<li>border-image-repeat	这个例子演示了如何创建一个border-image 属性的按钮。</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h5 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h5><p>不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background-image: url(img_flwr.gif), url(paper.gif);</span><br><span class="line">	background-position: right bottom, left top;</span><br><span class="line">	background-repeat: no-repeat, repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以给不同的图片设置多个不同的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><p>background-size可以指定图像的大小。CSS3以前，背景图像大小由图像的实际大小决定。<br>CSS3中可以指定背景图片，重新在不同的环境中指定背景图片的大小。指定的大小是相对父元素的宽度和高度的百分比大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-size:80px 60px;</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p>指定背景图片的位置区域。content-box、padding-box、border-box区域内可以放置背景图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">	background-size:100% 100%;</span><br><span class="line">	background-origin:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="渐变-gradient"><a href="#渐变-gradient" class="headerlink" title="渐变 gradient"></a>渐变 gradient</h3><p>gradient可以在两个或多个指定颜色之间显示平稳的过渡。<br>CSS3中定义了两种类型的渐变</p>
<ul>
<li>线性渐变 Line Gradient  向下&#x2F;向上&#x2F;向左&#x2F;向右&#x2F;对角方向</li>
<li>径向渐变 Radial Gradient 由它们的中心定义</li>
</ul>
<h5 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h5><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。</p>
<p><code>background: linear-gradient(direction, color-stop1, color-stop2, ...); </code></p>
<p>线性渐变 - 从上到下 （默认情况）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  	background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  	background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  	background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  	background: linear-gradient(red, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线性渐变 - 从左到右</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(to right, red , blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性渐变 - 对角</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用角度</p>
<p><code>background: linear-gradient(angle, color-stop1, color-stop2);</code></p>
<p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。</p>
<p><img src="/2017/10/29/CSS3/angleGradient.jpg" alt="角度"></p>
<p>但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。换算公式 90 - x &#x3D; y 其中 x 为标准角度，y为非标准角度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(180deg, red, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多个颜色结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(red, green, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用透明度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */</span><br><span class="line">  background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/</span><br><span class="line">  background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/</span><br><span class="line">  background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复的线性渐变<br>repeating-linear-gradient() 函数用于重复线性渐变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -o-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* Firefox 3.6 - 15 */</span><br><span class="line">  background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* 标准的语法 */</span><br><span class="line">  background: repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h5><p>径向渐变由它的中心定义。</p>
<p>为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
<p><code>background: radial-gradient(center, shape size, start-color, ..., last-color); </code></p>
<p>径向渐变 - 颜色结点均匀分布（默认情况下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(red, green, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>径向渐变 - 颜色结点不均匀分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置形状</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h6 id="CSS3-font-face-规则"><a href="#CSS3-font-face-规则" class="headerlink" title="CSS3 @font-face 规则"></a>CSS3 @font-face 规则</h6><p>在CSS3之前，web设计师必须使用已在用户计算机上安装好的字体，不能够使用离线字体，不过通过CSS3，web设计师可以使用他们喜欢的任意字体。</p>
<p>当您找到或购买到希望使用的字体时，可将该字体文件存放到web服务器上，它会在需要时被自动下载到用户的计算机上。</p>
<p>您”自己的”的字体是在 CSS3 @font-face 规则中定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">   font-family: myFirstFont;</span><br><span class="line">   src: url(sansation_light.woff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">   font-family:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h3><h5 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h5><p>根据左（x轴）和顶部（y轴）位置给定的参数，从当前元素位置移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: translate(50px, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h5><p>在给定的读书顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: rotate(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h5><p>该元素增加或减少的大小，取决于宽度（x轴）和高度（y轴）的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: scale(2,4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="skew"><a href="#skew" class="headerlink" title="skew()"></a>skew()</h5><p>包含两个参数，分别表示X轴和Y轴倾斜角度，如果第二个参数为空，则默认为0，参数为负表示向相反的方向倾斜。</p>
<ul>
<li>skewX() 表示只在X轴（水平方向）倾斜</li>
<li>skewY() 表示只在Y轴（垂直方向）倾斜</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: skew(10deg, 30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h5><p>matrix()方法和2D变换方法合并成一个。<br>matrix()方法有6个参数，包含旋转、缩放、移动（平移）和倾斜功能。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: matrix(0.3, 0.5, -0.5, 0.3, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/" class="post-title-link" itemprop="url">高效操作DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-22 20:58:31" itemprop="dateCreated datePublished" datetime="2017-10-22T20:58:31+08:00">2017-10-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h1><p>DOM（Document Object Model） 文档对象模型。</p>
<p>是JavaScript操作HTML的接口。</p>
<p>DOM V3标准主要由3个部分组成</p>
<ul>
<li>DOM节点</li>
<li>DOM事件</li>
<li>选择区域</li>
</ul>
<p>DOM节点概念区分：</p>
<ul>
<li>标签是HTML的基本单位，比如div、li、p、input等</li>
<li>节点是DOM数的基本单位，有多种类型，比如注释节点、文本节点</li>
<li>元素是节点中的一种，与HTML标签相应，比如p标签会对应p元素</li>
</ul>
<h1 id="DOM操作耗时"><a href="#DOM操作耗时" class="headerlink" title="DOM操作耗时"></a>DOM操作耗时</h1><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>浏览器包括渲染引擎（浏览器内核）和JavaScript引擎，它们都是单线程，单线程的优势是开发方便，避免了多线程下的死锁、竞争等问题；劣势是失去了并发能力。</p>
<p>浏览器为了避免两个引擎同时修改页面而造成渲染结果不一致的情况，这两个引擎具有互斥性，在某一个时刻只有一个引擎在运行，另一个引擎被阻塞。</p>
<p>操作系统在进行线程切换时需要保存上一个线程执行时的状态信息，并读取下一个线程的状态信息，俗称上下文切换，这个操作相对而言是比较耗时的。</p>
<p>从JavaScript引擎切换到渲染引擎执行相应操作后，再切换回JavaScript引擎继续执行，会带来性能损耗。</p>
<h2 id="重新渲染"><a href="#重新渲染" class="headerlink" title="重新渲染"></a>重新渲染</h2><p>渲染过程中最耗时的两个步骤为重排（Reflow）与重绘（Repaint）。</p>
<p>渲染页面是将HTML和CSS分别解析成DOM树和CSSOM树，然后合并进行排布，再绘制成我们可见的页面，如果在操作DOM时涉及到元素、样式的修改，就会引起渲染引擎重新计算样式生成CSSOM树，同时还有可能触发对元素的重新排布（简称“重排”）和重新绘制（简称“重绘”）</p>
<p>影响到其他元素排布的操作就会引起重排，继而引发重绘。</p>
<p>比如：</p>
<ul>
<li>修改元素边距、大小</li>
<li>添加删除元素</li>
<li>改变窗口大小</li>
</ul>
<p>与之相反的操作只会引起重绘</p>
<p>比如：</p>
<ul>
<li>设置背景图片</li>
<li>修改字体颜色</li>
<li>改变visibility属性值</li>
</ul>
<h2 id="如何高效操作DOM"><a href="#如何高效操作DOM" class="headerlink" title="如何高效操作DOM"></a>如何高效操作DOM</h2><h3 id="在循环外操作元素"><a href="#在循环外操作元素" class="headerlink" title="在循环外操作元素"></a>在循环外操作元素</h3><p>不用在循环内操作元素，尽量在循环外操作元素。</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224635494.png" alt="image-20230319224635494"></p>
<h3 id="批量操作元素"><a href="#批量操作元素" class="headerlink" title="批量操作元素"></a>批量操作元素</h3><p>比如创建10000个元素，在节点中直接添加耗时会非常多。如果拼接到字符串中，则相对较少。</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224706991.png" alt="image-20230319224706991"></p>
<h3 id="缓存元素集合"><a href="#缓存元素集合" class="headerlink" title="缓存元素集合"></a>缓存元素集合</h3><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224956526.png" alt="image-20230319224956526"></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319225019237.png" alt="image-20230319225019237"></p>
<h2 id="其他减少耗时的方法"><a href="#其他减少耗时的方法" class="headerlink" title="其他减少耗时的方法"></a>其他减少耗时的方法</h2><ul>
<li>尽量不用使用复杂的匹配规则和复杂的样式。从而减少渲染引擎计算样式规则生成CSSOM树的时间</li>
<li>尽量减少重排和重绘影响的区域</li>
<li>使用CSS特效来实现动画效果</li>
</ul>
<h1 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>搜索输入框，绑定input元素的键盘事件，然后在监听函数中发送AJAX请求。直接在事件方法里调用接口，这样会触发性能问题，每输入一个字符，都会在事件里响应，调用一次接口，而在实际中，用户输入完整字符后调用接口才是有效的。</p>
<p>针对这种情况，需要一个“防抖”功能，为函数的执行设置一个合理的时间间隔，避免事件在时间间隔内频繁触发，同时又保证用户输入后能即时看到搜索结果。</p>
<p><strong>setTimeout函数来让函数延迟执行</strong></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319230223440.png" alt="image-20230319230223440"></p>
<p>这个函数可以抽取成公共函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共防抖</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">func, wait=<span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> args</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">        args = arg</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Promise形式返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">res</span>(result)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    <span class="title function_">rej</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许取消</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许立即执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flush</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>()</span><br><span class="line">        <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.<span class="property">cancel</span> = cancel</span><br><span class="line">    debounced.<span class="property">flush</span> = flush</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>场景：一个浏览页面，左侧目录，右侧文章，浏览文章时，左侧目录根据右侧浏览滚动位置高亮显示。</p>
<p>实现：计算出每级目录对应文章内容的高度，根据距离来判断需要高亮的章节。在滚动事件里实时根据滚动距离去判断，但这会影响性能，一滚动就会触发计算。</p>
<p><strong>“节流“功能</strong></p>
<p>设置在指定一段时间内只调用一次函数，从而降低函数调用频率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">func, wait=<span class="number">0</span>, execFirstCall</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> args</span><br><span class="line">    <span class="keyword">let</span> firstCallTimestamp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!firstCallTimestamp) </span><br><span class="line">            firstCallTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">        <span class="keyword">if</span> (!execFirstCall || !args) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set args&#x27;</span>, arg)</span><br><span class="line">            args = arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Promise形式返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title function_">async</span>(res, rej) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - firstCallTimestamp &gt;= wait) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   	<span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">res</span>(result)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    <span class="title function_">rej</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="title function_">cancel</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">                        <span class="title function_">res</span>(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                        <span class="title function_">rej</span>(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="title function_">cancel</span>()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, firstCallTimestamp + wait - <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许取消</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        args = <span class="literal">null</span></span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">        firstCallTimestamp = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许立即执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flush</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>()</span><br><span class="line">        <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    throttled.<span class="property">cancel</span> = cancel</span><br><span class="line">    throttled.<span class="property">flush</span> = flush</span><br><span class="line">    <span class="keyword">return</span> throttled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319232609530.png" alt="image-20230319232609530"></p>
<p>对上面代码中的”编辑“和”删除“进行事件监听。</p>
<p>如果数据量一旦增大，事件绑定占用的内存以及执行时间将会成线性增加，其实这些事件监听函数逻辑一致，只是参数不同而已，我们可以以事件代理或事件委托来进行优化。</p>
<p><strong>DOM事件触发流程</strong></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319232907645.png" alt="image-20230319232907645"></p>
<p><strong>代理事件</strong></p>
<p>对list中的事件同一处理，通过参数来识别不同的item</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319233155747.png" alt="image-20230319233155747"></p>
<h2 id="关于DOM事件标准"><a href="#关于DOM事件标准" class="headerlink" title="关于DOM事件标准"></a>关于DOM事件标准</h2><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319233256667.png" alt="image-20230319233256667"></p>
<p>上面三种方式的区别</p>
<p>方式1和方式2会覆盖前面的事件</p>
<p>推荐使用方式3，同一事件的监听函数互补影响，而且可以独立取消，调用顺序和监听顺序一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/" class="post-title-link" itemprop="url">HTML中易忽略的标签</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-19 20:02:26" itemprop="dateCreated datePublished" datetime="2017-10-19T20:02:26+08:00">2017-10-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h1><h2 id="自动刷新-x2F-跳转"><a href="#自动刷新-x2F-跳转" class="headerlink" title="自动刷新&#x2F;跳转"></a>自动刷新&#x2F;跳转</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5;URL=page2.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设要实现PPT自动播放的功能，只需在每个页面的meta标签内设置好下一个页面地址即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;60&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>比如每隔一分钟就需要刷新页面的大屏幕监控，也可以通过meta标签来实现，只需去掉后面的URL。</p>
<blockquote>
<p>使用这种方式，刷新和跳转是不可取消的，对刷新时间间隔或者需要手动取消的，推荐使用JavaScript定时器来实现。</p>
<p>如果只是想实现页面的定时刷新或跳转（比如某些页面缺乏访问权限，在x秒后跳回首页这样的场景），建议使用meta标签</p>
</blockquote>
<h1 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h1><h2 id="Hack手段：消息提醒"><a href="#Hack手段：消息提醒" class="headerlink" title="Hack手段：消息提醒"></a>Hack手段：消息提醒</h2><p>B&#x2F;S架构在处理某些场景，比如即时通信时，会变得比较麻烦，因为前后端通信深度依赖HTTP协议，而HTTP协议是采用”请求-响应“模式。一种低效的解决方案是客户端通过轮询机制获取最新消息，（HTML5下可以使用WebSocket协议）</p>
<p>HTML5标准发布之前，浏览器没有开放图标闪烁、弹出系统消息之类的接口，只能借助一些Hack手段，比如修改title标签来达到类似的效果。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msgNum = <span class="number">1</span> <span class="comment">//条数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">const</span> inerval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    count = (count + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (msgNum === <span class="number">0</span>) &#123;</span><br><span class="line">        doucument.<span class="property">title</span> += <span class="string">&#x27;聊天页面&#x27;</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> refix = count % <span class="number">2</span> ? <span class="string">`新消息(<span class="subst">$&#123;msgNum&#125;</span>)`</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">    doucument.<span class="property">title</span> = <span class="string">`<span class="subst">$&#123;prefix&#125;</span>聊天页面`</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<p>HTML5中可以使用Web notifications API弹出系统消息。</p>
<p>动态修改title标签，还可以将一些关键信息显示在标签上，（比如下载时的进度、当前操作步骤等）</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>性能问题的两方面原因：渲染速度慢、请求时间长。</p>
<p>合理地利用标签，可以在一定程度上提升渲染速度以及减少请求时间。</p>
<h1 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h1><h2 id="调整加载顺序提升渲染速度"><a href="#调整加载顺序提升渲染速度" class="headerlink" title="调整加载顺序提升渲染速度"></a>调整加载顺序提升渲染速度</h2><p>渲染引擎在解析HTML时，若遇到script标签引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至JavaScript引擎来执行对应代码，代码执行完成后切换至渲染引擎继续渲染页面。</p>
<h2 id="script标签的3个属性"><a href="#script标签的3个属性" class="headerlink" title="script标签的3个属性"></a>script标签的3个属性</h2><ul>
<li><p>async属性</p>
<p>立即请求文件，但不阻塞渲染属性，文件加载完毕后阻塞渲染引擎并立即执行文件内容。</p>
</li>
<li><p>defer属性</p>
<p>立即请求文件，但不阻塞渲染属性，等到解析完HTML之后再执行文件内容。</p>
</li>
<li><p>HTML5标准type属性</p>
<p>对应的值为module。</p>
<p>让浏览器按照ES6标准将文件当作模块进行解析，默认阻塞效果同defer，也可以配合async在请求完成后立即执行。</p>
</li>
</ul>
<p><img src="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/image-20230319203320817.png" alt="image-20230319203320817"></p>
<p>当渲染引擎解析HTML遇到script标签引入文件时，会立即渲染一次。</p>
<p>构建工具会把编译好的引用JavaScript代码的script标签放入到body标签底部。当渲染引擎执行到body底部时会先将已解析的内容渲染出来，然后再去请求响应的JavaScript文件。</p>
<p>如果时内联脚本（不通过src引用外部脚本文件），渲染引擎不好渲染。</p>
<h1 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h1><h2 id="通过预处理提升渲染速度"><a href="#通过预处理提升渲染速度" class="headerlink" title="通过预处理提升渲染速度"></a>通过预处理提升渲染速度</h2><ul>
<li><p>dns-prefetch</p>
<p>当link标签的rel属性值为”dns-prefetch“时，浏览器会对某个域名预先进行DNS解析并缓存。当浏览器再访问同一域名的资源时，可以减少通过域名查询ip的过程，从而提升速度。</p>
</li>
<li><p>preconnect</p>
<p>让浏览器在一个HTTP请求正式发给服务器前预先执行一些操作，包括DNS解析、TLS协商、TCP握手，通过消除往返延迟来为用户节省时间。</p>
</li>
<li><p>prefetch&#x2F;preload</p>
<p>两个值都是让浏览器预先下载并缓存某个资源，但不同的是：prefetch可能会在浏览器忙时被忽略，而preload则是一定会被预先下载</p>
</li>
<li><p>prerender</p>
<p>浏览器不仅会加载资源，还会解析执行页面，进行预渲染。</p>
<p><img src="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/image-20230319204750649.png" alt="image-20230319204750649"></p>
</li>
</ul>
<h1 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h1><h2 id="meta标签：提取关键信息"><a href="#meta标签：提取关键信息" class="headerlink" title="meta标签：提取关键信息"></a>meta标签：提取关键信息</h2><p>meta标签专门为搜索引擎设置一些描述信息，方便用户预览到搜索结果</p>
<p>在实际工作中，推荐使用一些关键字工具来挑选，比如Google trends、站长工具</p>
<h2 id="link标签：减少重复"><a href="#link标签：减少重复" class="headerlink" title="link标签：减少重复"></a>link标签：减少重复</h2><p>对于同一个页面会有多个网址，又或者存在某些重定向页面，比如：</p>
<p><a target="_blank" rel="noopener" href="https://xx.com/a.html">https://xx.com/a.html</a></p>
<p><a target="_blank" rel="noopener" href="https://xx.com/detail?id=a">https://xx.com/detail?id=a</a></p>
<p>可以使用link标签，避免搜索引擎抓取相同页面的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://xx.com/a.html&quot; rel=&quot;canonical&quot; &gt;</span><br></pre></td></tr></table></figure>

<p>合并网址的方式：比如使用站点地图，或者在HTTP请求响应头部添加rel&#x3D;”canonical”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/15/react-native/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/15/react-native/" class="post-title-link" itemprop="url">React Native</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-15 16:31:32" itemprop="dateCreated datePublished" datetime="2017-10-15T16:31:32+08:00">2017-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/08/24/read-react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/24/read-react/" class="post-title-link" itemprop="url">React</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-24 23:52:48" itemprop="dateCreated datePublished" datetime="2017-08-24T23:52:48+08:00">2017-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="node和npm"><a href="#node和npm" class="headerlink" title="node和npm"></a>node和npm</h3><ol>
<li><p>node	</p>
<p> node包管理器</p>
</li>
<li><p>npm</p>
<p> <code>npm install -g &lt;package&gt;</code> 安装全局包<br> <code>npm install &lt;package&gt;</code> 安装本地包</p>
<p> node包安装完后会保存在node_modules&#x2F;文件夹下，并且会添加到package.json中</p>
<p> <code>npm init -y</code> 创建npm项目和package.json文件</p>
<p> <code>npm install</code> 从依赖文件package.json中安装node包</p>
<p> <code>npm install --save-dev</code> –save-dev 标记该node包只是用作开发环境的一部分，并不会作为产品代码发布</p>
</li>
</ol>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="创建react项目"><a href="#创建react项目" class="headerlink" title="创建react项目"></a>创建react项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><h4 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;;</span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.reander(</span><br><span class="line">	&lt;App /&gt;,</span><br><span class="line">	document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">	module.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ShoppingList extends React.Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		&lt;div className=&quot;shopping-list&quot;&gt;</span><br><span class="line">			&lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">			&lt;ul&gt;</span><br><span class="line">				&lt;li&gt;Instagram&lt;/li&gt;</span><br><span class="line">				&lt;li&gt;WhatsApp&lt;/li&gt;</span><br><span class="line">				&lt;li&gt;Oculus&lt;/li&gt;</span><br><span class="line">			&lt;/ul&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用法： &lt;ShoppingList name=&quot;mark&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="函数定义组件"><a href="#函数定义组件" class="headerlink" title="函数定义组件"></a>函数定义组件</h4><p>为只有render方法的组件提供的一种简便的定义组件的方法。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Square(props) &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;button className=&quot;square&quot; onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">			&#123;props.value&#125;</span><br><span class="line">		&lt;/button&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化事件处理函数。这里把 <code>onClick=&#123; () =&gt; props.onClick() &#125;</code> 直接修改为 <code>onClick=&#123;props.onClick&#125;</code> ，注意不能写成 <code>onClick=&#123;props.onClick()&#125;</code>否则<code>porps.onClick</code>方法会在Square组件渲染时被直接触发而不是等到Board组件渲染完成时通过点击触发，又因为此时Board组件正在渲染中（即Board组件的render方法正在调用），又触发父组件onClick中调用setState()会再次调用render方法导致死循环。     </p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/2017/08/24/read-react/lifecycle.png" alt="生命周期">     </p>
<h4 id="正确使用state"><a href="#正确使用state" class="headerlink" title="正确使用state"></a>正确使用state</h4><p>构造函数是唯一能够初始化state的地方。</p>
<ul>
<li><p>不要直接更新状态，应当使用setState()</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Wrong，此代码不会重新渲染组件</span><br><span class="line">this.state.comment = &#x27;Hello&#x27;;</span><br><span class="line">// Correct</span><br><span class="line">this.setState(&#123;comment: &#x27;Hello&#x27;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>状态更新可能是异步的<br>  React可以将多个setState()调用合并成一个调用来提高性能。<br>  因为this.props和this.state可能是异步更新的，你不应该依靠它们的值来计算下一个状态。      </p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">	counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Correct</span><br><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">	counter: prevState.counter + props.increment</span><br><span class="line">&#125;);</span><br><span class="line">// Correct</span><br><span class="line">this.setState(function(prevState, props) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		counter: prevState.counter + props.increment</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>状态更新合并</p>
<p>  当调用setState()时，React将提供的对象合并到当前状态。 </p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">	super(props);</span><br><span class="line">	this.state = &#123;</span><br><span class="line">		posts: [],</span><br><span class="line">		comments: []</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">	fetchPost().then(response =&gt; &#123;</span><br><span class="line">		this.setState(&#123;</span><br><span class="line">			posts: response.posts</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	fetchPost().then(response =&gt; &#123;</span><br><span class="line">		this.setState(&#123;</span><br><span class="line">			comments: response.comments</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里的合并是浅合并，也就是说this.setState({comments})完整保留了this.state.posts，但完全替换了this.state.comments。</p>
</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>React元素的事件处理和DOM元素的很相似。但是有一些语法上的不同：</p>
<ul>
<li>React事件绑定属性的命名采用驼峰式写法，而不是小写。   </li>
<li>如果采用JSX的语法需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素的写法）</li>
<li>在React中，不能使用返回false的方式阻止默认行为，必须明确使用preventDefault</li>
</ul>
<p>在React中，JSX回调函数中的this，类方法默认不会绑定this的。如果忘记绑定this.handleClick并把它传入onClick，当你调用这个函数的时候，this的值是undefined。<br>两种不用绑定this的方法，属性初始化器语法和箭头函数。      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		this.state = &#123;</span><br><span class="line">			isToggleOn: true</span><br><span class="line">		&#125;;</span><br><span class="line">		this.handleClick1 = this.handleClick1.bind(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick1() &#123;</span><br><span class="line">		this.setState((prevState) =&gt; &#123;</span><br><span class="line">			isToggleOn: !prevState.isToggleOn</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick2 = (e) =&gt; &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick3(e) &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;button onClick=&#123;this.handleClick1&#125;&gt;</span><br><span class="line">					&#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">				&lt;button onClick=&#123;this.handleClick2&#125;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">				&lt;button onClick=&#123;(e) =&gt; this.handleClick3(e)&#125;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用箭头函数，每次Toggle渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。      </p>
<h4 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deleteRow(rowId, event) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="列表和keys"><a href="#列表和keys" class="headerlink" title="列表和keys"></a>列表和keys</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo) =&gt;</span><br><span class="line">  &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当元素没有确定的id时，你可以使用他的序列号索引index作为key。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo, index) =&gt;</span><br><span class="line">  &lt;li key=&#123;index&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作键值，因为这样做会导致性能的负面影响，还可能引起组件状态问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/21/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/21/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B/" class="post-title-link" itemprop="url">读《大型网站技术架构：核心原理与案例分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-21 14:10:13" itemprop="dateCreated datePublished" datetime="2017-06-21T14:10:13+08:00">2017-06-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="大型网站架构演化"><a href="#大型网站架构演化" class="headerlink" title="大型网站架构演化"></a>大型网站架构演化</h2><h3 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h3><h3 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h3><h4 id="初始阶段的网站架构"><a href="#初始阶段的网站架构" class="headerlink" title="初始阶段的网站架构"></a>初始阶段的网站架构</h4><h4 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h4><h4 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h4><h4 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h4><h4 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h4><h4 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h4><h4 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h4><h4 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h4><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><h4 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h4><h3 id="大型网站架构演化的价值观"><a href="#大型网站架构演化的价值观" class="headerlink" title="大型网站架构演化的价值观"></a>大型网站架构演化的价值观</h3><h4 id="大型网站架构技术的核心价值是随网站所需灵活应对"><a href="#大型网站架构技术的核心价值是随网站所需灵活应对" class="headerlink" title="大型网站架构技术的核心价值是随网站所需灵活应对"></a>大型网站架构技术的核心价值是随网站所需灵活应对</h4><h4 id="驱动大型网站技术发展的主要力量是网站的业务发展"><a href="#驱动大型网站技术发展的主要力量是网站的业务发展" class="headerlink" title="驱动大型网站技术发展的主要力量是网站的业务发展"></a>驱动大型网站技术发展的主要力量是网站的业务发展</h4><h3 id="网站架构设计误区"><a href="#网站架构设计误区" class="headerlink" title="网站架构设计误区"></a>网站架构设计误区</h3><h4 id="一味追随大公司的解决方案"><a href="#一味追随大公司的解决方案" class="headerlink" title="一味追随大公司的解决方案"></a>一味追随大公司的解决方案</h4><h4 id="为了技术而技术"><a href="#为了技术而技术" class="headerlink" title="为了技术而技术"></a>为了技术而技术</h4><h4 id="企图用技术解决所有问题"><a href="#企图用技术解决所有问题" class="headerlink" title="企图用技术解决所有问题"></a>企图用技术解决所有问题</h4><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h2><h3 id="网站架构模式"><a href="#网站架构模式" class="headerlink" title="网站架构模式"></a>网站架构模式</h3><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><h4 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h4><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><h3 id="架构模式在新浪微博的应用"><a href="#架构模式在新浪微博的应用" class="headerlink" title="架构模式在新浪微博的应用"></a>架构模式在新浪微博的应用</h3><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站核心架构要素"><a href="#大型网站核心架构要素" class="headerlink" title="大型网站核心架构要素"></a>大型网站核心架构要素</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="瞬间响应：网站的高性能架构"><a href="#瞬间响应：网站的高性能架构" class="headerlink" title="瞬间响应：网站的高性能架构"></a>瞬间响应：网站的高性能架构</h2><h3 id="网站性能测试"><a href="#网站性能测试" class="headerlink" title="网站性能测试"></a>网站性能测试</h3><h4 id="不同视角下的网站性能"><a href="#不同视角下的网站性能" class="headerlink" title="不同视角下的网站性能"></a>不同视角下的网站性能</h4><h4 id="性能测试指标"><a href="#性能测试指标" class="headerlink" title="性能测试指标"></a>性能测试指标</h4><h4 id="性能测试方法"><a href="#性能测试方法" class="headerlink" title="性能测试方法"></a>性能测试方法</h4><h4 id="性能测试报告"><a href="#性能测试报告" class="headerlink" title="性能测试报告"></a>性能测试报告</h4><h4 id="性能测试策略"><a href="#性能测试策略" class="headerlink" title="性能测试策略"></a>性能测试策略</h4><h3 id="Web前端性能优化"><a href="#Web前端性能优化" class="headerlink" title="Web前端性能优化"></a>Web前端性能优化</h3><h4 id="浏览器访问优化"><a href="#浏览器访问优化" class="headerlink" title="浏览器访问优化"></a>浏览器访问优化</h4><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><h3 id="应用服务器性能优化"><a href="#应用服务器性能优化" class="headerlink" title="应用服务器性能优化"></a>应用服务器性能优化</h3><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><h4 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h4><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><h3 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h3><h4 id="机械硬盘-vs-固态硬盘"><a href="#机械硬盘-vs-固态硬盘" class="headerlink" title="机械硬盘 vs 固态硬盘"></a>机械硬盘 vs 固态硬盘</h4><h4 id="B-树-vs-LSM树"><a href="#B-树-vs-LSM树" class="headerlink" title="B+树 vs LSM树"></a>B+树 vs LSM树</h4><h4 id="RAID-vs-HDFS"><a href="#RAID-vs-HDFS" class="headerlink" title="RAID vs HDFS"></a>RAID vs HDFS</h4><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><h2 id="万无一失：网站的高可用框架"><a href="#万无一失：网站的高可用框架" class="headerlink" title="万无一失：网站的高可用框架"></a>万无一失：网站的高可用框架</h2><h3 id="网站可用性的度量与考核"><a href="#网站可用性的度量与考核" class="headerlink" title="网站可用性的度量与考核"></a>网站可用性的度量与考核</h3><h4 id="网站可用性度量"><a href="#网站可用性度量" class="headerlink" title="网站可用性度量"></a>网站可用性度量</h4><h4 id="网站可用性考核"><a href="#网站可用性考核" class="headerlink" title="网站可用性考核"></a>网站可用性考核</h4><h3 id="高可用的网站架构"><a href="#高可用的网站架构" class="headerlink" title="高可用的网站架构"></a>高可用的网站架构</h3><h3 id="高可用的应用"><a href="#高可用的应用" class="headerlink" title="高可用的应用"></a>高可用的应用</h3><h4 id="通过负载均衡进行无状态服务的失效转移"><a href="#通过负载均衡进行无状态服务的失效转移" class="headerlink" title="通过负载均衡进行无状态服务的失效转移"></a>通过负载均衡进行无状态服务的失效转移</h4><h4 id="应用服务器集群的Session管理"><a href="#应用服务器集群的Session管理" class="headerlink" title="应用服务器集群的Session管理"></a>应用服务器集群的Session管理</h4><h3 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h3><h3 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h3><h4 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h4><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h4 id="失效转移"><a href="#失效转移" class="headerlink" title="失效转移"></a>失效转移</h4><h3 id="高可用网站的软件质量保证"><a href="#高可用网站的软件质量保证" class="headerlink" title="高可用网站的软件质量保证"></a>高可用网站的软件质量保证</h3><h4 id="网站发布"><a href="#网站发布" class="headerlink" title="网站发布"></a>网站发布</h4><h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><h4 id="预发布验证"><a href="#预发布验证" class="headerlink" title="预发布验证"></a>预发布验证</h4><h4 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h4><h4 id="自动化发布"><a href="#自动化发布" class="headerlink" title="自动化发布"></a>自动化发布</h4><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><h3 id="网站运行监控"><a href="#网站运行监控" class="headerlink" title="网站运行监控"></a>网站运行监控</h3><h4 id="监控数据采集"><a href="#监控数据采集" class="headerlink" title="监控数据采集"></a>监控数据采集</h4><h4 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h4><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><h2 id="永无止境：网站的伸缩性架构"><a href="#永无止境：网站的伸缩性架构" class="headerlink" title="永无止境：网站的伸缩性架构"></a>永无止境：网站的伸缩性架构</h2><h3 id="网站架构的伸缩性设计"><a href="#网站架构的伸缩性设计" class="headerlink" title="网站架构的伸缩性设计"></a>网站架构的伸缩性设计</h3><h4 id="不同功能进行物理分离实现伸缩"><a href="#不同功能进行物理分离实现伸缩" class="headerlink" title="不同功能进行物理分离实现伸缩"></a>不同功能进行物理分离实现伸缩</h4><h4 id="单一功能通过集群规模实现伸缩"><a href="#单一功能通过集群规模实现伸缩" class="headerlink" title="单一功能通过集群规模实现伸缩"></a>单一功能通过集群规模实现伸缩</h4><h3 id="应用服务器集群的伸缩性设计"><a href="#应用服务器集群的伸缩性设计" class="headerlink" title="应用服务器集群的伸缩性设计"></a>应用服务器集群的伸缩性设计</h3><h4 id="HTTP重定向负载均衡"><a href="#HTTP重定向负载均衡" class="headerlink" title="HTTP重定向负载均衡"></a>HTTP重定向负载均衡</h4><h4 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h4><h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><h4 id="IP负载均衡"><a href="#IP负载均衡" class="headerlink" title="IP负载均衡"></a>IP负载均衡</h4><h4 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h4><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><h3 id="分布式缓存集群的伸缩性设计"><a href="#分布式缓存集群的伸缩性设计" class="headerlink" title="分布式缓存集群的伸缩性设计"></a>分布式缓存集群的伸缩性设计</h3><h4 id="Memcached分布式缓存集群的访问模型"><a href="#Memcached分布式缓存集群的访问模型" class="headerlink" title="Memcached分布式缓存集群的访问模型"></a>Memcached分布式缓存集群的访问模型</h4><h4 id="Memcached分布式缓存集群的伸缩性挑战"><a href="#Memcached分布式缓存集群的伸缩性挑战" class="headerlink" title="Memcached分布式缓存集群的伸缩性挑战"></a>Memcached分布式缓存集群的伸缩性挑战</h4><h4 id="分布式缓存的一致性Hash算法"><a href="#分布式缓存的一致性Hash算法" class="headerlink" title="分布式缓存的一致性Hash算法"></a>分布式缓存的一致性Hash算法</h4><h3 id="数据存储服务器集群的伸缩性设计"><a href="#数据存储服务器集群的伸缩性设计" class="headerlink" title="数据存储服务器集群的伸缩性设计"></a>数据存储服务器集群的伸缩性设计</h3><h4 id="关系数据库集群的伸缩性设计"><a href="#关系数据库集群的伸缩性设计" class="headerlink" title="关系数据库集群的伸缩性设计"></a>关系数据库集群的伸缩性设计</h4><h4 id="NoSQL数据库的伸缩性设计"><a href="#NoSQL数据库的伸缩性设计" class="headerlink" title="NoSQL数据库的伸缩性设计"></a>NoSQL数据库的伸缩性设计</h4><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><h2 id="随需应变：网站的可扩展架构"><a href="#随需应变：网站的可扩展架构" class="headerlink" title="随需应变：网站的可扩展架构"></a>随需应变：网站的可扩展架构</h2><h3 id="构建可扩展的网站架构"><a href="#构建可扩展的网站架构" class="headerlink" title="构建可扩展的网站架构"></a>构建可扩展的网站架构</h3><h3 id="利用分布式消息队列降低系统耦合性"><a href="#利用分布式消息队列降低系统耦合性" class="headerlink" title="利用分布式消息队列降低系统耦合性"></a>利用分布式消息队列降低系统耦合性</h3><h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><h3 id="利用分布式服务打造可复用的业务平台"><a href="#利用分布式服务打造可复用的业务平台" class="headerlink" title="利用分布式服务打造可复用的业务平台"></a>利用分布式服务打造可复用的业务平台</h3><h4 id="Web-Service-与企业级分布式服务"><a href="#Web-Service-与企业级分布式服务" class="headerlink" title="Web Service 与企业级分布式服务"></a>Web Service 与企业级分布式服务</h4><h4 id="大型网站分布式服务的需求与特点"><a href="#大型网站分布式服务的需求与特点" class="headerlink" title="大型网站分布式服务的需求与特点"></a>大型网站分布式服务的需求与特点</h4><h4 id="分布式服务框架设计"><a href="#分布式服务框架设计" class="headerlink" title="分布式服务框架设计"></a>分布式服务框架设计</h4><h3 id="可扩展的数据结构"><a href="#可扩展的数据结构" class="headerlink" title="可扩展的数据结构"></a>可扩展的数据结构</h3><h3 id="利用开放平台建设网站生态圈"><a href="#利用开放平台建设网站生态圈" class="headerlink" title="利用开放平台建设网站生态圈"></a>利用开放平台建设网站生态圈</h3><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><h2 id="固若金汤：网站的安全架构"><a href="#固若金汤：网站的安全架构" class="headerlink" title="固若金汤：网站的安全架构"></a>固若金汤：网站的安全架构</h2><h3 id="道高一尺魔高一丈的网站应用攻击与防御"><a href="#道高一尺魔高一丈的网站应用攻击与防御" class="headerlink" title="道高一尺魔高一丈的网站应用攻击与防御"></a>道高一尺魔高一丈的网站应用攻击与防御</h3><h4 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h4><h4 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h4><h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><h4 id="其他攻击和漏洞"><a href="#其他攻击和漏洞" class="headerlink" title="其他攻击和漏洞"></a>其他攻击和漏洞</h4><h4 id="Web应用防火墙"><a href="#Web应用防火墙" class="headerlink" title="Web应用防火墙"></a>Web应用防火墙</h4><h4 id="网站安全漏铜扫描"><a href="#网站安全漏铜扫描" class="headerlink" title="网站安全漏铜扫描"></a>网站安全漏铜扫描</h4><h3 id="信息加密技术及密钥安全管理"><a href="#信息加密技术及密钥安全管理" class="headerlink" title="信息加密技术及密钥安全管理"></a>信息加密技术及密钥安全管理</h3><h4 id="单向三列加密"><a href="#单向三列加密" class="headerlink" title="单向三列加密"></a>单向三列加密</h4><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><h4 id="密钥安全管理"><a href="#密钥安全管理" class="headerlink" title="密钥安全管理"></a>密钥安全管理</h4><h3 id="信息过滤与反垃圾"><a href="#信息过滤与反垃圾" class="headerlink" title="信息过滤与反垃圾"></a>信息过滤与反垃圾</h3><h4 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h4><h4 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h4><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><h3 id="电子商务风险控制"><a href="#电子商务风险控制" class="headerlink" title="电子商务风险控制"></a>电子商务风险控制</h3><h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><h4 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h4><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="淘宝网的架构演化案例分析"><a href="#淘宝网的架构演化案例分析" class="headerlink" title="淘宝网的架构演化案例分析"></a>淘宝网的架构演化案例分析</h2><h3 id="淘宝网的业务发展历程"><a href="#淘宝网的业务发展历程" class="headerlink" title="淘宝网的业务发展历程"></a>淘宝网的业务发展历程</h3><h3 id="淘宝网技术架构演化"><a href="#淘宝网技术架构演化" class="headerlink" title="淘宝网技术架构演化"></a>淘宝网技术架构演化</h3><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><h2 id="维基百科的高性能架构设计分析"><a href="#维基百科的高性能架构设计分析" class="headerlink" title="维基百科的高性能架构设计分析"></a>维基百科的高性能架构设计分析</h2><h3 id="Wikipedia-网站整体架构"><a href="#Wikipedia-网站整体架构" class="headerlink" title="Wikipedia 网站整体架构"></a>Wikipedia 网站整体架构</h3><h3 id="Wikipedia-性能优化策略"><a href="#Wikipedia-性能优化策略" class="headerlink" title="Wikipedia 性能优化策略"></a>Wikipedia 性能优化策略</h3><h4 id="Wikipedia-前端性能优化"><a href="#Wikipedia-前端性能优化" class="headerlink" title="Wikipedia 前端性能优化"></a>Wikipedia 前端性能优化</h4><h4 id="Wikipedia-服务端性能优化"><a href="#Wikipedia-服务端性能优化" class="headerlink" title="Wikipedia 服务端性能优化"></a>Wikipedia 服务端性能优化</h4><h4 id="Wikipedia-后端性能优化"><a href="#Wikipedia-后端性能优化" class="headerlink" title="Wikipedia 后端性能优化"></a>Wikipedia 后端性能优化</h4><h2 id="海量分布式存储系统Doris的高可用架构设计分析"><a href="#海量分布式存储系统Doris的高可用架构设计分析" class="headerlink" title="海量分布式存储系统Doris的高可用架构设计分析"></a>海量分布式存储系统Doris的高可用架构设计分析</h2><h3 id="分布式存储系统的高可用架构"><a href="#分布式存储系统的高可用架构" class="headerlink" title="分布式存储系统的高可用架构"></a>分布式存储系统的高可用架构</h3><h3 id="不同故障情况下的高可用解决方案"><a href="#不同故障情况下的高可用解决方案" class="headerlink" title="不同故障情况下的高可用解决方案"></a>不同故障情况下的高可用解决方案</h3><h4 id="分布式存储系统的故障分类"><a href="#分布式存储系统的故障分类" class="headerlink" title="分布式存储系统的故障分类"></a>分布式存储系统的故障分类</h4><h4 id="正常情况下系统访问结构"><a href="#正常情况下系统访问结构" class="headerlink" title="正常情况下系统访问结构"></a>正常情况下系统访问结构</h4><h4 id="瞬时故障的高可用解决方案"><a href="#瞬时故障的高可用解决方案" class="headerlink" title="瞬时故障的高可用解决方案"></a>瞬时故障的高可用解决方案</h4><h4 id="临时故障的高可用解决方案"><a href="#临时故障的高可用解决方案" class="headerlink" title="临时故障的高可用解决方案"></a>临时故障的高可用解决方案</h4><h4 id="永久故障的高可用解决方案"><a href="#永久故障的高可用解决方案" class="headerlink" title="永久故障的高可用解决方案"></a>永久故障的高可用解决方案</h4><h2 id="网购秒杀系统架构设计案例分析"><a href="#网购秒杀系统架构设计案例分析" class="headerlink" title="网购秒杀系统架构设计案例分析"></a>网购秒杀系统架构设计案例分析</h2><h3 id="秒杀活动的技术挑战"><a href="#秒杀活动的技术挑战" class="headerlink" title="秒杀活动的技术挑战"></a>秒杀活动的技术挑战</h3><h3 id="秒杀系统的应对策略"><a href="#秒杀系统的应对策略" class="headerlink" title="秒杀系统的应对策略"></a>秒杀系统的应对策略</h3><h3 id="秒杀系统架构设计"><a href="#秒杀系统架构设计" class="headerlink" title="秒杀系统架构设计"></a>秒杀系统架构设计</h3><h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站典型故障案例分析"><a href="#大型网站典型故障案例分析" class="headerlink" title="大型网站典型故障案例分析"></a>大型网站典型故障案例分析</h2><h3 id="写日志也会引发故障"><a href="#写日志也会引发故障" class="headerlink" title="写日志也会引发故障"></a>写日志也会引发故障</h3><h3 id="高并发访问数据库引发的故障"><a href="#高并发访问数据库引发的故障" class="headerlink" title="高并发访问数据库引发的故障"></a>高并发访问数据库引发的故障</h3><h3 id="高并发情况下锁引发的故障"><a href="#高并发情况下锁引发的故障" class="headerlink" title="高并发情况下锁引发的故障"></a>高并发情况下锁引发的故障</h3><h3 id="缓存引发的故障"><a href="#缓存引发的故障" class="headerlink" title="缓存引发的故障"></a>缓存引发的故障</h3><h3 id="应用启动不同步引发的故障"><a href="#应用启动不同步引发的故障" class="headerlink" title="应用启动不同步引发的故障"></a>应用启动不同步引发的故障</h3><h3 id="大文件读写独占磁盘引发的故障"><a href="#大文件读写独占磁盘引发的故障" class="headerlink" title="大文件读写独占磁盘引发的故障"></a>大文件读写独占磁盘引发的故障</h3><h3 id="滥用生产环境引发的故障"><a href="#滥用生产环境引发的故障" class="headerlink" title="滥用生产环境引发的故障"></a>滥用生产环境引发的故障</h3><h3 id="不规范的流程引发的故障"><a href="#不规范的流程引发的故障" class="headerlink" title="不规范的流程引发的故障"></a>不规范的流程引发的故障</h3><h3 id="不好的编程习惯引发的故障"><a href="#不好的编程习惯引发的故障" class="headerlink" title="不好的编程习惯引发的故障"></a>不好的编程习惯引发的故障</h3><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><h1 id="架构师"><a href="#架构师" class="headerlink" title="架构师"></a>架构师</h1><h2 id="架构师领导艺术"><a href="#架构师领导艺术" class="headerlink" title="架构师领导艺术"></a>架构师领导艺术</h2><h3 id="关注人而不是产品"><a href="#关注人而不是产品" class="headerlink" title="关注人而不是产品"></a>关注人而不是产品</h3><h3 id="发掘人的优秀"><a href="#发掘人的优秀" class="headerlink" title="发掘人的优秀"></a>发掘人的优秀</h3><h3 id="共享美好蓝图"><a href="#共享美好蓝图" class="headerlink" title="共享美好蓝图"></a>共享美好蓝图</h3><h3 id="共同参与架构"><a href="#共同参与架构" class="headerlink" title="共同参与架构"></a>共同参与架构</h3><h3 id="学会妥协"><a href="#学会妥协" class="headerlink" title="学会妥协"></a>学会妥协</h3><h3 id="成就他人"><a href="#成就他人" class="headerlink" title="成就他人"></a>成就他人</h3><h2 id="网站架构师职场攻略"><a href="#网站架构师职场攻略" class="headerlink" title="网站架构师职场攻略"></a>网站架构师职场攻略</h2><h3 id="发现问题，寻找突破"><a href="#发现问题，寻找突破" class="headerlink" title="发现问题，寻找突破"></a>发现问题，寻找突破</h3><h3 id="提出问题，寻求支持"><a href="#提出问题，寻求支持" class="headerlink" title="提出问题，寻求支持"></a>提出问题，寻求支持</h3><h3 id="解决问题，达成绩效"><a href="#解决问题，达成绩效" class="headerlink" title="解决问题，达成绩效"></a>解决问题，达成绩效</h3><h2 id="漫话网站架构师"><a href="#漫话网站架构师" class="headerlink" title="漫话网站架构师"></a>漫话网站架构师</h2><h3 id="按作用划分架构师"><a href="#按作用划分架构师" class="headerlink" title="按作用划分架构师"></a>按作用划分架构师</h3><h3 id="按效果划分架构师"><a href="#按效果划分架构师" class="headerlink" title="按效果划分架构师"></a>按效果划分架构师</h3><h3 id="按职责角色划分架构师"><a href="#按职责角色划分架构师" class="headerlink" title="按职责角色划分架构师"></a>按职责角色划分架构师</h3><h3 id="安关注层次划分架构师"><a href="#安关注层次划分架构师" class="headerlink" title="安关注层次划分架构师"></a>安关注层次划分架构师</h3><h3 id="安关注层次划分架构师-1"><a href="#安关注层次划分架构师-1" class="headerlink" title="安关注层次划分架构师"></a>安关注层次划分架构师</h3><h3 id="安口碑划分架构师"><a href="#安口碑划分架构师" class="headerlink" title="安口碑划分架构师"></a>安口碑划分架构师</h3><h3 id="非主流方式划分架构师"><a href="#非主流方式划分架构师" class="headerlink" title="非主流方式划分架构师"></a>非主流方式划分架构师</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/05/JavaScript%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/05/JavaScript%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">JavaScript闭包和高阶函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-05 20:28:22" itemprop="dateCreated datePublished" datetime="2017-06-05T20:28:22+08:00">2017-06-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的作用域，就是指变量的有效范围。<br>当在函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量。这种做法会造成命名冲突。<br>在函数内声明的变量是局部变量，只有在函数内才能访问到该变量。因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境 创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到 内的。  </p>
<h3 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h3><p>普通函数，函数结束，局部变量的生命周期也将结束。但闭包不同，在闭包中，函数结束，局部变量的生命周期不一定结束。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var func = function() &#123;</span><br><span class="line">	var a = 1;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		a++;</span><br><span class="line">		console.log(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = func();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>当执行 var f &#x3D; func();时，f 返回了一个匿名函数的引用，它可以访问到 func() 被调用时产生的环境，而局部变量 a 一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起 来被延续了。</p>
<p>应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;1&lt;/div&gt;</span><br><span class="line">&lt;div&gt;2&lt;/div&gt;</span><br><span class="line">&lt;div&gt;3&lt;/div&gt;</span><br><span class="line">&lt;div&gt;4&lt;/div&gt;</span><br><span class="line">&lt;div&gt;5&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	var nodes = document.getElementsByTagName(&#x27;div&#x27;);</span><br><span class="line">	for (var i = 0, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">		nodes[i].onclick = function() &#123;</span><br><span class="line">			console.log(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，无论触发哪个数的事件，输出都是5。因为 div 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是 5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。<br>解决方法是使用闭包，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链 中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i，如果有 5 个 div，这里的 i 就分别 是 0,1,2,3,4。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">	(function(i) &#123;</span><br><span class="line">		nodes[i].onclick = function() &#123;</span><br><span class="line">			console.log(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var Type = &#123;&#125;;</span><br><span class="line">for (var i = 0, type; type = [&#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27;][i++];) &#123;</span><br><span class="line">	(function(type)&#123;</span><br><span class="line">		Type[&#x27;is&#x27;+type] = function(obj) &#123;</span><br><span class="line">			return Object.prototype.toString.call(obj) === &#x27;[object &#x27; + type + &#x27;]&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(type)</span><br><span class="line">&#125;</span><br><span class="line">console.log(Type.isArray([]));</span><br><span class="line">console.log(Type.isString(&#x27;str&#x27;));</span><br><span class="line">console.log(Type);</span><br><span class="line">	</span><br><span class="line">//输出</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">&#123;isString: ƒ, isArray: ƒ, isNumber: ƒ&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h3><ol>
<li><p>封装变量<br>如果一个变量仅仅在函数中被使用，可以把它封闭在函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function() &#123;</span><br><span class="line">	var cache = &#123;&#125;;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args = Array.prototype.join.call(arguments, &#x27;,&#x27;);</span><br><span class="line">		if (args in cache) &#123;</span><br><span class="line">			return cache[args];</span><br><span class="line">		&#125;</span><br><span class="line">		var a = 1;</span><br><span class="line">		for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">			a = a * arguments[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return cache[args] = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(mult(1,2,3));</span><br><span class="line">console.log(mult(4,5,6));</span><br><span class="line">//输出</span><br><span class="line">6</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<p> 如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些 小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他 9 地方使用，最好是把它们用闭包封闭起来。代码如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var mult = (function() &#123;</span><br><span class="line">	var cache = &#123;&#125;;</span><br><span class="line">	var calculate = function() &#123;</span><br><span class="line">		var a = 1;</span><br><span class="line">		for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">			a = a * arguments[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args = Array.prototype.join.call(arguments, &#x27;,&#x27;);</span><br><span class="line">		if (args in cache) &#123;</span><br><span class="line">			return cache[args];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return cache[args] = calculate.apply(null, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(mult(1,2,3));</span><br><span class="line">console.log(mult(4,5,6));</span><br><span class="line">//输出</span><br><span class="line">6</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
</li>
<li><p>延续局部变量的寿命<br>img 对象经常用于进行数据上报，如下所示:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var report = function( src )&#123; var img = new Image(); 		img.src = src;</span><br><span class="line">&#125;;</span><br><span class="line">report( &#x27;http://xxx.com/getUserInfo&#x27; );</span><br></pre></td></tr></table></figure></li>
</ol>
<p>但是通过查询后台的记录得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失30%左右的数据，也就是说，report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后，img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。<br>现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题:</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var report = (function()&#123; </span><br><span class="line">	var imgs = [];</span><br><span class="line">	return function( src )&#123;</span><br><span class="line">		var img = new Image(); </span><br><span class="line">		imgs.push( img ); </span><br><span class="line">		img.src = src;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="闭包和面向对象设计"><a href="#闭包和面向对象设计" class="headerlink" title="闭包和面向对象设计"></a>闭包和面向对象设计</h3><p>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然，也可以使用闭包来实现一个完整的面向对象系统。<br>闭包实现：     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var extent = function() &#123;</span><br><span class="line">	var value = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		call: function() &#123;</span><br><span class="line">			value++,</span><br><span class="line">			console.log(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var extent = extent();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br><span class="line">//输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>面向对象的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var extent = &#123; </span><br><span class="line">	value: 0,</span><br><span class="line">	call: function()&#123; </span><br><span class="line">		this.value++;</span><br><span class="line">		console.log( this.value ); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">extent.call(); </span><br><span class="line">extent.call(); </span><br><span class="line">extent.call();</span><br><span class="line">//输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3 </span><br><span class="line">//或者：</span><br><span class="line">var Extent = function() &#123;</span><br><span class="line">	this.value = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Extent.prototype.call1 = function() &#123;</span><br><span class="line">	this.value++;</span><br><span class="line">	console.log(this.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var extent = new Extent();</span><br><span class="line">extent.call1();</span><br><span class="line">extent.call1();</span><br><span class="line">extent.call1();</span><br><span class="line">//输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3 </span><br></pre></td></tr></table></figure>

<h3 id="用闭包实现命令模式"><a href="#用闭包实现命令模式" class="headerlink" title="用闭包实现命令模式"></a>用闭包实现命令模式</h3><h3 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h3><p>闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。</p>
<p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。</p>
<p>跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象 的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。</p>
<p>同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运 行时，就会删除这些值并回收它们占用的内存。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是指满足以下条件之一的函数。</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h3 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h3><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><h5 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a>Array.prototype.sort</h5><p>Array.prototype.sort接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; [1,4,3].sort(function(a,b)&#123;</span><br><span class="line">... return a -b;</span><br><span class="line">... &#125;)</span><br><span class="line">[ 1, 3, 4 ]</span><br><span class="line">&gt; [1,4,3].sort(function(a,b)&#123;</span><br><span class="line">... return b - a;</span><br><span class="line">... &#125;)</span><br><span class="line">[ 4, 3, 1 ]</span><br></pre></td></tr></table></figure>

<h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><p>相比把函数作为参数传递，函数当作返回值输出的应用场景也许更多，也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。</p>
<h5 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var isType = function(type) &#123;</span><br><span class="line">	return function(obj) &#123;</span><br><span class="line">		return Object.prototype.toString.call(obj) === &#x27;[object &#x27; + type + &#x27;]&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var isArray = isType(&#x27;Array&#x27;);</span><br><span class="line">var isString = isType(&#x27;String&#x27;);</span><br><span class="line">var isNumber = isType(&#x27;Number&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(isArray([1,2,3,4]));</span><br><span class="line">console.log(isString(&#x27;abcd&#x27;));</span><br><span class="line">console.log(isString(123));</span><br><span class="line">console.log(isNumber(123));</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以用循环语句，批量注册这些isType函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var Type = &#123;&#125;;</span><br><span class="line">for (var i = 0, type; type = [&#x27;String&#x27;, &#x27;Array&#x27;, &#x27;Number&#x27;][i++];) &#123;</span><br><span class="line">	(function(type)&#123;</span><br><span class="line">		Type[&#x27;is&#x27; + type] = function(obj) &#123;</span><br><span class="line">			return Object.prototype.toString.call(obj) === &#x27;[object &#x27; + type + &#x27;]&#x27;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(type)</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Type.isArray([]));</span><br><span class="line">console.log(Type.isString(&#x27;123&#x27;));</span><br><span class="line">console.log(Type.isNumber(123));</span><br><span class="line">//输出</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">var getSingle = function(fn) &#123;</span><br><span class="line">	var ret;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return ret || (ret = fn.apply(this, arguments))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var getScript = getSingle(function() &#123;</span><br><span class="line">	return document.createElement(&#x27;script&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var script1 = getScript();</span><br><span class="line">var script2 = getScript();</span><br><span class="line"></span><br><span class="line">console.log(script1 === script2)   //true</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h3><p>AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些 跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn) &#123;</span><br><span class="line">	var __self = this;  //保存原函数的引用</span><br><span class="line">	return function() &#123;  //返回包含了原函数和新函数的“代理”函数</span><br><span class="line">		beforefn.apply(this, arguments);  //执行新函数，修正this</span><br><span class="line">		return __self.apply(this, arguments);  //执行原函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Function.prototype.after = function(afterfn) &#123;</span><br><span class="line">	var __self = this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var ret = __self.apply(this, arguments);</span><br><span class="line">		afterfn.apply(this, arguments);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func = function() &#123;</span><br><span class="line">	console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func = func.before(function()&#123;</span><br><span class="line">	console.log(1);</span><br><span class="line">&#125;).after(function()&#123;</span><br><span class="line">	console.log(3);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h3><h5 id="currying"><a href="#currying" class="headerlink" title="currying"></a>currying</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var currying = function(fn) &#123;</span><br><span class="line">	var args = [];</span><br><span class="line">	return function() &#123;</span><br><span class="line">		if (arguments.length === 0) &#123;</span><br><span class="line">			return fn.apply(this, args);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			[].push.apply(args, arguments);</span><br><span class="line">			return arguments.callee</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var cost = (function()&#123;</span><br><span class="line">	var money = 0;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">			money += arguments[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return money</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">var cost = currying(cost);</span><br><span class="line">cost(100);</span><br><span class="line">cost(200);</span><br><span class="line">cost(300);</span><br><span class="line">console.log(cost()); //600</span><br></pre></td></tr></table></figure>

<h5 id="uncurrying"><a href="#uncurrying" class="headerlink" title="uncurrying"></a>uncurrying</h5><p>在我们的预期中，Array.prototype 上的方法原本只能用来操作 array 对象。但用 call 和 apply 可以把任意对象当作 this 传入某个方法，这样一来，方法中用到 this 的地方就不再局限于原来规定的对象，而是加以泛化并得到更广的适用性。那么有没有办法把泛化 this 的过程提取出来呢? uncurrying 就是用来解决这个问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.uncurrying = function() &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var obj = Array.prototype.shift.call(arguments);</span><br><span class="line">		return self.apply(obj, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//在类数组对象 arguments 借用 Array.prototype 的方法之前，先把 Array.prototype.push.call这句代码转换为一个通用的 push 函数</span><br><span class="line">var push = Array.prototype.push.uncurrying();</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">	console.log(arguments);</span><br><span class="line">	push(arguments, 4);</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;)(1,2,3)</span><br></pre></td></tr></table></figure>

<p>通过 uncurrying 的方式，Array.prototype.push.call 变成了一个通用的 push 函数。这样一来， push 函数的作用就跟 Array.prototype.push 一样了，同样不仅仅局限于只能操作 array 对象。而 对于使用者而言，调用 push 函数的方式也显得更加简洁和意图明了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0, fn, ary = [&#x27;push&#x27;, &#x27;shift&#x27;, &#x27;forEach&#x27;]; fn = ary[i++];) &#123;</span><br><span class="line">	Array[fn] = Array.prototype[fn].uncurrying();</span><br><span class="line">&#125;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">	&#x27;length&#x27;: 3,</span><br><span class="line">	&#x27;0&#x27;: 1,</span><br><span class="line">	&#x27;1&#x27;: 2,</span><br><span class="line">	&#x27;2&#x27;: 3</span><br><span class="line">&#125;</span><br><span class="line">Array.push(obj, 4);</span><br><span class="line">console.log(obj.length);</span><br><span class="line">var first = Array.shift(obj);</span><br><span class="line">console.log(first);</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">Array.forEach(obj, function(i, n)&#123;</span><br><span class="line">	console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">&#123;0: 2, 1: 3, 2: 4, length: 3&#125;</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var throttle = function(fn, interval) &#123;</span><br><span class="line">	var __self = fn;</span><br><span class="line">	var timer;</span><br><span class="line">	var firstTime = true;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args = arguments;</span><br><span class="line">		var __me = this;</span><br><span class="line">		if (firstTime) &#123;</span><br><span class="line">			__self.apply(__me, args);</span><br><span class="line">			return firstTime = false</span><br><span class="line">		&#125;</span><br><span class="line">		if (timer) &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		timer = setTimeout(function() &#123;</span><br><span class="line">			clearTimeout(timer);</span><br><span class="line">			timer = null;</span><br><span class="line">			__self.apply(__me, args);</span><br><span class="line">		&#125;, interval || 500)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">		</span><br><span class="line">window.onresize = throttle(function() &#123;</span><br><span class="line">	console.log(1);</span><br><span class="line">&#125;, 500)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/03/JavaScript%E4%B8%AD%E7%9A%84this%E3%80%81call%E5%92%8Capply/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/03/JavaScript%E4%B8%AD%E7%9A%84this%E3%80%81call%E5%92%8Capply/" class="post-title-link" itemprop="url">JavaScript中的this、call和apply</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-03 16:13:48" itemprop="dateCreated datePublished" datetime="2017-06-03T16:13:48+08:00">2017-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。      </p>
<h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4中：</p>
<ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li>Function.prototype.call或Function.prototype.apply调用</li>
</ul>
<h5 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h5><p>当作为对象的方法被调用时，this指向该对象。      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var obj = &#123;</span><br><span class="line">... a: 1,</span><br><span class="line">... getA: function() &#123;</span><br><span class="line">..... console.log(this === obj);</span><br><span class="line">..... console.log(this.a);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.getA()</span><br><span class="line">true</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的this总是指向全局对象。在浏览器的JavaScript中，这个全局对象是window对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">window.name = &quot;globalName&quot;;</span><br><span class="line">var getName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getName());</span><br><span class="line"></span><br><span class="line">var myObj = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;,</span><br><span class="line">	getName: function() &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getName1 = myObj.getName;</span><br><span class="line">console.log(getName1());</span><br><span class="line">console.log(myObj.getName());</span><br><span class="line"></span><br><span class="line">//	输出</span><br><span class="line">//	globalName</span><br><span class="line">//	globalName</span><br><span class="line">// 	sven</span><br></pre></td></tr></table></figure>

<p>有种情况，比如在div节点的事件函数内部，有个局部的callback方法，callback被视为普通函数调用，callback内部的this指向了window，但我们往往是想让它指向该div节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;this is a div&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	window.id = &#x27;window&#x27;;</span><br><span class="line">	document.getElementById(&#x27;div1&#x27;).onclick = function() &#123;</span><br><span class="line">		alert(this.id);   //div1</span><br><span class="line">		var callback = function() &#123;</span><br><span class="line">			alert(this.id);   //window</span><br><span class="line">		&#125;</span><br><span class="line">		callback();</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>一种简单的解决方案，可以用一个变量保存div节点的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#x27;div1&#x27;).onclick = function() &#123;</span><br><span class="line">	alert(this.id);   //div1</span><br><span class="line">	var that = this;</span><br><span class="line">	var callback = function() &#123;</span><br><span class="line">		alert(that.id);   //window</span><br><span class="line">	&#125;</span><br><span class="line">	callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">	&quot;use strict&quot;</span><br><span class="line">	alert(this);    //undefined</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h5 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h5><p>JavaScript中没有类，但是可以从构造器中创建对象，同时也提供了new运算符，使得构造器看起来更像一个类。<br>除了宿主提供的一些内置函数，大部分JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass = function() &#123;</span><br><span class="line">... this.name = &#x27;sven&#x27;;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj = new MyClass();</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#x27;sven&#x27;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass = function() &#123;</span><br><span class="line">... this.name = &#x27;sven&#x27;;</span><br><span class="line">... return &#123;</span><br><span class="line">..... name: &#x27;anne&#x27;,</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj = new MyClass();</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#x27;anne&#x27;</span><br></pre></td></tr></table></figure>

<p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass = function() &#123;</span><br><span class="line">... this.name = &#x27;sven&#x27;;</span><br><span class="line">... return &#x27;anne&#x27;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj = new MyClass()</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#x27;sven&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="Function-prototype-call或Function-prototype-apply调用"><a href="#Function-prototype-call或Function-prototype-apply调用" class="headerlink" title="Function.prototype.call或Function.prototype.apply调用"></a>Function.prototype.call或Function.prototype.apply调用</h5><p>跟普通的函数调用相比，用Function.prototype.call或Function.prototype.apply可以动态地改变传入函数的this。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; var obj1 = &#123;</span><br><span class="line">... name: &#x27;sven&#x27;,</span><br><span class="line">... getName: function() &#123;</span><br><span class="line">..... return this.name;</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj2 = &#123;</span><br><span class="line">... name: &#x27;anne&#x27;,</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; obj1.getName()</span><br><span class="line">&#x27;sven&#x27;</span><br><span class="line">&gt; obj1.getName.call(obj2)</span><br><span class="line">&#x27;anne&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><h5 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h5><p>它们的作用一模一样，区别仅在于传入参数形式的不同。<br>apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以是类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; var func = function(a,b,c) &#123;</span><br><span class="line">... console.log([a,b,c])</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; func.apply(null, [1,2,3])</span><br><span class="line">[ 1, 2, 3 ]</span><br><span class="line">undefined</span><br><span class="line">//参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列 表中的 a、b、c</span><br><span class="line">&gt; func.apply(null, 1,2,3)</span><br><span class="line">TypeError: CreateListFromArrayLike called on non-object</span><br></pre></td></tr></table></figure>

<p>call是包装在apply上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call来传送参数。<br>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a,b,c) &#123;</span><br><span class="line">	console.log(a,b,c);</span><br><span class="line">	alert(this === window);   //true</span><br><span class="line">&#125;</span><br><span class="line">func.apply(null, [1,2,3]);</span><br></pre></td></tr></table></figure>

<p>但如果是在严格模式下，函数体内的 this 还是为 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a,b,c) &#123;</span><br><span class="line">	&quot;use strict&quot;</span><br><span class="line">	console.log(a,b,c)</span><br><span class="line">	console.log(this === window);</span><br><span class="line">	console.log(this === null);</span><br><span class="line">&#125;</span><br><span class="line">func.apply(null, [1,2,3])</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">1 2 3</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.max.apply(null,[1,23,5,2,3,6])</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<h4 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h4><h5 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h5><p>场景一：      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">	name: &#x27;anne&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var getName = function() &#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line">getName.call(obj1);</span><br><span class="line">getName.call(obj2);</span><br><span class="line">//输出</span><br><span class="line">window</span><br><span class="line">sven</span><br><span class="line">anne</span><br></pre></td></tr></table></figure>

<p>场景二：在div事件中的内部函数中，修正this        </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#x27;div1&#x27;).onclick = function() &#123;</span><br><span class="line">	console.log(this.id);</span><br><span class="line">	var func = function() &#123;</span><br><span class="line">		console.log(&#x27;id:&#x27; + this.id);</span><br><span class="line">	&#125;</span><br><span class="line">	func();</span><br><span class="line">	func.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">div1</span><br><span class="line">id:undefined</span><br><span class="line">id:div1</span><br></pre></td></tr></table></figure>

<h5 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h5><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向，即使没有原生的Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return self.apply(context, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var func = function() &#123;</span><br><span class="line">	alert(this.name);    //输出sven</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>带有参数的Function.prototype.bind</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">	var self = this;   //保存原函数</span><br><span class="line">	var context = [].shift.call(arguments);  //需要绑定的this上下文</span><br><span class="line">	var args = [].slice.call(arguments);  //剩余的参数转成数组</span><br><span class="line">	return function() &#123;  //返回一个新函数</span><br><span class="line">		return self.apply(context, [].concat.call(args, [].slice.call(arguments)));</span><br><span class="line">		//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span><br><span class="line">		//并且组合两次分别传入的参数，作为新函数的参数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var func = function(a,b,c,d) &#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">	console.log([a,b,c,d]);</span><br><span class="line">&#125;.bind(obj, 1,2);</span><br><span class="line">func(3, 4);</span><br><span class="line">//输出</span><br><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h5 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var A = function(name) &#123;</span><br><span class="line">	this.name = name</span><br><span class="line">&#125;</span><br><span class="line">var B = function() &#123;</span><br><span class="line">	A.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.getName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var b = new B(&#x27;sven&#x27;);</span><br><span class="line">console.log(b.getName());</span><br><span class="line">//输出</span><br><span class="line">sven</span><br></pre></td></tr></table></figure>

<p>另一种常用的场景。<br>函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组， 所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常 会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用 Array.prototype.push:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">	Array.prototype.push.call(arguments, 3);</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;)(1,2)</span><br><span class="line">//输出</span><br><span class="line">Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></table></figure>

<p>我们可以把“任意”对象传入 Array.prototype.push。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Array.prototype.push.call(a, &#x27;first&#x27;)</span><br><span class="line">1</span><br><span class="line">&gt; a.length</span><br><span class="line">1</span><br><span class="line">&gt; a[0]</span><br><span class="line">&#x27;first&#x27;</span><br><span class="line">&gt; typeof a</span><br><span class="line">&#x27;object&#x27;</span><br></pre></td></tr></table></figure>

<p>这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版 本的 IE 浏览器中执行，必须显式地给对象 a 设置length 属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; </span><br><span class="line">	length: 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面我们之所以把“任意”两字加了双引号，是因为可以借用 Array.prototype.push 方法的对象还要满足以下两个条件</p>
<ol>
<li>对象本身要可以存取属性;</li>
<li>对象的 length 属性可读写。</li>
</ol>
<p>注：函数对象的length属性是只读属性，并不满足要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; var func = function()&#123;&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Array.prototype.push.call(func, &#x27;first&#x27;)</span><br><span class="line">TypeError: Cannot assign to read only property &#x27;length&#x27; of function &#x27;function()&#123;&#125;&#x27;</span><br><span class="line">    at Function.push (&lt;anonymous&gt;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/11/17/JavaScript4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/17/JavaScript4/" class="post-title-link" itemprop="url">JavaScript（ES6）4  --日期和时间、数学运算、正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-17 09:48:02" itemprop="dateCreated datePublished" datetime="2016-11-17T09:48:02+08:00">2016-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h4 id="构造Date对象"><a href="#构造Date对象" class="headerlink" title="构造Date对象"></a>构造Date对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; new Date()   //当前日期</span><br><span class="line">Sun Feb 17 2019 09:56:01 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">//在JavaScript中，月份是从0开始的。 0=1月</span><br><span class="line">&gt; new Date(2015, 0)</span><br><span class="line">Thu Jan 01 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14)</span><br><span class="line">Sat Feb 14 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13)</span><br><span class="line">Sat Feb 14 2015 13:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13, 30)</span><br><span class="line">Sat Feb 14 2015 13:30:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13, 30, 5);</span><br><span class="line">Sat Feb 14 2015 13:30:05 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13, 30, 5, 500);</span><br><span class="line">Sat Feb 14 2015 13:30:05 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">//传入毫秒数</span><br><span class="line">&gt; new Date(0)</span><br><span class="line">Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(1000)</span><br><span class="line">Thu Jan 01 1970 08:00:01 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(1463443200000)</span><br><span class="line">Tue May 17 2016 08:00:00 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>
<p>在JavaScript内部，时间都是以UTC存储的，然后根据当地时间（有计算机操作系统决定）进行格式化。</p>
<h4 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h4><p>Moment.js库有两个版本：一种支持时区，一种不支持。由于支持时区的版本很大（它包含全世界所有的时区信息），日常工作中可以选择不支持时区的版本。</p>
<h5 id="引用Moment-js的方式"><a href="#引用Moment-js的方式" class="headerlink" title="引用Moment.js的方式"></a>引用Moment.js的方式</h5><p><a target="_blank" rel="noopener" href="http://momentjs.cn/">Moment.js中文文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// html文件中引用</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// Node中，npm 安装</span><br><span class="line">npm install -save moment-timezone</span><br><span class="line">const moment = require(&#x27;moment-timezone&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="日期的组成"><a href="#日期的组成" class="headerlink" title="日期的组成"></a>日期的组成</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; const d = new Date(Date.UTC(1815,9,10))</span><br><span class="line">undefined</span><br><span class="line">&gt; d</span><br><span class="line">1815-10-10T00:00:00.000Z</span><br><span class="line">&gt; d.getFullYear()</span><br><span class="line">1815</span><br><span class="line">&gt; d.getMonth()</span><br><span class="line">9</span><br><span class="line">&gt; d.getDate()</span><br><span class="line">10</span><br><span class="line">&gt; d.getDay()</span><br><span class="line">2</span><br><span class="line">&gt; d.getHours()</span><br><span class="line">8</span><br><span class="line">&gt; d.getMinutes()</span><br><span class="line">0</span><br><span class="line">&gt; d.getSeconds()</span><br><span class="line">0</span><br><span class="line">&gt; d.getMilliseconds()</span><br><span class="line">0</span><br><span class="line">&gt; d.getUTCFullYear()</span><br><span class="line">1815</span><br><span class="line">&gt; d.getUTCMounth()</span><br><span class="line">TypeError: d.getUTCMounth is not a function</span><br><span class="line">&gt; d.getUTCMonth()</span><br><span class="line">9</span><br><span class="line">&gt; d.getUTCDate()</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h5 id="日期的比较"><a href="#日期的比较" class="headerlink" title="日期的比较"></a>日期的比较</h5><p>简单的日期比较，如日期A和日期B谁在前谁在后？可以使用JavaScript内建的比较运算符。因为Date实例是以数值存储日期的，所以比较运算符比较的是它们的数值大小。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; const d1 = new Date(1996, 2, 1)</span><br><span class="line">undefined</span><br><span class="line">&gt; const d2 = new Date(2009, 4, 27)</span><br><span class="line">undefined</span><br><span class="line">&gt; d1 &gt; d2</span><br><span class="line">false</span><br><span class="line">&gt; d2 &gt; d1</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h5 id="日期的四则运算"><a href="#日期的四则运算" class="headerlink" title="日期的四则运算"></a>日期的四则运算</h5><p>因为日期只是一些数字，所以可以将日期相减从而获取它们相差的毫秒数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; const d1 = new Date(1996, 2, 1)</span><br><span class="line">undefined</span><br><span class="line">&gt; const d2 = new Date(2009, 4, 27)</span><br><span class="line">undefined</span><br><span class="line">&gt; d1 - d2</span><br><span class="line">-417744000000</span><br><span class="line">&gt; d2 - d1</span><br><span class="line">417744000000</span><br></pre></td></tr></table></figure>

<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="格式化数字"><a href="#格式化数字" class="headerlink" title="格式化数字"></a>格式化数字</h3><h5 id="固定小数"><a href="#固定小数" class="headerlink" title="固定小数"></a>固定小数</h5><p>Number.prototype.toFixed，函数的输出结果是对指定小数进行四舍五入的结果。          </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; const x = 19.51;</span><br><span class="line">undefined</span><br><span class="line">&gt; x.toFixed(3);</span><br><span class="line">&#x27;19.510&#x27;</span><br><span class="line">&gt; x.toFixed(2);</span><br><span class="line">&#x27;19.51&#x27;</span><br><span class="line">&gt; x.toFixed(1);</span><br><span class="line">&#x27;19.5&#x27;</span><br><span class="line">&gt; x.toFixed(0);</span><br><span class="line">&#x27;20&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="指数符号"><a href="#指数符号" class="headerlink" title="指数符号"></a>指数符号</h5><p>Number.prototype.toExponential，函数的输出结果是四舍五入。指定的精度是小数位的个数。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const y = 3800.5;</span><br><span class="line">undefined</span><br><span class="line">&gt; y.toExponential(4);</span><br><span class="line">&#x27;3.8005e+3&#x27;</span><br><span class="line">&gt; y.toExponential(3);</span><br><span class="line">&#x27;3.801e+3&#x27;</span><br><span class="line">&gt; y.toExponential(2);</span><br><span class="line">&#x27;3.80e+3&#x27;</span><br><span class="line">&gt; y.toExponential(1);</span><br><span class="line">&#x27;3.8e+3&#x27;</span><br><span class="line">&gt; y.toExponential(0);</span><br><span class="line">&#x27;4e+3&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="固定精度"><a href="#固定精度" class="headerlink" title="固定精度"></a>固定精度</h5><p>Number.prototype.toPrecision，函数输出的结果是四舍五入，同时有一个指定位数的精度。必要时，输出会是指数。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; let z = 1000;</span><br><span class="line">undefined</span><br><span class="line">&gt; z.toPrecision(5);</span><br><span class="line">&#x27;1000.0&#x27;</span><br><span class="line">&gt; z.toPrecision(4);</span><br><span class="line">&#x27;1000&#x27;</span><br><span class="line">&gt; z.toPrecision(3);</span><br><span class="line">&#x27;1.00e+3&#x27;</span><br><span class="line">&gt; z.toPrecision(2);</span><br><span class="line">&#x27;1.0e+3&#x27;</span><br><span class="line">&gt; z.toPr</span><br></pre></td></tr></table></figure>

<h5 id="不同进制"><a href="#不同进制" class="headerlink" title="不同进制"></a>不同进制</h5><p>Number.prototype.toString，函数可以接受一个指定进制（从2到36）从而实现格式化。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const x = 12;</span><br><span class="line">undefined</span><br><span class="line">&gt; x.toString();</span><br><span class="line">&#x27;12&#x27;</span><br><span class="line">&gt; x.toString(10);</span><br><span class="line">&#x27;12&#x27;</span><br><span class="line">&gt; x.toString(16);</span><br><span class="line">&#x27;c&#x27;</span><br><span class="line">&gt; x.toString(8);</span><br><span class="line">&#x27;14&#x27;</span><br><span class="line">&gt; x.toString(2);</span><br><span class="line">&#x27;1100&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>有一些很常用且重要的常量可以用作Math对象的属性来使用。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.E;      //自然对数的底</span><br><span class="line">2.718281828459045        //圆周率</span><br><span class="line">&gt; Math.PI;</span><br><span class="line">3.141592653589793</span><br><span class="line"> </span><br><span class="line">// 常用对数这些值也都可以通过调用库方法来计算出</span><br><span class="line">&gt; Math.LN2      // 2的自然对数</span><br><span class="line">0.6931471805599453      </span><br><span class="line">&gt; Math.LN10;       // 10的自然对数</span><br><span class="line">2.302585092994046</span><br><span class="line">&gt; Math.LOG2E        // 以2为底的Math.E的对数</span><br><span class="line">1.4426950408889634</span><br><span class="line">&gt; Math.LOG10E        // 以10为底的Math.E的对数</span><br><span class="line">0.4342944819032518</span><br><span class="line"></span><br><span class="line">// 代数常数 </span><br><span class="line">&gt; Math.SQRT1_2       // 1/2 的平方根</span><br><span class="line">0.7071067811865476</span><br><span class="line">&gt; Math.SQRT2			 // 2的平方根</span><br><span class="line">1.4142135623730951</span><br></pre></td></tr></table></figure>

<h4 id="代数函数"><a href="#代数函数" class="headerlink" title="代数函数"></a>代数函数</h4><h5 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h5><p>Math.pow<br><img src="/2016/11/17/JavaScript4/pow.png" alt="幂函数"></p>
<h5 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h5><p>Math.log，在JavaScript中log表示自然对数。<br><img src="/2016/11/17/JavaScript4/log.png" alt="对数函数"></p>
<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><p><img src="/2016/11/17/JavaScript4/other.png" alt="其他函数"><br><img src="/2016/11/17/JavaScript4/other2.png" alt="其他函数"></p>
<h5 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h5><p>Math.random，函数会生成一个大于0且小于1的伪随机数字。它无法设置随机种子。<br><img src="/2016/11/17/JavaScript4/random.png" alt="伪随机数"><br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/seedrandom">seedrandom.js库</a>，使用随机种子来产生随机数       </p>
<h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><p><img src="/2016/11/17/JavaScript4/sin.png" alt="数字三角函数"></p>
<h4 id="双曲线函数"><a href="#双曲线函数" class="headerlink" title="双曲线函数"></a>双曲线函数</h4><p><img src="/2016/11/17/JavaScript4/sinh.png" alt="数字双曲线函数"><br><img src="/2016/11/17/JavaScript4/tanh.png" alt="数字双曲线函数"> </p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/10/12/JavaScript3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/12/JavaScript3/" class="post-title-link" itemprop="url">JavaScript（ES6）3  --异常处理、迭代器和生成器、异步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-12 21:46:20" itemprop="dateCreated datePublished" datetime="2016-10-12T21:46:20+08:00">2016-10-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异常和错误处理"><a href="#异常和错误处理" class="headerlink" title="异常和错误处理"></a>异常和错误处理</h2><h4 id="Error对象"><a href="#Error对象" class="headerlink" title="Error对象"></a>Error对象</h4><p>JavaScript有一个内建的Error对象，它可以用来处理任意类型的错误。可以在创建Error实例的时候提供一些错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; const err = new Error(&#x27;invalid email&#x27;)</span><br><span class="line">undefined</span><br><span class="line">&gt; err instanceof Error</span><br><span class="line">true </span><br></pre></td></tr></table></figure>
<h4 id="使用try和catch处理异常"><a href="#使用try和catch处理异常" class="headerlink" title="使用try和catch处理异常"></a>使用try和catch处理异常</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; function validateEmail(email) &#123;</span><br><span class="line">... return email.match(/@/) ? email : new Error(`invalid email: $&#123;email&#125;`);</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const email = null;</span><br><span class="line">undefined</span><br><span class="line">&gt; try &#123;</span><br><span class="line">... const validatedEmail = validateEmail(email);</span><br><span class="line">... if (validatedEmail instanceof Error) &#123;</span><br><span class="line">..... console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">..... &#125; else &#123;</span><br><span class="line">..... console.log(`valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;catch(err) &#123;</span><br><span class="line">... console.error(`Error: $&#123;err.message&#125;`);</span><br><span class="line">... &#125;</span><br><span class="line">Error: Cannot read property &#x27;match&#x27; of null</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>在JavaScript中，可以抛出任何值：数字、字符串、或其他任何类型。不过抛出Error实例可以更方便地处理异常。<br>通过throw抛出异常，调用throw的时候，当前函数会立即停止执行。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; function billPay(amount, payee, account) &#123;</span><br><span class="line">... if (amount &gt; account.balance)</span><br><span class="line">... 	throw new Error(&#x27;insufficient funds&#x27;);</span><br><span class="line">... account.transfer(payee, amount);</span><br><span class="line">... &#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常处理和调用栈"><a href="#异常处理和调用栈" class="headerlink" title="异常处理和调用栈"></a>异常处理和调用栈</h4><p>函数a调用函数b，函数b调用函数c，当函数c正在执行的时候，a和b都未完成，这种未完成的嵌套函数调用就叫做调用栈。<br>函数中发生错误时，错误会沿着调用栈传递，直到被捕获。错误可以在调用栈的任一级别被捕获。如果它们没有被捕获，JavaScript解释器就会强行终止程序。          </p>
<h4 id="try-…-catch-…-finally"><a href="#try-…-catch-…-finally" class="headerlink" title="try … catch … finally"></a>try … catch … finally</h4><p>catch中的代码只有在发生错误的时候才会执行。不管是否发生错误，finally中的代码都会被执行。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; try &#123;</span><br><span class="line">... console.log(&#x27;this line is excuted...&#x27;);</span><br><span class="line">... throw new Error(&#x27;whoops&#x27;);</span><br><span class="line">... console.log(&#x27;this line is not...&#x27;);</span><br><span class="line">... &#125;catch(err) &#123;</span><br><span class="line">... console.log(&#x27;there was an error...&#x27;);</span><br><span class="line">... &#125;finally &#123;</span><br><span class="line">... console.log(&#x27;...always executed&#x27;);</span><br><span class="line">... &#125;</span><br><span class="line">this line is excuted...</span><br><span class="line">there was an error...</span><br><span class="line">...always executed</span><br><span class="line">undefined</span><br><span class="line">&gt; try &#123;</span><br><span class="line">... console.log(&#x27;this line is excuted...&#x27;);</span><br><span class="line">... &#125;finally &#123;</span><br><span class="line">... console.log(&#x27;...always executed&#x27;);</span><br><span class="line">... &#125;</span><br><span class="line">this line is excuted...</span><br><span class="line">...always executed</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><p>数组可以通过values()方法获取迭代器。迭代器有next()方法，next返回的对象中有两个属性：value和done。当运行结束时，返回的对象中value的值为undefined。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; const books = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];</span><br><span class="line">undefined</span><br><span class="line">&gt; books</span><br><span class="line">(3) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&gt; const bv = books.values();</span><br><span class="line">undefined</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: &quot;a&quot;, done: false&#125;</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: &quot;b&quot;, done: false&#125;</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: &quot;c&quot;, done: false&#125;</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h4><p>如果一个类提供了一个符号方法Symbol.iterator，这个方法返回一个具有迭代行为的对象（比如：对象有next方法，同时next方法返回一个包含value和done的对象），那么这个类就是可迭代的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Log &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        this.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line">    add(message) &#123;</span><br><span class="line">        this.messages.push(message);</span><br><span class="line">    &#125;</span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        return this.messages.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const log = new Log();</span><br><span class="line">undefined</span><br><span class="line">&gt; log.add(&#x27;first day at sea&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; log.add(&#x27;spotted whale&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; log.add(&#x27;spotted another vessel&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; for (let entry of log) &#123;</span><br><span class="line">    console.log(`$&#123;entry&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">VM554:2 first day at sea</span><br><span class="line">VM554:2 spotted whale</span><br><span class="line">VM554:2 spotted another vessel</span><br></pre></td></tr></table></figure>
<p>也可以编写自己的迭代器。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Log &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        this.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line">    add(message) &#123;</span><br><span class="line">        this.messages.push(message);</span><br><span class="line">    &#125;</span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        let i = 0;</span><br><span class="line">        const messages = this.messages;</span><br><span class="line">        return &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                if (i &gt;= messages.length) &#123;</span><br><span class="line">                    return &#123;value: undefined, done: true&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                return &#123;value: messages[i++], done: false&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是使用迭代器来控制其运行的函数。生成器提供了两种能力：首先：是控制函数执行的能力，使函数能够分布执行；其次，是与执行中的函数对话的能力。<br>生成器与一般的函数有两个不同的地方： </p>
<ul>
<li>函数可以通过使用域（yield），在其运行的任意时刻将控制权交还给调用方。</li>
<li>调用生成器的时候，它并不立即执行。而是会回到迭代器中。函数会在调用迭代器的next方法时执行。</li>
</ul>
<p>在JavaScript中，生成器需要在function关键字后添加一个通配符（*）来指明；其他语法跟普通函数一样。如果一个函数是生成器，就可以在return中添加yield关键字。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; function* rainbow() &#123;</span><br><span class="line">    yield &#x27;red&#x27;;</span><br><span class="line">    yield &#x27;orange&#x27;;</span><br><span class="line">    yield &#x27;yellow&#x27;;</span><br><span class="line">    yield &#x27;green&#x27;;</span><br><span class="line">    yield &#x27;blue&#x27;;</span><br><span class="line">    yield &#x27;indigo&#x27;;</span><br><span class="line">    yield &#x27;violet&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const it = rainbow();</span><br><span class="line">undefined</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;red&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;orange&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;yellow&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;green&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;blue&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;indigo&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;violet&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用for … of循环迭代器。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let color of rainbow()) &#123;</span><br><span class="line">    console.log(color);</span><br><span class="line">&#125;</span><br><span class="line">VM1240:2 red</span><br><span class="line">VM1240:2 orange</span><br><span class="line">VM1240:2 yellow</span><br><span class="line">VM1240:2 green</span><br><span class="line">VM1240:2 blue</span><br><span class="line">VM1240:2 indigo</span><br><span class="line">VM1240:2 violet</span><br></pre></td></tr></table></figure>

<h5 id="yield-表达式和双向交流"><a href="#yield-表达式和双向交流" class="headerlink" title="yield 表达式和双向交流"></a>yield 表达式和双向交流</h5><p>yield是一个表达式，ta可以计算出一个值，它计算的是调用方每次在生成器的迭代器上调用next时提供的参数。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; function* interrogate() &#123;</span><br><span class="line">    const name = yield &quot;What is your name?&quot;;</span><br><span class="line">    const color = yield &quot;What is your favorite color?&quot;;</span><br><span class="line">    return `$&#123;name&#125;&#x27;s favorite color is $&#123;color&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const inte = interrogate();</span><br><span class="line">undefined</span><br><span class="line">&gt; inte.next();</span><br><span class="line">&#123;value: &quot;What is your name?&quot;, done: false&#125;</span><br><span class="line">&gt; inte.next(&#x27;Ethan&#x27;);</span><br><span class="line">&#123;value: &quot;What is your favorite color?&quot;, done: false&#125;</span><br><span class="line">&gt; inte.next(&#x27;orange&#x27;);</span><br><span class="line">&#123;value: &quot;Ethan&#x27;s favorite color is orange&quot;, done: true&#125;</span><br><span class="line">&gt; inte.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>不能通过箭头函数来创建生成器，必须使用function*关键字</p>
<h5 id="生成器和返回值"><a href="#生成器和返回值" class="headerlink" title="生成器和返回值"></a>生成器和返回值</h5><p>yield表达式本身不能让生成器结束，即使它是生成器的最后一个语句。在生成器的任何位置调用return都会使done的值变成true，而value的值则是任何被返回的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function* abc() &#123;</span><br><span class="line">    yield &#x27;a&#x27;;</span><br><span class="line">    yield &#x27;b&#x27;;</span><br><span class="line">    return &#x27;c&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">const ab = abc();</span><br><span class="line">undefined</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: &quot;a&quot;, done: false&#125;</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: &quot;b&quot;, done: false&#125;</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: &quot;c&quot;, done: true&#125;</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个行为是正确的，但要记住，使用生成器的东西并不总会在意done为true时value的值。比如，如果在for … of循环中用它，那么‘c’是不会被打印出来的。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let ab of abc()) &#123;</span><br><span class="line">    console.log(ab);</span><br><span class="line">&#125;</span><br><span class="line">VM1809:2 a</span><br><span class="line">VM1809:2 b</span><br></pre></td></tr></table></figure>
<p>建议不要在return中提供一个对生成器有意义的值。如果想在生成器之外使用某个值，应该调用yield；return应该只被用做提前停止生成器。出于这个原因，通常建议：在生成器中调用return的时候，不提供返回值。</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>在调用一个基于promise的异步函数时，它会返回一个promise实例。其中只可能发生两件事：被满足（success）或被拒绝（failure）。promise可以保证只有一件事会发生，而结果只会发生一次（如果满足，那么只会被满足一次，如果拒绝，也只会被拒绝一次）。一旦promise被满足或者被拒绝了，就会认为它被处理了。<br>创建一个带有函数的promise实例，它应该包括一个resolve和一个reject回调函数。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt; function countdown(seconds) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        for (let i = seconds; i &gt;=0; i--) &#123;</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">                if (i &gt; 0) console.log(i + &#x27;...&#x27;);</span><br><span class="line">                else resolve(console.log(&#x27;Go!&#x27;));</span><br><span class="line">            &#125;, (seconds - i) * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; countdown(5).then(function() &#123;</span><br><span class="line">    console.log(&#x27;countdown completed successfully&#x27;);</span><br><span class="line">&#125;,function(err) &#123;</span><br><span class="line">    console.log(&#x27;countdown experienced an error:&#x27; + err.message);</span><br><span class="line">&#125;);</span><br><span class="line">Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">VM218:5 5...</span><br><span class="line">VM218:5 4...</span><br><span class="line">VM218:5 3...</span><br><span class="line">VM218:5 2...</span><br><span class="line">VM218:5 1...</span><br><span class="line">VM218:6 Go!</span><br><span class="line">VM434:2 countdown completed successfully</span><br><span class="line">&gt; const p = countdown(5);</span><br><span class="line">undefined</span><br><span class="line">VM218:5 5...</span><br><span class="line">VM218:5 4...</span><br><span class="line">VM218:5 3...</span><br><span class="line">VM218:5 2...</span><br><span class="line">VM218:5 1...</span><br><span class="line">VM218:6 Go!</span><br><span class="line">&gt; p.then(function() &#123;</span><br><span class="line">    console.log(&#x27;countdown completed successfully&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">VM562:2 countdown completed successfully</span><br><span class="line">Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br><span class="line">p.catch(function(err) &#123;</span><br><span class="line">    console.log(&#x27;countdown experienced an error: &#x27; + err.message);</span><br><span class="line">&#125;);</span><br><span class="line">Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件发射器可以广播事件，任何愿意监听（或者“订阅”）这些事件的人都可以去做这件事。创建自己的事件系统，Node提供了内建支持。如果使用浏览器，jQuery同样提供了一个事件机制（<a target="_blank" rel="noopener" href="http://api.jquery.com/category/events/%EF%BC%89">http://api.jquery.com/category/events/）</a>     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&gt; const EventEmitter = require(&#x27;events&#x27;).EventEmitter;</span><br><span class="line">undefined</span><br><span class="line">&gt; class Countdown extends EventEmitter &#123;</span><br><span class="line">... constructor(seconds, superstitious) &#123;</span><br><span class="line">..... super();</span><br><span class="line">..... this.seconds = seconds;</span><br><span class="line">..... this.superstitious = !!superstitious;</span><br><span class="line">..... &#125;</span><br><span class="line">... go() &#123;</span><br><span class="line">..... const countdown = this;</span><br><span class="line">..... return new Promise(function(resolve, reject) &#123;</span><br><span class="line">....... for (let i = countdown.seconds; i &gt;= 0; i--) &#123;</span><br><span class="line">......... setTimeout(function() &#123;</span><br><span class="line">........... if (countdown.superstitious &amp;&amp; i === 13)</span><br><span class="line">........... return reject(new Error(&#x27;definitely not counting that&#x27;));</span><br><span class="line">........... countdown.emit(&#x27;tick&#x27;,i);</span><br><span class="line">........... if(i === 0) resolve();</span><br><span class="line">........... &#125;, (countdown.seconds-i)*1000);</span><br><span class="line">......... &#125;</span><br><span class="line">....... &#125;);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const c = new Countdown(5);</span><br><span class="line">undefined</span><br><span class="line">&gt; c.on(&#x27;tick&#x27;, function(i) &#123;</span><br><span class="line">... if (i&gt;0) console.log(i + &#x27;...&#x27;);</span><br><span class="line">... &#125;);</span><br><span class="line">Countdown &#123;</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125;,</span><br><span class="line">  _events: &#123; tick: [Function] &#125;,</span><br><span class="line">  _eventsCount: 1,</span><br><span class="line">  _maxListeners: undefined,</span><br><span class="line">  seconds: 5,</span><br><span class="line">  superstitious: false &#125;</span><br><span class="line">&gt; c.go().then(function() &#123;</span><br><span class="line">... console.log(&#x27;go!&#x27;);</span><br><span class="line">... &#125;).catch(function(err) &#123;</span><br><span class="line">... console.log(err.message);</span><br><span class="line">... &#125;)</span><br><span class="line">Promise &#123;</span><br><span class="line">  &lt;pending&gt;,</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125; &#125;</span><br><span class="line">&gt; 5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">go!</span><br><span class="line">&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="promise链"><a href="#promise链" class="headerlink" title="promise链"></a>promise链</h5><p>promise的一个优点就是它可以被链式调用；也就是说，当一个promise被满足时，可以立即用它调用另一个返回promise的函数，以此类推。promise链的一个好处是不用在每一步都捕获错误；如果错误可能发生在链中的任何一环，promise链都会停止，继而调到catch中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; function launch() &#123;</span><br><span class="line">... return new Promise(function(resolve, reject) &#123;</span><br><span class="line">..... console.log(&#x27;lift off&#x27;);</span><br><span class="line">..... setTimeout(function() &#123;</span><br><span class="line">....... resolve(&#x27;in orbit&#x27;);</span><br><span class="line">....... &#125;, 2*1000);</span><br><span class="line">..... &#125;);</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const c1 = new Countdown(5);</span><br><span class="line">&gt; c1.go().then(launch).then(function(msg)&#123;console.log(msg);&#125;).catch(function(err) &#123;console.error(&#x27;houston, we have a problem ....&#x27;);&#125;)</span><br><span class="line">Promise &#123;</span><br><span class="line">  &lt;pending&gt;,</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125; &#125;</span><br><span class="line">&gt; 5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">0...</span><br><span class="line">lift off</span><br><span class="line">in orbit</span><br></pre></td></tr></table></figure>
<h5 id="避免不被处理的promise"><a href="#避免不被处理的promise" class="headerlink" title="避免不被处理的promise"></a>避免不被处理的promise</h5><p>promise可以简化异步代码，同时确保回调函数不会被多次调用，但却不能避免那些因为promise没有被处理而产生的问题（没被处理指在这个promise中，既没有调用resolve，也没有调用reject）。有种方式可以避免这种错误，就是给promise一个特定的超时。如果promise没有在一段合理的时间内被处理，就会自动被拒绝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; function addTimeout(fn, timeout) &#123;</span><br><span class="line">... if (timeout === undefined) timeout = 1000;  //默认时间</span><br><span class="line">... return function(...args) &#123;</span><br><span class="line">..... return new Promise(function(resolve, reject) &#123;</span><br><span class="line">....... const tid = setTimeout(reject, timeout, new Error(&#x27;promise timed out&#x27;)); </span><br><span class="line">....... fn(...args).then(function(...args) &#123;</span><br><span class="line">......... clearTimeout(tid);</span><br><span class="line">......... resolve(...args);</span><br><span class="line">......... &#125;).catch(function(...args) &#123;</span><br><span class="line">......... clearTimeout(tid);</span><br><span class="line">......... reject(...args);</span><br><span class="line">......... &#125;);</span><br><span class="line">....... &#125;);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; c1.go().then(addTimeout(launch, 4*1000)).then(function(msg) &#123;console.log(msg);&#125;).catch(function(err) &#123; console.error(&#x27;houston, we have a problem: &#x27; + err.message); &#125;);</span><br><span class="line">Promise &#123;</span><br><span class="line">  &lt;pending&gt;,</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125; &#125;</span><br><span class="line">&gt; 5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">0...</span><br><span class="line">lift off</span><br><span class="line">in orbit</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fhclk"
      src="/images/avatar1.png">
  <p class="site-author-name" itemprop="name">fhclk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">153</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fhclk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fhclk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fhclk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
</body>
</html>
