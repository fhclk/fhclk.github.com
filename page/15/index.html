<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fhclk.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="拾荒者">
<meta property="og:url" content="http://fhclk.github.io/page/15/index.html">
<meta property="og:site_name" content="拾荒者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fhclk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fhclk.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>拾荒者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拾荒者</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">昨夜西风凋碧树，独上高楼，望尽天涯路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/05/25/read-fupan1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/25/read-fupan1/" class="post-title-link" itemprop="url">读《复盘+把经验转化为能力》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-25 20:32:54" itemprop="dateCreated datePublished" datetime="2018-05-25T20:32:54+08:00">2018-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;前几天把《复盘+把经验转化为能力》读了一遍。书中详细的介绍了复盘的概念，为什么要用复盘，复盘的实施步骤，及详细描述美军AAR和联想的复盘过程等。通篇本书，略觉书中内容略有繁琐，并且略有夸大复盘在企业发展和企业管理中的作用，每个公司和每个个人均有其特性，不能都按照书中详尽的复盘流程来复盘，达到自己对失败项目的深入总结和学习过程。<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;柳传志首创复盘理论，并将其运用于联想内部管理中，取得不错的效果。美军也将AAR永远美军军事训练中，并对大量训练进行AAR，从而达到教学目标。等等实例，说明复盘是一种有效的学习方法。<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在复盘过程中，应该以严肃、认真的态度还原这个事件或项目的发展过程，应该尽量摒弃个人情感，其中包括想妥协责任、贬低他人、抬高自己、随意等情感，尽量客观的还原整个事件过程，找出其中引发问题的节点，进行反思总结，避免再次因同样的问题而造成项目或事情的失败，从而达到学习的目的。<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;个人将复盘理念运用到个人的成长学习过程中，可以养成一种严禁的做事风格，并一种比较好的学习方法，从以往经历中、其他人的经历或其他事件的失败过程，汲取经验，从而到达自我的提高，避免自己犯同样的错误而导致事情的失败，避免掉入相同的坑中。<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;团队和部门将复盘理念运用到项目管理中，可以避免项目因相同的原因出现相同的问题，浪费时间或者造成项目的失败。通过对复盘的实施，提升团队成员做事的严禁性，并从过去失败的实例中汲取经验教训，从而提升团队质量，提高团队做事的效率，项目的执行过程中的效率和质量有所提升。<br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;复盘是一个从过去经历中总结经验，学习提高的过程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/03/25/read-xtjgsjsjc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/25/read-xtjgsjsjc/" class="post-title-link" itemprop="url">读《系统架构设计师教程》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-25 13:49:05" itemprop="dateCreated datePublished" datetime="2018-03-25T13:49:05+08:00">2018-03-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h2><h3 id="计算机系统组成"><a href="#计算机系统组成" class="headerlink" title="计算机系统组成"></a>计算机系统组成</h3><h4 id="计算机硬件的组成"><a href="#计算机硬件的组成" class="headerlink" title="计算机硬件的组成"></a>计算机硬件的组成</h4><p><img src="/2018/03/25/read-xtjgsjsjc/computerStruct.png"></p>
<ul>
<li>控制器是分析和执行指令的部件，也是统一指挥并控制计算机各部件协 调工作的中心部件，所依据的是机器指令。</li>
<li>运算器也称为算术逻辑单元(ArithmeticandLogicUnit，ALU)，其主要功能是在控制器的控制下完成各种算术运算和逻辑运算。</li>
<li>主存储器也称为内存储器(通常简称为“内存”或“主存”)。存储现场操作的信息与中间结果，包括机器指令和数据。</li>
<li>辅助存储器也称为外存储器，通常简称为外存或辅存。存储需要长 期保存的各种信息。</li>
<li>输入设备的任务是把人们编好的程序和原始数据送到计算机中去，并且 将它们转换成计算机内部所能识别和接受的信息方式。按输入信息的形态可分为字符 (包括汉字)输入、图形输入、图像输入及语音输入等。目前，常见的输入设备有键盘、 鼠 标、扫描仪等。</li>
<li>输出设备的任务是将计算机的处理结果以人或其他设备所能接受的 形 式送出计算机。目前，最常用的输出设备是打印机和显示器。</li>
</ul>
<h4 id="计算机系统结构的分类"><a href="#计算机系统结构的分类" class="headerlink" title="计算机系统结构的分类"></a>计算机系统结构的分类</h4><h4 id="复杂指令集系统与精简指令集系统"><a href="#复杂指令集系统与精简指令集系统" class="headerlink" title="复杂指令集系统与精简指令集系统"></a>复杂指令集系统与精简指令集系统</h4><h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>总线是一组能为多个部件分时共享的公共信息传送线路。共享是指总线上可以挂接多个 部件，各个部件之间相互交换的信息都可以通过这组公共线路传送;分时是指同一时刻只允 许有一个部件向总线发送信息，如果出现两个或两个以上部件同时向总线发送信息，势必导 致信号冲突。当然，在同一时刻，允许多个部件同时从总线上接收相同的信息。<br>按总线相对于 CPU 或其他芯片的位置可分为内部总线和外部总线两种。<br>按总线功能来划分，又可分为地址总线、数据总线、控制总线三类。</p>
<h3 id="存储器系统"><a href="#存储器系统" class="headerlink" title="存储器系统"></a>存储器系统</h3><p>传统的存储器系统一般分为高速缓冲存储器(Cache)、主存、辅存三级。<br>存储器中数据常用的存取方式有顺序存取、直接存取、随机存取和相联存取四种。</p>
<h4 id="主存储器系统"><a href="#主存储器系统" class="headerlink" title="主存储器系统"></a>主存储器系统</h4><p>主存用来存放计算机运行期间所需要的程序和数据，CPU 可直接随机地进行读&#x2F;写。<br>根据工艺和技术不同，主存可分为随机存取存储器和只 读存储器。</p>
<h4 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h4><ol>
<li>磁带存储器磁带存储器是一种顺序存取的设备，其特点包括:存取时间较长，但存储 容量大，便于携带，价格便宜。磁带应用的场景越来越少，目前主要用于资料的归档保存。</li>
<li>硬盘存储器在硬盘中，信息分布呈以下层次:记录面、圆柱面、磁道和扇区.</li>
</ol>
<h4 id="Cache存储器"><a href="#Cache存储器" class="headerlink" title="Cache存储器"></a>Cache存储器</h4><p>通常在 CPU 和内存之间设置小容量的 Cache。Cache 容量小但速度快，内存速度较低但容量大， 通过优化调度算法，系统的性能会大大改善，仿佛其存储系统容量与内存相当而访问速度近 似 Cache。    </p>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>流水线技术把一个任务分解为若干顺序执行的子任务，不同的子任务由不同的执行机构 负责执行，而这些机构可以同时并行工作。在任一时刻，任一任务只占用其中一个执行机构， 这样就可以实现多个任务的重叠执行，以提高工作效率。</p>
<h4 id="流水线周期"><a href="#流水线周期" class="headerlink" title="流水线周期"></a>流水线周期</h4><p>流水线应用过程中，会将需要处理的工作分为 N 个阶段，最耗时的那一段所消耗的时 间为流水线周期。</p>
<h4 id="计算流水线执行时间"><a href="#计算流水线执行时间" class="headerlink" title="计算流水线执行时间"></a>计算流水线执行时间</h4><p>流水线执行时间&#x3D;第 1 条指令的执行时间+(n-1)*流水线周期.<br>注:n 代表需要处理的任务数量。  </p>
<h4 id="流水线的吞吐率"><a href="#流水线的吞吐率" class="headerlink" title="流水线的吞吐率"></a>流水线的吞吐率</h4><p>流水线的吞吐率(Though Put rate，TP)是指在单位时间内流水线所完成的任务数量或输出的结果数量。有些文献也称为平均吞吐率、实际吞率。计算流水线吞吐率的最基本的公式如下:<br><img src="/2018/03/25/read-xtjgsjsjc/thoughPutRate.png"></p>
<h4 id="流水线的加速比"><a href="#流水线的加速比" class="headerlink" title="流水线的加速比"></a>流水线的加速比</h4><p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线 的加速比(speedup ratio)。     </p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统的基本类型有:批处理操作系统、分时操作系 统和实时操作系统。从资源管理的角度看，操作系统主要是对处理器、存储器、文件、设备 和作业进行管理。</p>
<h3 id="操作系统的类型与结构"><a href="#操作系统的类型与结构" class="headerlink" title="操作系统的类型与结构"></a>操作系统的类型与结构</h3><h4 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h4><p>按照操作系统的功能划分，操作系统的基本类型有批处理操作系统、分时操作系统、实时操作系统、网络操作系统、分布式操作系统、嵌入式操作统、微内核操作系统等。</p>
<h3 id="操作系统的基本原理"><a href="#操作系统的基本原理" class="headerlink" title="操作系统的基本原理"></a>操作系统的基本原理</h3><p>操作系统的主要功能是进行处理机与进程管理、存储管理、设备管理、文件管理和作业管理的工作</p>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p><img src="/2018/03/25/read-xtjgsjsjc/progressStates.png"></p>
<h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><h4 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h4><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><h4 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h4><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><h3 id="数据库管理系统的类型"><a href="#数据库管理系统的类型" class="headerlink" title="数据库管理系统的类型"></a>数据库管理系统的类型</h3><h3 id="书籍模式与范式"><a href="#书籍模式与范式" class="headerlink" title="书籍模式与范式"></a>书籍模式与范式</h3><h4 id="数据库的结构与模式"><a href="#数据库的结构与模式" class="headerlink" title="数据库的结构与模式"></a>数据库的结构与模式</h4><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><h4 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h4><h4 id="数据的规范化"><a href="#数据的规范化" class="headerlink" title="数据的规范化"></a>数据的规范化</h4><h4 id="反规范化"><a href="#反规范化" class="headerlink" title="反规范化"></a>反规范化</h4><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="数据库设计的方法"><a href="#数据库设计的方法" class="headerlink" title="数据库设计的方法"></a>数据库设计的方法</h4><h4 id="数据库设计的基础步骤"><a href="#数据库设计的基础步骤" class="headerlink" title="数据库设计的基础步骤"></a>数据库设计的基础步骤</h4><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><h4 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h4><h4 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h4><h4 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h4><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><h4 id="故障与恢复"><a href="#故障与恢复" class="headerlink" title="故障与恢复"></a>故障与恢复</h4><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><h3 id="分布式数据库系统"><a href="#分布式数据库系统" class="headerlink" title="分布式数据库系统"></a>分布式数据库系统</h3><h4 id="分布式数据库的概念"><a href="#分布式数据库的概念" class="headerlink" title="分布式数据库的概念"></a>分布式数据库的概念</h4><h4 id="分布式数据库的架构"><a href="#分布式数据库的架构" class="headerlink" title="分布式数据库的架构"></a>分布式数据库的架构</h4><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><h4 id="数据仓库的概念"><a href="#数据仓库的概念" class="headerlink" title="数据仓库的概念"></a>数据仓库的概念</h4><h4 id="数据挖掘的功能"><a href="#数据挖掘的功能" class="headerlink" title="数据挖掘的功能"></a>数据挖掘的功能</h4><h4 id="数据挖掘常用技术"><a href="#数据挖掘常用技术" class="headerlink" title="数据挖掘常用技术"></a>数据挖掘常用技术</h4><h4 id="数据挖掘的流程"><a href="#数据挖掘的流程" class="headerlink" title="数据挖掘的流程"></a>数据挖掘的流程</h4><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="网络架构与协议"><a href="#网络架构与协议" class="headerlink" title="网络架构与协议"></a>网络架构与协议</h3><h4 id="网络互连模型"><a href="#网络互连模型" class="headerlink" title="网络互连模型"></a>网络互连模型</h4><h4 id="常见的网络协议"><a href="#常见的网络协议" class="headerlink" title="常见的网络协议"></a>常见的网络协议</h4><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><h3 id="局域网与广域网"><a href="#局域网与广域网" class="headerlink" title="局域网与广域网"></a>局域网与广域网</h3><h4 id="局域网基础知识"><a href="#局域网基础知识" class="headerlink" title="局域网基础知识"></a>局域网基础知识</h4><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><h4 id="广域网技术"><a href="#广域网技术" class="headerlink" title="广域网技术"></a>广域网技术</h4><h4 id="网络接入技术"><a href="#网络接入技术" class="headerlink" title="网络接入技术"></a>网络接入技术</h4><h3 id="网络互连与常用设备"><a href="#网络互连与常用设备" class="headerlink" title="网络互连与常用设备"></a>网络互连与常用设备</h3><h3 id="网络工程"><a href="#网络工程" class="headerlink" title="网络工程"></a>网络工程</h3><h4 id="网络规划"><a href="#网络规划" class="headerlink" title="网络规划"></a>网络规划</h4><h4 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h4><h4 id="网络实施"><a href="#网络实施" class="headerlink" title="网络实施"></a>网络实施</h4><h3 id="网络存储技术"><a href="#网络存储技术" class="headerlink" title="网络存储技术"></a>网络存储技术</h3><h3 id="综合布线"><a href="#综合布线" class="headerlink" title="综合布线"></a>综合布线</h3><h2 id="系统性能评价"><a href="#系统性能评价" class="headerlink" title="系统性能评价"></a>系统性能评价</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><h4 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h4><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><h4 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h4><h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><h4 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h4><h3 id="性能计算"><a href="#性能计算" class="headerlink" title="性能计算"></a>性能计算</h3><h3 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h3><h4 id="阿姆达尔解决方案"><a href="#阿姆达尔解决方案" class="headerlink" title="阿姆达尔解决方案"></a>阿姆达尔解决方案</h4><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h3 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h3><h4 id="基准测试程序"><a href="#基准测试程序" class="headerlink" title="基准测试程序"></a>基准测试程序</h4><h4 id="Web服务器的性能评估"><a href="#Web服务器的性能评估" class="headerlink" title="Web服务器的性能评估"></a>Web服务器的性能评估</h4><h4 id="系统监视"><a href="#系统监视" class="headerlink" title="系统监视"></a>系统监视</h4><h2 id="开发方法"><a href="#开发方法" class="headerlink" title="开发方法"></a>开发方法</h2><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><h3 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h3><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><h4 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h4><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><h4 id="构件组装模型"><a href="#构件组装模型" class="headerlink" title="构件组装模型"></a>构件组装模型</h4><h3 id="统一过程"><a href="#统一过程" class="headerlink" title="统一过程"></a>统一过程</h3><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><h4 id="特征驱动开发"><a href="#特征驱动开发" class="headerlink" title="特征驱动开发"></a>特征驱动开发</h4><h4 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h4><h4 id="水晶方法"><a href="#水晶方法" class="headerlink" title="水晶方法"></a>水晶方法</h4><h4 id="其他敏捷方法"><a href="#其他敏捷方法" class="headerlink" title="其他敏捷方法"></a>其他敏捷方法</h4><h3 id="软件重用"><a href="#软件重用" class="headerlink" title="软件重用"></a>软件重用</h3><h4 id="软件重用-1"><a href="#软件重用-1" class="headerlink" title="软件重用"></a>软件重用</h4><h4 id="构件技术"><a href="#构件技术" class="headerlink" title="构件技术"></a>构件技术</h4><h3 id="基于架构的软件设计"><a href="#基于架构的软件设计" class="headerlink" title="基于架构的软件设计"></a>基于架构的软件设计</h3><h4 id="ABSD方法与生命周期"><a href="#ABSD方法与生命周期" class="headerlink" title="ABSD方法与生命周期"></a>ABSD方法与生命周期</h4><h4 id="基于架构的软件开发模型"><a href="#基于架构的软件开发模型" class="headerlink" title="基于架构的软件开发模型"></a>基于架构的软件开发模型</h4><h3 id="形式化方法"><a href="#形式化方法" class="headerlink" title="形式化方法"></a>形式化方法</h3><h2 id="系统规划"><a href="#系统规划" class="headerlink" title="系统规划"></a>系统规划</h2><h3 id="项目的提出与选择"><a href="#项目的提出与选择" class="headerlink" title="项目的提出与选择"></a>项目的提出与选择</h3><h4 id="项目的立项目标和动机"><a href="#项目的立项目标和动机" class="headerlink" title="项目的立项目标和动机"></a>项目的立项目标和动机</h4><h4 id="项目的选择和确定"><a href="#项目的选择和确定" class="headerlink" title="项目的选择和确定"></a>项目的选择和确定</h4><h4 id="项目提出和选择的结果"><a href="#项目提出和选择的结果" class="headerlink" title="项目提出和选择的结果"></a>项目提出和选择的结果</h4><h3 id="可行性研究与效益分析"><a href="#可行性研究与效益分析" class="headerlink" title="可行性研究与效益分析"></a>可行性研究与效益分析</h3><h4 id="可行性研究的内容"><a href="#可行性研究的内容" class="headerlink" title="可行性研究的内容"></a>可行性研究的内容</h4><h4 id="成本效益分析"><a href="#成本效益分析" class="headerlink" title="成本效益分析"></a>成本效益分析</h4><h4 id="可行性分析报告"><a href="#可行性分析报告" class="headerlink" title="可行性分析报告"></a>可行性分析报告</h4><h3 id="方案的制订和改进"><a href="#方案的制订和改进" class="headerlink" title="方案的制订和改进"></a>方案的制订和改进</h3><h3 id="新旧系统的分析和比较"><a href="#新旧系统的分析和比较" class="headerlink" title="新旧系统的分析和比较"></a>新旧系统的分析和比较</h3><h4 id="遗留系统的评估方法"><a href="#遗留系统的评估方法" class="headerlink" title="遗留系统的评估方法"></a>遗留系统的评估方法</h4><h4 id="遗留系统的演化策略"><a href="#遗留系统的演化策略" class="headerlink" title="遗留系统的演化策略"></a>遗留系统的演化策略</h4><h2 id="系统分析与设计方法"><a href="#系统分析与设计方法" class="headerlink" title="系统分析与设计方法"></a>系统分析与设计方法</h2><h3 id="定义问题与归结模型"><a href="#定义问题与归结模型" class="headerlink" title="定义问题与归结模型"></a>定义问题与归结模型</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><h4 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h4><h3 id="需求分析与软件设计"><a href="#需求分析与软件设计" class="headerlink" title="需求分析与软件设计"></a>需求分析与软件设计</h3><h4 id="需求分析的任务与过程"><a href="#需求分析的任务与过程" class="headerlink" title="需求分析的任务与过程"></a>需求分析的任务与过程</h4><h4 id="如何进行系统设计"><a href="#如何进行系统设计" class="headerlink" title="如何进行系统设计"></a>如何进行系统设计</h4><h4 id="软件设计的任务与活动"><a href="#软件设计的任务与活动" class="headerlink" title="软件设计的任务与活动"></a>软件设计的任务与活动</h4><h3 id="结构化分析与设计"><a href="#结构化分析与设计" class="headerlink" title="结构化分析与设计"></a>结构化分析与设计</h3><h4 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h4><h4 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h4><h4 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h4><h3 id="面向对象的分析与设计"><a href="#面向对象的分析与设计" class="headerlink" title="面向对象的分析与设计"></a>面向对象的分析与设计</h3><h4 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h4><h4 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h4><h4 id="统一建模语言"><a href="#统一建模语言" class="headerlink" title="统一建模语言"></a>统一建模语言</h4><h3 id="用户界面设计"><a href="#用户界面设计" class="headerlink" title="用户界面设计"></a>用户界面设计</h3><h4 id="用户界面设计的原则"><a href="#用户界面设计的原则" class="headerlink" title="用户界面设计的原则"></a>用户界面设计的原则</h4><h4 id="用户界面设计过程"><a href="#用户界面设计过程" class="headerlink" title="用户界面设计过程"></a>用户界面设计过程</h4><h3 id="工作流设计"><a href="#工作流设计" class="headerlink" title="工作流设计"></a>工作流设计</h3><h4 id="工作流设计概述"><a href="#工作流设计概述" class="headerlink" title="工作流设计概述"></a>工作流设计概述</h4><h4 id="工作流管理系统"><a href="#工作流管理系统" class="headerlink" title="工作流管理系统"></a>工作流管理系统</h4><h3 id="简单分布式计算机应用系统的设计"><a href="#简单分布式计算机应用系统的设计" class="headerlink" title="简单分布式计算机应用系统的设计"></a>简单分布式计算机应用系统的设计</h3><h3 id="系统运行环境的集成与设计"><a href="#系统运行环境的集成与设计" class="headerlink" title="系统运行环境的集成与设计"></a>系统运行环境的集成与设计</h3><h3 id="系统过渡计划"><a href="#系统过渡计划" class="headerlink" title="系统过渡计划"></a>系统过渡计划</h3><h2 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h2><h3 id="软件架构概述"><a href="#软件架构概述" class="headerlink" title="软件架构概述"></a>软件架构概述</h3><h4 id="软件架构的定义"><a href="#软件架构的定义" class="headerlink" title="软件架构的定义"></a>软件架构的定义</h4><h4 id="软件架构的重要性"><a href="#软件架构的重要性" class="headerlink" title="软件架构的重要性"></a>软件架构的重要性</h4><h4 id="架构的模型"><a href="#架构的模型" class="headerlink" title="架构的模型"></a>架构的模型</h4><h3 id="架构需求与软件质量属性"><a href="#架构需求与软件质量属性" class="headerlink" title="架构需求与软件质量属性"></a>架构需求与软件质量属性</h3><h4 id="软件质量属性"><a href="#软件质量属性" class="headerlink" title="软件质量属性"></a>软件质量属性</h4><h4 id="6个质量属性及实现"><a href="#6个质量属性及实现" class="headerlink" title="6个质量属性及实现"></a>6个质量属性及实现</h4><h3 id="软件架构风格"><a href="#软件架构风格" class="headerlink" title="软件架构风格"></a>软件架构风格</h3><h4 id="软件架构风格分类"><a href="#软件架构风格分类" class="headerlink" title="软件架构风格分类"></a>软件架构风格分类</h4><h4 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h4><h4 id="调用-x2F-返回风格"><a href="#调用-x2F-返回风格" class="headerlink" title="调用&#x2F;返回风格"></a>调用&#x2F;返回风格</h4><h4 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h4><h4 id="仓库风格"><a href="#仓库风格" class="headerlink" title="仓库风格"></a>仓库风格</h4><h3 id="层次系统架构风格"><a href="#层次系统架构风格" class="headerlink" title="层次系统架构风格"></a>层次系统架构风格</h3><h4 id="二层及三层C-x2F-S架构风格"><a href="#二层及三层C-x2F-S架构风格" class="headerlink" title="二层及三层C&#x2F;S架构风格"></a>二层及三层C&#x2F;S架构风格</h4><h4 id="B-x2F-S架构风格"><a href="#B-x2F-S架构风格" class="headerlink" title="B&#x2F;S架构风格"></a>B&#x2F;S架构风格</h4><h4 id="MVC架构风格"><a href="#MVC架构风格" class="headerlink" title="MVC架构风格"></a>MVC架构风格</h4><h4 id="MVP架构风格"><a href="#MVP架构风格" class="headerlink" title="MVP架构风格"></a>MVP架构风格</h4><h3 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h3><h4 id="SOA概述"><a href="#SOA概述" class="headerlink" title="SOA概述"></a>SOA概述</h4><h4 id="SOA的关键技术"><a href="#SOA的关键技术" class="headerlink" title="SOA的关键技术"></a>SOA的关键技术</h4><h4 id="SOA的实现方法"><a href="#SOA的实现方法" class="headerlink" title="SOA的实现方法"></a>SOA的实现方法</h4><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h3 id="软件架构文档化"><a href="#软件架构文档化" class="headerlink" title="软件架构文档化"></a>软件架构文档化</h3><h3 id="软件架构评估"><a href="#软件架构评估" class="headerlink" title="软件架构评估"></a>软件架构评估</h3><h4 id="软件架构评估的方法"><a href="#软件架构评估的方法" class="headerlink" title="软件架构评估的方法"></a>软件架构评估的方法</h4><h4 id="架构的权衡分析法"><a href="#架构的权衡分析法" class="headerlink" title="架构的权衡分析法"></a>架构的权衡分析法</h4><h4 id="成本效益分析法"><a href="#成本效益分析法" class="headerlink" title="成本效益分析法"></a>成本效益分析法</h4><h3 id="构件及其复用"><a href="#构件及其复用" class="headerlink" title="构件及其复用"></a>构件及其复用</h3><h4 id="商用构件标准规范"><a href="#商用构件标准规范" class="headerlink" title="商用构件标准规范"></a>商用构件标准规范</h4><h4 id="应用系统簇与构件系统"><a href="#应用系统簇与构件系统" class="headerlink" title="应用系统簇与构件系统"></a>应用系统簇与构件系统</h4><h4 id="基于复用开发的组织结构"><a href="#基于复用开发的组织结构" class="headerlink" title="基于复用开发的组织结构"></a>基于复用开发的组织结构</h4><h3 id="产品线及系统演化"><a href="#产品线及系统演化" class="headerlink" title="产品线及系统演化"></a>产品线及系统演化</h3><h4 id="复用及产品线"><a href="#复用及产品线" class="headerlink" title="复用及产品线"></a>复用及产品线</h4><h4 id="基于产品线的架构"><a href="#基于产品线的架构" class="headerlink" title="基于产品线的架构"></a>基于产品线的架构</h4><h4 id="产品线的开发模型"><a href="#产品线的开发模型" class="headerlink" title="产品线的开发模型"></a>产品线的开发模型</h4><h4 id="特定领域软件架构"><a href="#特定领域软件架构" class="headerlink" title="特定领域软件架构"></a>特定领域软件架构</h4><h4 id="架构及系统演化"><a href="#架构及系统演化" class="headerlink" title="架构及系统演化"></a>架构及系统演化</h4><h3 id="软件架构视图"><a href="#软件架构视图" class="headerlink" title="软件架构视图"></a>软件架构视图</h3><h4 id="软件视图的分类"><a href="#软件视图的分类" class="headerlink" title="软件视图的分类"></a>软件视图的分类</h4><h4 id="模块视图类型及其风格"><a href="#模块视图类型及其风格" class="headerlink" title="模块视图类型及其风格"></a>模块视图类型及其风格</h4><h4 id="C-amp-C视图类型及其风格"><a href="#C-amp-C视图类型及其风格" class="headerlink" title="C&amp;C视图类型及其风格"></a>C&amp;C视图类型及其风格</h4><h4 id="分配视图类型及其风格"><a href="#分配视图类型及其风格" class="headerlink" title="分配视图类型及其风格"></a>分配视图类型及其风格</h4><h4 id="各视图类型间的映射关系"><a href="#各视图类型间的映射关系" class="headerlink" title="各视图类型间的映射关系"></a>各视图类型间的映射关系</h4><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h4><h4 id="设计模式的组成"><a href="#设计模式的组成" class="headerlink" title="设计模式的组成"></a>设计模式的组成</h4><h4 id="GoF设计模式"><a href="#GoF设计模式" class="headerlink" title="GoF设计模式"></a>GoF设计模式</h4><h4 id="其他设计模式"><a href="#其他设计模式" class="headerlink" title="其他设计模式"></a>其他设计模式</h4><h4 id="设计模式与软件架构"><a href="#设计模式与软件架构" class="headerlink" title="设计模式与软件架构"></a>设计模式与软件架构</h4><h4 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h4><h3 id="设计模式及实现"><a href="#设计模式及实现" class="headerlink" title="设计模式及实现"></a>设计模式及实现</h3><h3 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h3><h2 id="测试评审方法"><a href="#测试评审方法" class="headerlink" title="测试评审方法"></a>测试评审方法</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><h4 id="软件测试阶段"><a href="#软件测试阶段" class="headerlink" title="软件测试阶段"></a>软件测试阶段</h4><h4 id="白盒测试和黑盒测试"><a href="#白盒测试和黑盒测试" class="headerlink" title="白盒测试和黑盒测试"></a>白盒测试和黑盒测试</h4><h4 id="缺陷的分类和级别"><a href="#缺陷的分类和级别" class="headerlink" title="缺陷的分类和级别"></a>缺陷的分类和级别</h4><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><h3 id="评审方法"><a href="#评审方法" class="headerlink" title="评审方法"></a>评审方法</h3><h3 id="验证与确认"><a href="#验证与确认" class="headerlink" title="验证与确认"></a>验证与确认</h3><h3 id="测试自动化"><a href="#测试自动化" class="headerlink" title="测试自动化"></a>测试自动化</h3><h3 id="面向对象测试"><a href="#面向对象测试" class="headerlink" title="面向对象测试"></a>面向对象测试</h3><h2 id="嵌入式系统设计"><a href="#嵌入式系统设计" class="headerlink" title="嵌入式系统设计"></a>嵌入式系统设计</h2><h3 id="嵌入式系统概论"><a href="#嵌入式系统概论" class="headerlink" title="嵌入式系统概论"></a>嵌入式系统概论</h3><h3 id="嵌入式系统的组成"><a href="#嵌入式系统的组成" class="headerlink" title="嵌入式系统的组成"></a>嵌入式系统的组成</h3><h4 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h4><h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><h3 id="嵌入式开发平台与调试环境"><a href="#嵌入式开发平台与调试环境" class="headerlink" title="嵌入式开发平台与调试环境"></a>嵌入式开发平台与调试环境</h3><h4 id="嵌入式系统软件开发平台"><a href="#嵌入式系统软件开发平台" class="headerlink" title="嵌入式系统软件开发平台"></a>嵌入式系统软件开发平台</h4><h4 id="嵌入式开发调试"><a href="#嵌入式开发调试" class="headerlink" title="嵌入式开发调试"></a>嵌入式开发调试</h4><h3 id="嵌入式网络系统"><a href="#嵌入式网络系统" class="headerlink" title="嵌入式网络系统"></a>嵌入式网络系统</h3><h4 id="现场总线网"><a href="#现场总线网" class="headerlink" title="现场总线网"></a>现场总线网</h4><h4 id="家庭信息网"><a href="#家庭信息网" class="headerlink" title="家庭信息网"></a>家庭信息网</h4><h4 id="无线数据通信网"><a href="#无线数据通信网" class="headerlink" title="无线数据通信网"></a>无线数据通信网</h4><h4 id="嵌入式Internet"><a href="#嵌入式Internet" class="headerlink" title="嵌入式Internet"></a>嵌入式Internet</h4><h3 id="嵌入式数据库管理系统"><a href="#嵌入式数据库管理系统" class="headerlink" title="嵌入式数据库管理系统"></a>嵌入式数据库管理系统</h3><h4 id="使用环境的特点"><a href="#使用环境的特点" class="headerlink" title="使用环境的特点"></a>使用环境的特点</h4><h4 id="系统组成与关键技术"><a href="#系统组成与关键技术" class="headerlink" title="系统组成与关键技术"></a>系统组成与关键技术</h4><h3 id="实时系统与嵌入式操作系统"><a href="#实时系统与嵌入式操作系统" class="headerlink" title="实时系统与嵌入式操作系统"></a>实时系统与嵌入式操作系统</h3><h4 id="嵌入式系统的实时概念"><a href="#嵌入式系统的实时概念" class="headerlink" title="嵌入式系统的实时概念"></a>嵌入式系统的实时概念</h4><h4 id="嵌入式操作系统概述"><a href="#嵌入式操作系统概述" class="headerlink" title="嵌入式操作系统概述"></a>嵌入式操作系统概述</h4><h4 id="实时嵌入式操作系统"><a href="#实时嵌入式操作系统" class="headerlink" title="实时嵌入式操作系统"></a>实时嵌入式操作系统</h4><h4 id="主流嵌入式操作系统介绍"><a href="#主流嵌入式操作系统介绍" class="headerlink" title="主流嵌入式操作系统介绍"></a>主流嵌入式操作系统介绍</h4><h3 id="嵌入式系统开发设计"><a href="#嵌入式系统开发设计" class="headerlink" title="嵌入式系统开发设计"></a>嵌入式系统开发设计</h3><h4 id="嵌入式系统设计概述"><a href="#嵌入式系统设计概述" class="headerlink" title="嵌入式系统设计概述"></a>嵌入式系统设计概述</h4><h4 id="开发模型与设计流程"><a href="#开发模型与设计流程" class="headerlink" title="开发模型与设计流程"></a>开发模型与设计流程</h4><h4 id="嵌入式系统设计和核心技术"><a href="#嵌入式系统设计和核心技术" class="headerlink" title="嵌入式系统设计和核心技术"></a>嵌入式系统设计和核心技术</h4><h4 id="嵌入式开发设计环境"><a href="#嵌入式开发设计环境" class="headerlink" title="嵌入式开发设计环境"></a>嵌入式开发设计环境</h4><h4 id="嵌入式软件设计模型"><a href="#嵌入式软件设计模型" class="headerlink" title="嵌入式软件设计模型"></a>嵌入式软件设计模型</h4><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><h4 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h4><h4 id="系统集成与测试"><a href="#系统集成与测试" class="headerlink" title="系统集成与测试"></a>系统集成与测试</h4><h2 id="开发管理"><a href="#开发管理" class="headerlink" title="开发管理"></a>开发管理</h2><h3 id="项目的范围、时间和成本"><a href="#项目的范围、时间和成本" class="headerlink" title="项目的范围、时间和成本"></a>项目的范围、时间和成本</h3><h4 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h4><h4 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h4><h4 id="项目时间管理"><a href="#项目时间管理" class="headerlink" title="项目时间管理"></a>项目时间管理</h4><h3 id="配置管理与文档管理"><a href="#配置管理与文档管理" class="headerlink" title="配置管理与文档管理"></a>配置管理与文档管理</h3><h4 id="软件配置管理的概念"><a href="#软件配置管理的概念" class="headerlink" title="软件配置管理的概念"></a>软件配置管理的概念</h4><h4 id="软件配置管理的解决方案"><a href="#软件配置管理的解决方案" class="headerlink" title="软件配置管理的解决方案"></a>软件配置管理的解决方案</h4><h4 id="软件文档管理"><a href="#软件文档管理" class="headerlink" title="软件文档管理"></a>软件文档管理</h4><h3 id="软件需求管理"><a href="#软件需求管理" class="headerlink" title="软件需求管理"></a>软件需求管理</h3><h4 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h4><h4 id="需求跟踪"><a href="#需求跟踪" class="headerlink" title="需求跟踪"></a>需求跟踪</h4><h3 id="软件开发的质量与风险"><a href="#软件开发的质量与风险" class="headerlink" title="软件开发的质量与风险"></a>软件开发的质量与风险</h3><h4 id="软件质量管理"><a href="#软件质量管理" class="headerlink" title="软件质量管理"></a>软件质量管理</h4><h4 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h4><h3 id="人力资源管理"><a href="#人力资源管理" class="headerlink" title="人力资源管理"></a>人力资源管理</h3><h4 id="软件的运行与评价"><a href="#软件的运行与评价" class="headerlink" title="软件的运行与评价"></a>软件的运行与评价</h4><h4 id="软件过程改进"><a href="#软件过程改进" class="headerlink" title="软件过程改进"></a>软件过程改进</h4><h2 id="信息系统基础知识"><a href="#信息系统基础知识" class="headerlink" title="信息系统基础知识"></a>信息系统基础知识</h2><h3 id="信息系统概述"><a href="#信息系统概述" class="headerlink" title="信息系统概述"></a>信息系统概述</h3><h4 id="信息系统的组成"><a href="#信息系统的组成" class="headerlink" title="信息系统的组成"></a>信息系统的组成</h4><h4 id="信息系统的生命周期"><a href="#信息系统的生命周期" class="headerlink" title="信息系统的生命周期"></a>信息系统的生命周期</h4><h4 id="信息系统建设的原则"><a href="#信息系统建设的原则" class="headerlink" title="信息系统建设的原则"></a>信息系统建设的原则</h4><h4 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h4><h3 id="信息系统工程"><a href="#信息系统工程" class="headerlink" title="信息系统工程"></a>信息系统工程</h3><h4 id="信息系统工程的概念"><a href="#信息系统工程的概念" class="headerlink" title="信息系统工程的概念"></a>信息系统工程的概念</h4><h4 id="信息系统工程的内容"><a href="#信息系统工程的内容" class="headerlink" title="信息系统工程的内容"></a>信息系统工程的内容</h4><h4 id="信息系统工程的总体规划"><a href="#信息系统工程的总体规划" class="headerlink" title="信息系统工程的总体规划"></a>信息系统工程的总体规划</h4><h4 id="总体规划的方法论"><a href="#总体规划的方法论" class="headerlink" title="总体规划的方法论"></a>总体规划的方法论</h4><h3 id="政府信息化与电子政务"><a href="#政府信息化与电子政务" class="headerlink" title="政府信息化与电子政务"></a>政府信息化与电子政务</h3><h4 id="我国政府信息化的历程和策略"><a href="#我国政府信息化的历程和策略" class="headerlink" title="我国政府信息化的历程和策略"></a>我国政府信息化的历程和策略</h4><h4 id="电子政务的内容"><a href="#电子政务的内容" class="headerlink" title="电子政务的内容"></a>电子政务的内容</h4><h4 id="电子政务建设的过程模式和技术模式"><a href="#电子政务建设的过程模式和技术模式" class="headerlink" title="电子政务建设的过程模式和技术模式"></a>电子政务建设的过程模式和技术模式</h4><h3 id="企业信息化与电子商务"><a href="#企业信息化与电子商务" class="headerlink" title="企业信息化与电子商务"></a>企业信息化与电子商务</h3><h4 id="企业信息化概述"><a href="#企业信息化概述" class="headerlink" title="企业信息化概述"></a>企业信息化概述</h4><h4 id="企业资源规划"><a href="#企业资源规划" class="headerlink" title="企业资源规划"></a>企业资源规划</h4><h4 id="客户关系管理"><a href="#客户关系管理" class="headerlink" title="客户关系管理"></a>客户关系管理</h4><h4 id="产品数据管理"><a href="#产品数据管理" class="headerlink" title="产品数据管理"></a>产品数据管理</h4><h4 id="企业门户"><a href="#企业门户" class="headerlink" title="企业门户"></a>企业门户</h4><h4 id="企业应用集成"><a href="#企业应用集成" class="headerlink" title="企业应用集成"></a>企业应用集成</h4><h4 id="供应链管理"><a href="#供应链管理" class="headerlink" title="供应链管理"></a>供应链管理</h4><h4 id="电子商务概述"><a href="#电子商务概述" class="headerlink" title="电子商务概述"></a>电子商务概述</h4><h3 id="知识管理与商业智能"><a href="#知识管理与商业智能" class="headerlink" title="知识管理与商业智能"></a>知识管理与商业智能</h3><h4 id="知识管理"><a href="#知识管理" class="headerlink" title="知识管理"></a>知识管理</h4><h4 id="商业智能"><a href="#商业智能" class="headerlink" title="商业智能"></a>商业智能</h4><h3 id="业务流程重组"><a href="#业务流程重组" class="headerlink" title="业务流程重组"></a>业务流程重组</h3><h2 id="基于中间件的开发"><a href="#基于中间件的开发" class="headerlink" title="基于中间件的开发"></a>基于中间件的开发</h2><h3 id="中间件技术"><a href="#中间件技术" class="headerlink" title="中间件技术"></a>中间件技术</h3><h4 id="中间件的概述"><a href="#中间件的概述" class="headerlink" title="中间件的概述"></a>中间件的概述</h4><h4 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h4><h4 id="中间件产品介绍"><a href="#中间件产品介绍" class="headerlink" title="中间件产品介绍"></a>中间件产品介绍</h4><h3 id="应用服务器技术"><a href="#应用服务器技术" class="headerlink" title="应用服务器技术"></a>应用服务器技术</h3><h4 id="应用服务器的概念"><a href="#应用服务器的概念" class="headerlink" title="应用服务器的概念"></a>应用服务器的概念</h4><h4 id="主要的应用服务器"><a href="#主要的应用服务器" class="headerlink" title="主要的应用服务器"></a>主要的应用服务器</h4><h3 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h3><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><h4 id="应用服务层"><a href="#应用服务层" class="headerlink" title="应用服务层"></a>应用服务层</h4><h3 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h3><h3 id="企业应用集成-1"><a href="#企业应用集成-1" class="headerlink" title="企业应用集成"></a>企业应用集成</h3><h3 id="轻量级架构和重量级架构"><a href="#轻量级架构和重量级架构" class="headerlink" title="轻量级架构和重量级架构"></a>轻量级架构和重量级架构</h3><h2 id="安全性和保密性设计"><a href="#安全性和保密性设计" class="headerlink" title="安全性和保密性设计"></a>安全性和保密性设计</h2><h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><h4 id="对称密钥加密算法"><a href="#对称密钥加密算法" class="headerlink" title="对称密钥加密算法"></a>对称密钥加密算法</h4><h4 id="非对称密钥加密算法"><a href="#非对称密钥加密算法" class="headerlink" title="非对称密钥加密算法"></a>非对称密钥加密算法</h4><h3 id="数字签名和数字水印"><a href="#数字签名和数字水印" class="headerlink" title="数字签名和数字水印"></a>数字签名和数字水印</h3><h3 id="数字证书和密钥管理"><a href="#数字证书和密钥管理" class="headerlink" title="数字证书和密钥管理"></a>数字证书和密钥管理</h3><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><h3 id="计算机病毒与防治"><a href="#计算机病毒与防治" class="headerlink" title="计算机病毒与防治"></a>计算机病毒与防治</h3><h3 id="身份认证与访问控制"><a href="#身份认证与访问控制" class="headerlink" title="身份认证与访问控制"></a>身份认证与访问控制</h3><h3 id="网络安全体系"><a href="#网络安全体系" class="headerlink" title="网络安全体系"></a>网络安全体系</h3><h4 id="OSI安全架构"><a href="#OSI安全架构" class="headerlink" title="OSI安全架构"></a>OSI安全架构</h4><h4 id="VPN在网络安全中的应用"><a href="#VPN在网络安全中的应用" class="headerlink" title="VPN在网络安全中的应用"></a>VPN在网络安全中的应用</h4><h3 id="系统的安全性设计"><a href="#系统的安全性设计" class="headerlink" title="系统的安全性设计"></a>系统的安全性设计</h3><h4 id="物理安全问题与设计"><a href="#物理安全问题与设计" class="headerlink" title="物理安全问题与设计"></a>物理安全问题与设计</h4><h4 id="防火墙及其在系统安全中的应用"><a href="#防火墙及其在系统安全中的应用" class="headerlink" title="防火墙及其在系统安全中的应用"></a>防火墙及其在系统安全中的应用</h4><h4 id="入侵检测系统"><a href="#入侵检测系统" class="headerlink" title="入侵检测系统"></a>入侵检测系统</h4><h3 id="安全性规章"><a href="#安全性规章" class="headerlink" title="安全性规章"></a>安全性规章</h3><h2 id="系统的可靠性分析与设计"><a href="#系统的可靠性分析与设计" class="headerlink" title="系统的可靠性分析与设计"></a>系统的可靠性分析与设计</h2><h3 id="可靠性概述"><a href="#可靠性概述" class="headerlink" title="可靠性概述"></a>可靠性概述</h3><h3 id="系统故障模型"><a href="#系统故障模型" class="headerlink" title="系统故障模型"></a>系统故障模型</h3><h4 id="故障的来源以及表现"><a href="#故障的来源以及表现" class="headerlink" title="故障的来源以及表现"></a>故障的来源以及表现</h4><h4 id="几种常见的故障模型"><a href="#几种常见的故障模型" class="headerlink" title="几种常见的故障模型"></a>几种常见的故障模型</h4><h3 id="系统配置方法"><a href="#系统配置方法" class="headerlink" title="系统配置方法"></a>系统配置方法</h3><h4 id="单机容错技术"><a href="#单机容错技术" class="headerlink" title="单机容错技术"></a>单机容错技术</h4><h4 id="双机热备份技术"><a href="#双机热备份技术" class="headerlink" title="双机热备份技术"></a>双机热备份技术</h4><h4 id="服务器集群技术"><a href="#服务器集群技术" class="headerlink" title="服务器集群技术"></a>服务器集群技术</h4><h3 id="系统可靠性模型"><a href="#系统可靠性模型" class="headerlink" title="系统可靠性模型"></a>系统可靠性模型</h3><h4 id="时间模型"><a href="#时间模型" class="headerlink" title="时间模型"></a>时间模型</h4><h4 id="故障植入模型"><a href="#故障植入模型" class="headerlink" title="故障植入模型"></a>故障植入模型</h4><h4 id="数据模型-1"><a href="#数据模型-1" class="headerlink" title="数据模型"></a>数据模型</h4><h3 id="系统的可靠性分析和可靠度计算"><a href="#系统的可靠性分析和可靠度计算" class="headerlink" title="系统的可靠性分析和可靠度计算"></a>系统的可靠性分析和可靠度计算</h3><h4 id="组合模型"><a href="#组合模型" class="headerlink" title="组合模型"></a>组合模型</h4><h4 id="马尔柯夫模型"><a href="#马尔柯夫模型" class="headerlink" title="马尔柯夫模型"></a>马尔柯夫模型</h4><h3 id="提高系统可靠性的措施"><a href="#提高系统可靠性的措施" class="headerlink" title="提高系统可靠性的措施"></a>提高系统可靠性的措施</h3><h4 id="硬件冗余"><a href="#硬件冗余" class="headerlink" title="硬件冗余"></a>硬件冗余</h4><h4 id="信息冗余"><a href="#信息冗余" class="headerlink" title="信息冗余"></a>信息冗余</h4><h3 id="备份与恢复-1"><a href="#备份与恢复-1" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><h2 id="软件的知识产权保护"><a href="#软件的知识产权保护" class="headerlink" title="软件的知识产权保护"></a>软件的知识产权保护</h2><h3 id="著作权法及实施条例"><a href="#著作权法及实施条例" class="headerlink" title="著作权法及实施条例"></a>著作权法及实施条例</h3><h4 id="著作权法客体"><a href="#著作权法客体" class="headerlink" title="著作权法客体"></a>著作权法客体</h4><h4 id="著作权法的主体"><a href="#著作权法的主体" class="headerlink" title="著作权法的主体"></a>著作权法的主体</h4><h4 id="著作权"><a href="#著作权" class="headerlink" title="著作权"></a>著作权</h4><h3 id="计算机软件保护条例"><a href="#计算机软件保护条例" class="headerlink" title="计算机软件保护条例"></a>计算机软件保护条例</h3><h3 id="商标法及实施条例"><a href="#商标法及实施条例" class="headerlink" title="商标法及实施条例"></a>商标法及实施条例</h3><h3 id="专利法及实施细则"><a href="#专利法及实施细则" class="headerlink" title="专利法及实施细则"></a>专利法及实施细则</h3><h3 id="反不正当竞争法"><a href="#反不正当竞争法" class="headerlink" title="反不正当竞争法"></a>反不正当竞争法</h3><h2 id="标准化知识"><a href="#标准化知识" class="headerlink" title="标准化知识"></a>标准化知识</h2><h3 id="标准化概论"><a href="#标准化概论" class="headerlink" title="标准化概论"></a>标准化概论</h3><h3 id="标准分级与标准类型"><a href="#标准分级与标准类型" class="headerlink" title="标准分级与标准类型"></a>标准分级与标准类型</h3><h4 id="标准分级"><a href="#标准分级" class="headerlink" title="标准分级"></a>标准分级</h4><h4 id="强制性标准与推荐性标准"><a href="#强制性标准与推荐性标准" class="headerlink" title="强制性标准与推荐性标准"></a>强制性标准与推荐性标准</h4><h2 id="应用数学"><a href="#应用数学" class="headerlink" title="应用数学"></a>应用数学</h2><h3 id="运筹方法"><a href="#运筹方法" class="headerlink" title="运筹方法"></a>运筹方法</h3><h4 id="网络计划技术"><a href="#网络计划技术" class="headerlink" title="网络计划技术"></a>网络计划技术</h4><h4 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h4><h4 id="决策论"><a href="#决策论" class="headerlink" title="决策论"></a>决策论</h4><h4 id="对策论"><a href="#对策论" class="headerlink" title="对策论"></a>对策论</h4><h3 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h3><h2 id="虚拟化、云计算和物联网"><a href="#虚拟化、云计算和物联网" class="headerlink" title="虚拟化、云计算和物联网"></a>虚拟化、云计算和物联网</h2><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><h3 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/03/20/CSS%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/20/CSS%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">CSS代码管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-20 21:11:40" itemprop="dateCreated datePublished" datetime="2018-03-20T21:11:40+08:00">2018-03-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="样式文件"><a href="#样式文件" class="headerlink" title="样式文件"></a>样式文件</h1><p>CSS提供了import命令引用样式文件。但其存在一些问题：</p>
<ol>
<li>影响浏览器并行下载</li>
<li>加载顺序错乱</li>
</ol>
<p>从而其使用率极低。</p>
<p>更常见的做法是通过预处理器或编译工具插件来引入样式文件。</p>
<h1 id="如何避免样式冲突"><a href="#如何避免样式冲突" class="headerlink" title="如何避免样式冲突"></a>如何避免样式冲突</h1><p>CSS的规则是全局的。</p>
<p>任何一个样式规则，都对整个页面有效。</p>
<p>如果不对选择器的命名加以管控会很容易产生冲突。</p>
<h1 id="手动命名"><a href="#手动命名" class="headerlink" title="手动命名"></a>手动命名</h1><p>最简单有效的命名管理方式就是制定一些命名规则：</p>
<p>比如OOCSS、BEM\AMCSS，其中比较推荐BEM。</p>
<p>BEM是Block、Element、Modifier三个单词的缩写。</p>
<p>Block代表独立的功能组件</p>
<p>Element代表功能组件的一个组成部分</p>
<p>Modifier对应状态信息</p>
<p><img src="/2018/03/20/CSS%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/image-20230320221008812.png" alt="image-20230320221008812"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/03/19/CSS%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/19/CSS%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">CSS布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-19 23:38:59" itemprop="dateCreated datePublished" datetime="2018-03-19T23:38:59+08:00">2018-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h1><p>最常用的一种布局</p>
<p>实现效果就是将一个元素作为布局容器，通常设置一个较小的（最大）宽度来保证不同像素宽度屏幕下显示一致。</p>
<p>优势：</p>
<p>基本可以适配超过布局容器宽度的各种显示屏幕。</p>
<p>缺点：</p>
<p>过渡的冗余设计必然会带来浪费，屏幕宽度可以显示更多的内容，但是页面两侧却出现了大量的空白区域。</p>
<h1 id="2列布局"><a href="#2列布局" class="headerlink" title="2列布局"></a>2列布局</h1><p>将页面分成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满。</p>
<p>宽度较小的列父元素为次要布局容器。</p>
<p>宽度较大的列父元素为主要布局容器。</p>
<h1 id="3列布局"><a href="#3列布局" class="headerlink" title="3列布局"></a>3列布局</h1><p>按照左中右的顺序进行排列，通常中间列最宽，左右两列次之。</p>
<h1 id="布局实现"><a href="#布局实现" class="headerlink" title="布局实现"></a>布局实现</h1><p>单列布局通过将设置布局容器（最大）宽度以及左右边距为auto即可实现。</p>
<p>2列和3列布局方式。</p>
<ol>
<li>为了保证主要布局容器优先级，应将主要布局容器写在次要布局容器之前。</li>
<li>将布局容器进行水平排列。</li>
<li>设置宽度，即次要容器宽度固定，主要容器撑满。</li>
<li>消除布局方式的副作用，如浮动造成的高度塌陷。</li>
<li>为了在窄屏下也能正常显示，可以通过媒体查询进行优化。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/03/05/wx-applet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/05/wx-applet/" class="post-title-link" itemprop="url">微信.小程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-05 08:17:00" itemprop="dateCreated datePublished" datetime="2018-03-05T08:17:00+08:00">2018-03-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p>前往<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">小程序注册</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a> 注册小程序，一个邮箱账号对应一个小程序。<br>登录 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">微信公众平台</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com</a> ，在菜单 “设置”-“开发设置” 获取小程序的 AppID。</p>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=19020120">下载地址</a></p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/">官网开发文档</a></p>
<h4 id="设置服务器域名"><a href="#设置服务器域名" class="headerlink" title="设置服务器域名"></a>设置服务器域名</h4><p>小程序要与后端交互，需要登录“微信工作平台|小程序”，在“开发”-“开发设置”-“服务器域名”添加域名，并且服务器要支持HTTPS协议。<br>如果在开发过程中使用了web-view组件，需要在“开发设置”中的“业务域名”中添加域名，并且只有企业号对应的小程序才有此项功能，个人账户不能进行此项设置。<br><img src="/2018/03/05/wx-applet/wx-applet/domain.png" alt="域名设置">   </p>
<h3 id="成员管理"><a href="#成员管理" class="headerlink" title="成员管理"></a>成员管理</h3><p>在“管理”-“成员管理”里可以添加项目成员和体验成员，上传代码后在“版本管理”-“开发版本”中设置体验版本，已经添加的体验成员就可以扫描二维码体验小程序。    </p>
<h3 id="发布小程序"><a href="#发布小程序" class="headerlink" title="发布小程序"></a>发布小程序</h3><p>在小程序功能测试通过后，上传代码，在“开发版本”中提交审核，审核通过后在“审核版本”中发布到线上。<br><img src="/2018/03/05/wx-applet/wx-applet/publish.png" alt="发布小程序">   </p>
<p>发布成功后在微信里删除开发版本和预览版本，删除后台微信进程，重新打开微信，在小程序中搜索已发布的小程序，验证是否发布成功。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/" class="post-title-link" itemprop="url">读《聊聊架构》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-22 17:36:14" itemprop="dateCreated datePublished" datetime="2018-01-22T17:36:14+08:00">2018-01-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="认识架构"><a href="#认识架构" class="headerlink" title="认识架构"></a>认识架构</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="为什么会产生架构"><a href="#为什么会产生架构" class="headerlink" title="为什么会产生架构"></a>为什么会产生架构</h3><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="什么是抽象"><a href="#什么是抽象" class="headerlink" title="什么是抽象"></a>什么是抽象</h3><h3 id="识别问题"><a href="#识别问题" class="headerlink" title="识别问题"></a>识别问题</h3><p>遇到问题时，要识别出问题的主题，划分出问题的边界约束。<br>当遇到问题时，如果发现自己正在致力于把自己的工作完成，就要马上警惕起来，因为这样下去会演变成没有主人翁精神的工作态度。在面对概念的时候，也会不求甚解，最终导致无法真正的理解概念。作为软件工程师或架构师，我们大部分时候是要去解决别人的问题（用户的问题），“别人”是谁，是值得好好考虑的。</p>
<blockquote>
<p>发现问题永远比解决问题更加重要</p>
</blockquote>
<p>问题的主题是用户</p>
<h3 id="切分的原则"><a href="#切分的原则" class="headerlink" title="切分的原则"></a>切分的原则</h3><p>确定问题主题后，在解决问题的过程中，产生新的问题，需要做调整，而要采取新的行动解决问题，解决的方式就是架构拆分</p>
<h4 id="切分原则"><a href="#切分原则" class="headerlink" title="切分原则"></a>切分原则</h4><ol>
<li>被切分的生命周期，如果必须要生命周期的主题在连续时间内持续执行，而且不能够被打断并更换生命周期主体的话，就不能切分出去。这类生命周期是切分的最小粒度，受限于当前的技术水平无法进一步切分。（比如十月怀胎，不能10人怀胎1人1月）</li>
<li>每个生命周期的负责人，对所负责生命周期的权利和义务必须是对等的。</li>
<li>切分出来的生命周期，不应该超出一个自然人的负载。根据没人能力实际情况实际情况进行调整。切分出来的只能是非核心生命周期，这些生命周期必须是完整的，内聚的。</li>
<li>切分是内部活动，内部切分对整个系统的外部都是透明的</li>
</ol>
<h4 id="树和分层"><a href="#树和分层" class="headerlink" title="树和分层"></a>树和分层</h4><p>所有的架构拆分都应该形成树的结构，并且层次越少越好。其中节点的权责对等，如果出现不对等的情况要及时调整，保持效率。</p>
<h4 id="切分和建模"><a href="#切分和建模" class="headerlink" title="切分和建模"></a>切分和建模</h4><p>架构切分的过程就是建模的过程。随着业务和规模的增加，就要进行拆分。拆分就需要识别核心生命周期和非核心生命周期，把非核心生命周期切分出来。切分出来的非核心生命周期形成新的模型，核心生命周期模型把所有的模型通过树组织起来，形成新的模型</p>
<p>总结. </p>
<blockquote><p>1.架构切分的导火索是人的负载太重，也就是时间不够。<br>2.架构的切分实际就是对利益相关人的利益进行切分和合并，使得每个利益相关人的权责是对等的，每个利益相关人可以为自己的利益负责。<br>3.架构切分的最终结果都会体现在组织架构上，只有这样才能够让架构落地进行。<br>4.架构切分的结果一定是一棵树状，这也是为什么会产生分层。层数越多沟通越多，效率越低，分层要越少越好。尽可能变成一棵平衡树，才能让整个系统的效率最大化。</p>
</blockquote>

<h3 id="架构与流程"><a href="#架构与流程" class="headerlink" title="架构与流程"></a>架构与流程</h3><h3 id="什么是架构师"><a href="#什么是架构师" class="headerlink" title="什么是架构师"></a>什么是架构师</h3><p>架构师需要了解清楚业务，挖掘出核心生命周期，并确定核心生命周期的主体（架构师要发现问题主体，并确定核心问题）。在确定业务核心生命周期及核心生命周期主体之后，需要对核心生命周期进行分析，剥离非核心生命周期，根据当前人员状况，合理分配非核心生命周期的权责。<br>架构师要具备调动资源的能力。架构包括设计和执行层面。架构师需要有调动资源执行项目的权力，同时也有识别项目核心生命周期，思考核心生命周期主体，合理分配权力，保证效率。</p>
<h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h3 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h3><h3 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h3><p>软件的整个生命周期会发生切分，从而形成两个子生命周期：软件开发生命周期和软件运行生命周期。<br>软件运行生命周期才是核心生命周期，因为软件运行生命周期的主体和大的生命周期一致。<br>围绕软件的生命周期，可以切分出很多非核心生命周期：    </p>
<ol>
<li>软件开发生命周期，其中又可以切分出需求生命周期、代码开发生命周期、测试生命周期。</li>
<li>软件的运行生命周期。其中包含：<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;a.软件的访问生命周期。<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;b.软件的功能生命周期。<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;c.软件的监控生命周期。</li>
</ol>
<h4 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h4><blockquote>
<p>从软件的运行生命周期角度来说，一个可运行的独立部署单元才算是一个软件。</p>
</blockquote>
<h5 id="软件开发的增长"><a href="#软件开发的增长" class="headerlink" title="软件开发的增长"></a>软件开发的增长</h5><p>一个软件项目需要多人分工合作，就需要架构切分，软件开发的核心生命周期是编写代码，在这个核心生命周期下，软件开发生命周期可被切分成不同的非核心生命周期，每个非核心生命周期围绕核心生命周期组成树状架构，在时间和空间上并行开展工作，提升产量和速度。<br>不同的拆分方式，形成了不同的软件开发模式</p>
<h5 id="软件开发的迭代"><a href="#软件开发的迭代" class="headerlink" title="软件开发的迭代"></a>软件开发的迭代</h5><h4 id="软件开发的运行生命周期"><a href="#软件开发的运行生命周期" class="headerlink" title="软件开发的运行生命周期"></a>软件开发的运行生命周期</h4><p>软件功能的使用情况，会形成功能的访问生命周期，这个生命周期和业务的子生命周期相关。<br>软件启动后，运维要对系统进行监控，如zabbix。   </p>
<h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>软件架构就是通过对软件生命周期的拆分，在符合业务架构的前提下，以达到软件本身访问增长目的的方式。这个增长需要软件开发的增长，也需要软件运行的增长，由此达到所支撑业务的增长。<br>软件架构离不开软件开发团队的组织架构，这个组织架构是软件开发生命周期和软件运行生命周期的执行者。架构的核心生命周期就是架构的执行。    </p>
<h3 id="什么是软件架构师"><a href="#什么是软件架构师" class="headerlink" title="什么是软件架构师"></a>什么是软件架构师</h3><blockquote>
<p> 技术人员如果要成为架构师，就必须跳出技术的视角，换一个角度去看技术。要把时间花在研究生命周期规律和业务的增长上，花在选择合适的技术上，而不只是追求新潮的或自己喜欢的技术。     </p>
</blockquote>
<h3 id="业务、架构和技术三者的关系"><a href="#业务、架构和技术三者的关系" class="headerlink" title="业务、架构和技术三者的关系"></a>业务、架构和技术三者的关系</h3><p>先有业务问题，才会有技术来解决业务问题。而业务的长大要求，提高了对技术的要求，导致了对业务生命周期的拆分，以并行的方式提升效率，形成了架构，也形成了新的技术。所以在三者的关系里：<br>业务是核心，技术是解决业务问题的工具，而架构师让业务长大的组织方法。<br>架构需要用技术来实现拆分，而技术需要架构来合理组织，以提升效率。</p>
<p>选择技术时需要考虑的点：<br>1.当技术所要解决的问题和拆分出来要解决的问题完全匹配时，这是最完美的。<br>2.当技术所提供的能力远远超过需要解决的问题时，往往掌握技术和维护技术就会成为负担。<br>3.当技术所提供的能力和我们所要解决的问题部分匹配时，要判断是否要采用，最终还是要看成本。<br>所以，在架构拆分的基础之上，识别并平衡技术的能力，也是架构师所需要具备的能力之一。考虑的主要因素是长期的成本和收益。    </p>
<h3 id="软件研发"><a href="#软件研发" class="headerlink" title="软件研发"></a>软件研发</h3><p>软件所面对的共有三大业务领域及其所对应的架构。    </p>
<ol>
<li>业务领域，由业务组织架构来推动业务的架构，即业务生命周期的拆分。</li>
<li>软件开发业务领域，由软件开发的业务组织架构来推动软件的业务架构，如软件的研发流程、角色分工等。所形成的是软件开发模式，不同角色的分工模型。</li>
<li>软件运行业务领域，由软件的开发工程师来负责编写代码，形成软件的架构，并支撑软件的运行。对不同的软件开发工程师进行分工，形成不同的软件开发工程师组织架构，以支撑不同的软件，与软件的架构相匹配。</li>
</ol>
<p>在软件开发生命周期中，软件工程师和软件架构师是最重要的两个角色，软件工程师负责建设，软件架构师负责组织。<br>为了支持软件工程师的工作，软件架构师的主要职责包括以下几点：     </p>
<ol>
<li>理解业务组织架构，业务组织架构支撑并推进业务架构，背后的原因是对业务生命周期的拆分。     </li>
<li>根据业务生命周期的特点和软件开发生命周期的特点，形成软件开发本身的业务体系，以及对软件开发生命周期的拆分，也就是软件开发的业务架构。    </li>
<li>根据对业务生命周期以及软件开发生命周期的拆分，形成了和两者都相匹配的软件开发团队的组织架构。    </li>
<li>对软件进行架构拆分，匹配业务架构和软件开发的业务架构。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p1.png" alt="业务、软件开发业务和软件运行业务三者间的关系">.</li>
</ol>
<h3 id="软件的架构拆分"><a href="#软件的架构拆分" class="headerlink" title="软件的架构拆分"></a>软件的架构拆分</h3><h4 id="软件团队拆分"><a href="#软件团队拆分" class="headerlink" title="软件团队拆分"></a>软件团队拆分</h4><p>比较好的拆分方式：一个业务团队对应一个软件开发团队。<br>这个方式要求每个业务部门都有独立的软件开发团队来配合。每个软件开发团队只对应一个业务团队，这样所形成的软件边界都很清楚，沟通也很高效。业务团队和对应的软件开发团队能够形成合力，共同解决该团队的业务问题。<br>这种方式会让软件开发团队的组织也形成一棵组织架构树，并且这棵树和业务团队的组织架构是匹配的。      </p>
<h4 id="软件的拆分"><a href="#软件的拆分" class="headerlink" title="软件的拆分"></a>软件的拆分</h4><p>一个软件开发团队开发一个软件。这样每个软件的职责非常明确，沟通也会比较简单，这是最好的。这时形成的还是一棵树。软件和软件之间的关系，反映的就是组织和组织之间的关系，一一对应，还是一棵树。 </p>
<p>在拆分过程中，要避免不同的用户访问通道相互影响。因此，软件在访问通道的问题上不能重用。重用访问通道的结果，既损伤用户的利益，也损伤软件的利益，还会损伤软件开发团队和企业的利益。    </p>
<h4 id="软件开发的基础技术"><a href="#软件开发的基础技术" class="headerlink" title="软件开发的基础技术"></a>软件开发的基础技术</h4><p><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p2.png" alt="企业组织架构和软件架构_图片"><br>架构拆分的原则来源于业务自身的组织架构，使得软件架构保持和业务组织架构的匹配关系；其次来源于软件开发团队自身的组织架构；最后来源于用户的流量对软件本身的冲击。如果软件开发团队的组织架构和业务的组织架构一致，这就是损耗最小的方式，软件的架构也会更简单。</p>
<h3 id="如何写好代码"><a href="#如何写好代码" class="headerlink" title="如何写好代码"></a>如何写好代码</h3><p>内聚：内聚就是要确保一个事物的生命周期是完整的，而不是分裂的。所谓完整，就是指一个生命周期的主体，从生到死之间的整个过程中，所发生的行为和状态是累积在一个主体上的。<br>从流程角度讲，访问逻辑实际上就是实现业务流程的基础。每次访问都通过对不同角色的生命周期，也就是不同的业务逻辑进行访问，访问其实就是遍历架构树，形成业务流程，完成用户生命周期活动的推进。     </p>
<h4 id="业务逻辑分散的危害"><a href="#业务逻辑分散的危害" class="headerlink" title="业务逻辑分散的危害"></a>业务逻辑分散的危害</h4><ol>
<li>如果服务代码中混入了业务逻辑，则服务做了两件或者两件以上的事情。服务本身的责任是逻辑，这是顺序执行。加入了业务逻辑就表明做了两件或者两件以上的事情。可以分为以下两种情况：<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;a.两个不同的访问生命周期合并在一个服务中实现。<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;b.如果是有计算的逻辑的话，比如受益计算、订单金额计算等，那么这部分应该是业务代码需要完成的，不能交给服务代码来实现。这部分代码是需要单元测试的，而服务代码要和用户打交道就会有上下文相关的代码，因此不适合做单元测试。</li>
<li>黏合代码里面包含业务逻辑的话，也会做两件或者两件以上的事情，会和业务代码一样，遇到同样的问题。</li>
<li>存储代码里面如果混入了业务逻辑，则会导致业务逻辑进入到存储设备中。<br>存储一旦变成了逻辑计算的主体，绑定数据的逻辑计算就成了一个巨大的限制，会导致存储设备无法通过增加机器的方式横向扩展长大，只能换性能更好的机器纵向扩展，而纵向扩展不仅程度有限而且成本也较高。</li>
</ol>
<h4 id="业务逻辑内聚的好处"><a href="#业务逻辑内聚的好处" class="headerlink" title="业务逻辑内聚的好处"></a>业务逻辑内聚的好处</h4><h4 id="代码架构的实例"><a href="#代码架构的实例" class="headerlink" title="代码架构的实例"></a>代码架构的实例</h4><p>如图所示，Manager类实际就是黏合代码。<br>注意事项：      </p>
<ol>
<li>不能把业务模型当做数据对象来处理。业务模型关心的是其生命周期，数据是这些生命周期行为的状态。所以黏合代码需要把业务模型转换成存储设备的实体(entity)，实体和存储设备里面的存储粒度一一对应。比如在数据库中，每个实体对应一张表，并且跟着表的变化而变化，这样就保证存储设备的变更不会影响业务模型。同样业务模型不能拿来用作服务和用户之间的数据交换媒介，只能转换为DTO（Data Transfer Object）来使用。也就是说业务模型对用户是不可见的。DTO的目的是在用户的访问操作中传输数据，并和用户交互的视图保持一致。通过增加DTO可以保证用户的访问生命周期需求变化，并不会影响到业务模型，虽然用户的访问生命周期需要变化是最频繁的，但DTO解决了这个难题。     </li>
<li>服务代码里不要考虑代码的重用。针对不同的用户提供不同的服务，确保他们之间的访问生命周期是隔离的，避免相互影响。多个角色访问同一个接口，其中一个角色改了共有接口，势必会影响其他角色对该接口的正常使用。尽量给不同的角色不同的服务，既避免通道重用又降低沟通成本。服务多不是问题，服务的生命周期管理才是问题。    </li>
<li>业务模型是必须要重用的，因为这是所有用户访问的目标。业务模型总是围绕着核心生命周期展开的一棵树状结构。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p3.png" alt="案例"></li>
</ol>
<h4 id="代码误解"><a href="#代码误解" class="headerlink" title="代码误解"></a>代码误解</h4><p>服务代码、黏合代码和存储代码不能有逻辑。</p>
<h4 id="软件的拆分-1"><a href="#软件的拆分-1" class="headerlink" title="软件的拆分"></a>软件的拆分</h4><p>软件的拆分必须要和业务的拆分对应起来，此时就可看出业务生命周期分析的好处。软件的核心是模拟业务，而业务代码是按照业务的生命周期组织的，软件拆分的目的就是把软件的业务生命周期代码进行生命周期拆分。<br>不仅仅代码内部可以进行拆分，还可以直接把某些业务生命周期的代码拆分到另外一个软件中，并把相应的服务代码、管理者代码和存储代码一起拆分过去。这个拆分方式就形成了新的软件，而对原软件的影响仅仅是对被拆分出去的业务调用方式发生了变化而已，从本地调用变成了服务调用。<br>业务生命周期的分析既是软件拆分的大前提又是架构的基因。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是一种白盒测试，集成测试是一种黑盒测试。</p>
<h4 id="单元测试测什么"><a href="#单元测试测什么" class="headerlink" title="单元测试测什么"></a>单元测试测什么</h4><p>服务代码、管理者代码和存储代码都是不需要写单元测试的。单元测试是用来测试软件工程师自己写的逻辑，如果代码里面没有逻辑就不需要写单元测试。</p>
<h4 id="如何改造代码"><a href="#如何改造代码" class="headerlink" title="如何改造代码"></a>如何改造代码</h4><p>只要出现了模拟，单元测试就开始失效了。<br>对于一个逻辑“单元”，也就是方法，所依赖两个方面：一个是输入的参数，另一个是内部对外部的方法调用。只要确保输入参数不包含外部环境的上下文，同时内部代码对外部的调用也不包含对环境上下文的访问，这个方法就是可以单元测试的。</p>
<h4 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h4><ol>
<li>构建输入参数，并预测该输入所产生的输出。</li>
<li>调用要测试的目标方法，获取输出。</li>
<li>检测目标方法的输出是否和预测的输出一致。</li>
</ol>
<h3 id="软件架构和面向对象"><a href="#软件架构和面向对象" class="headerlink" title="软件架构和面向对象"></a>软件架构和面向对象</h3><h3 id="软件架构和设计模式"><a href="#软件架构和设计模式" class="headerlink" title="软件架构和设计模式"></a>软件架构和设计模式</h3><h4 id="设计模式和架构"><a href="#设计模式和架构" class="headerlink" title="设计模式和架构"></a>设计模式和架构</h4><p>创建型模式用生命周期来理解，就是把产生对象的生命周期单独拆分出来，即发生了架构分析。结构型模式则专注于对象的不同组合方式，而行为型则主要针对对象之间的沟通。<br>软件设计模式本身就是一个架构拆分的结果，只是这个拆分被标准化了，可以被重复使用而已。而设计模式在被使用的时候，则不需要再进行设计，直接使用即可。因此设计模式就变成了一个成熟的技巧或者技术了。软件设计模式这部分的代码其实是有自己的业务领域的，这个领域就是软件的访问生命周期。<br>只有从访问代码中剥离了所有服务业务的逻辑，才有可能讨论软件访问生命周期自身的业务模型。</p>
<h4 id="设计模式的误区"><a href="#设计模式的误区" class="headerlink" title="设计模式的误区"></a>设计模式的误区</h4><p>对于业务对象来说，业务对象表达的是业务的核心分工，是不同用户所访问的目标，这部分自然是要重用的。因为现实生活中，业务的分工就是这样的，执行业务的时候按照业务的访问流程组合不同的对象即可。但对于服务、黏合代码和存储而言，它们都有自己独特的业务问题，即它们处理访问通道的，目的并不是给大家共享，也不是访问的目标。而处理好通道问题，则是按照不同角度的用户来进行分析，提供不同的通道，让他们之间的访问互不影响，才能够服务好不同的要求。访问通道是不重用的。</p>
<h3 id="软件架构和软件框架"><a href="#软件架构和软件框架" class="headerlink" title="软件架构和软件框架"></a>软件架构和软件框架</h3><h4 id="访问类框架"><a href="#访问类框架" class="headerlink" title="访问类框架"></a>访问类框架</h4><p>MVC中的模型（Model）更多的是指对试图（View）的数据支持，一般用DTO（data transfer Object）来表达。而业务模型关注的是业务生命周期及其行为，业务模型的内部数据只是这些行为的结果。MVC中的模型和业务模型是连个不同的概念，不可混用。但是两者可以通过数据转换结合起来连接沟通使用，需要类似于适配器（Adapter）的模式（如ORM）来解决这个问题。</p>
<h4 id="业务类框架"><a href="#业务类框架" class="headerlink" title="业务类框架"></a>业务类框架</h4><p>为整个行业提供解决方案，而形成的一个行业的框架。如CRM（Customer Relationship Management），CRM把和用户打交道的基本规则封装起来，然后留给各企业按照自己企业的特点做一定变化的空间，最终所形成的就是一个行业的框架。</p>
<h4 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h4><p>框架基本上都是根据业务模型，或者设计模式等，把模型中稳定的部分进行封装，形成一个大的边界，但是具体内容仍留有余地。由于业务模型或者设计模式也是架构拆分的结果，因此框架同时也属于业务架构的一个具体实现。框架对业务模型中变化的部分，一般都会提供很容易的扩展方式，使得框架使用者可以根据自己业务的特殊性对框架进行扩展，而不需要全部从头开始编码。</p>
<h4 id="框架的特点"><a href="#框架的特点" class="headerlink" title="框架的特点"></a>框架的特点</h4><p>框架往往都是无法单独运行的。软件框架基本都是一个留有扩展余地，为其他代码所引用的代码或类库。<br>框架为方便本地定制，在本地进行改造，和自己的软件结合在一起。框架和服务的另一个区别：软件引用框架是本地引用的方式，而服务是用来远程调用的。<br>框架的背后总有一个模式存在，这个模式是来解决共同问题。    </p>
<h3 id="软件运维"><a href="#软件运维" class="headerlink" title="软件运维"></a>软件运维</h3><p>运维是软件真正的核心竞争力。</p>
<h4 id="软件运行生命周期"><a href="#软件运行生命周期" class="headerlink" title="软件运行生命周期"></a>软件运行生命周期</h4><p>软件的目的是为用户提供持续不断额访问，软件运行生命周期的核心是软件访问生命周期。<br>下图所示，软件生命周期分拆树，树的遍历顺序从左至右。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p4.png" alt="软件生命周期分拆树">     </p>
<h4 id="什么是软件运维"><a href="#什么是软件运维" class="headerlink" title="什么是软件运维"></a>什么是软件运维</h4><p>软件运行生命周期可以拆分成：软件运维生命周期和软件访问生命周期。其中软件访问生命周期是核心生命周期。运维生命周期是从软件开始部署开始，到软件结束服务为止。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p5.png" alt="软件生命周期分拆树">    </p>
<h4 id="运维的业务模型"><a href="#运维的业务模型" class="headerlink" title="运维的业务模型"></a>运维的业务模型</h4><p>运维的业务目标是保证用户的访问生命周期不受影响。     </p>
<h4 id="控制变化"><a href="#控制变化" class="headerlink" title="控制变化"></a>控制变化</h4><p>任何对软件的改变，都是风险，都需要运维的关注。<br>要做好变化的控制，首先要做的是：在软件周围设立隔离区，避免软件出现在不安全的地方。其中包括软件本身、硬件、网络和电力等。     </p>
<h6 id="如何隔离"><a href="#如何隔离" class="headerlink" title="如何隔离"></a>如何隔离</h6><p>拆分软件的运行环境，区分办公环境（开发）和生产环境（运行），生产环境是一套单独的设备环境。      </p>
<h6 id="控制变更"><a href="#控制变更" class="headerlink" title="控制变更"></a>控制变更</h6><ul>
<li>软件的变更    </li>
<li>硬件的变更</li>
<li>网络的变更</li>
<li>电力的变更</li>
</ul>
<h4 id="监控变更"><a href="#监控变更" class="headerlink" title="监控变更"></a>监控变更</h4><p>监控的目的实际上就是把系统内不同生命周期的当前运行状态，通过探测器传输出来，展示到可视或可感知的设备上，来供人查看。监控非常重要的指标是实时度。      </p>
<h4 id="预警变更"><a href="#预警变更" class="headerlink" title="预警变更"></a>预警变更</h4><p>预警内容分为两部分：    </p>
<ol>
<li>软件本身业务的预警，主要包括软件、硬件、网络和电力等设备。</li>
<li>软件所实现业务的预警。<blockquote>
<p>监控是生成预警的数据基础。对业务生命周期的理解则是生成预警的规则基础。<br>预警软件本身也是需要监控和预警的，也是预警的业务。</p>
</blockquote>
</li>
</ol>
<h4 id="主导变更"><a href="#主导变更" class="headerlink" title="主导变更"></a>主导变更</h4><p>在生成系统做变更，也需要有一个正向反馈环，这个正向反馈环核心环节就是监控和预警。   </p>
<h6 id="发布"><a href="#发布" class="headerlink" title="发布."></a>发布.</h6><p>一般第一次发布，就是该变更第一次在生产环境的应用，此时风险最大。因此要确保被影响的机器越少越好，把风险降到最低。首次发布时一般都选择可发布的最小单位，也就是一台机器。对于特别重要的软件，往往会在发布50%之后，经历一次业务高峰后再发布剩余的机器。因为即使该变更有问题，导致50%的机器在高峰期的压力下无法正常工作，还有剩下50%的机器能够支撑业务的运作。这意味着在建立集群的时候，必须要留有50%的冗余容量来做缓冲。</p>
<h3 id="软件访问生命周期"><a href="#软件访问生命周期" class="headerlink" title="软件访问生命周期"></a>软件访问生命周期</h3><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>集群就是组装有相同的软件，具备同样功能的一组计算机，组织在一起共同服务于客户的访问，它以横向扩展的方式提升软件访问能力。<br>应用集群后，所有用户不再只访问一台机器，变成了用户分散访问不同的机器，但还是访问同一个软件。因为集群内的机器功能都是一样的，相当于增加了访问通道，使得软件的访问容量得到了增长。<br>集群通过路由来指定用户对某一台计算机的访问。用户访问到达集群前端时做一个路由，把每个用户的请求按照预设的规则转发到集群中的某台机器，即可让用户的访问自动到达某台机器上的软件，转发预设的规则还需要考虑某台机器是否过忙，否则把用户的请求转发到过载的机器上反而影响用户的访问。<br>集群的路由主要考虑的因素是集群内机器的负载均衡问题，为了实现对集群内机器负载的感知，路由必须定时的检查集群内机器的健康和剩余访问容量。路由的引入使得用户并不知道自己访问的是一个集群，因为每次访问都只是访问一台机器，集群对用户是透明的。<br>集群出现后，用户的访问路径又做了一次架构拆分，在软件所部署的计算机之前增加了一个访问路由，这个路由负责把用户的请求按照转发规则转发给集群内的某台计算机。转发规则有很多种，比如按照访问的权重来路由，随机路由、散列路由等，各有各的优势和缺点。<br>集群虽好，但是要实现集群，对软件本身则有一个限制：要能够在不同的计算机之间保持用户的状态。比如用户本次访问的机器和上次不同，这个机器就不知道用户是谁，从而无法给用户服务，就要求用户再次登录。在这种情况下，用户感知到了集群的存在，集群就失去了意义。要做到集群对用户透明，软件本身还需要在用户的访问路径上做一个架构拆分，使得同一个集群的不同机器之间，能够共享用户的状态。只有做到这一点，才能够真正地让集群对用户透明。当然，还有一种路由转发规则是按照用户的来源固定给某台机器来服务，确保单个用户上次访问的目标计算机和当前要访问的目标计算机是同一台来避免这个问题。实现方式是按照访问来源地址对集群内机器数量做散列，这样某个来源地址所访问的机器就是固定的。   </p>
<h4 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h4><p>多数据中心可以看成是集群的集群，装有同一个软件的集群会同时部署在多个不同的数据中心，集群在不同的数据中心各复制了一份。<br>当一个数据中心出了问题，其他的数据中心可以接管，可以让软件保持持续运行，获得很长的运行生命周期，不会对用户的访问造成影响。<br>要做到用户在不同数据中心访问同一个软件，就必须在不同数据中心的前端放置一个路由，类似于前述的集群做法，为部署了同一个软件但位于不同数据中心的各个集群做路由。用户访问软件的路径又做了一次架构拆分，增加了数据中心的路由生命周期。<br>数据中心前置路由的路由策略和集群的路由策略有不同之处。集群的路由策略保障的是集群内机器访问的均衡，而数据中心前置路由的路由策略则是把数据中心所覆盖地区的用户访问归属到相应的数据中心。这就意味着在建数据中心时，要考虑的实际上是物理空间维度上用户的覆盖面，避免数据中心过小而用户过多，导致数据中心之间的负载不均衡。<br>同一个软件部署在多个数据中心的不同集群上，一般会重新定义一个名字，叫做池(Pool)，比如有两个数据中心shanghai-dc和beijing-dc，都分别有订单集群，它们的名字会是order-shanghai-dc和order-beijing-dc，但是它们都属于订单的集群，会有一个统一的名字，叫做订单池(Order Pool)，相当于一个集群池，方便和集群分开。多数据中心出现后，软件发布的目标不再是针对集群，而是针对池，集群是物理的，池可以认为是逻辑上的集群，多个数据中心里部署了同一个软件的计算机都属于同一个池。<br>多个数据中心的出现，对变更的发布也会造成影响。一个池会同时部署在多个数据中心，发布变更的时候不能把一个数据中心的集群全部关闭。比如上例中订单池在两个数据中心分别有一个集群，各100台机器。在软件发布到50%的时候，不能让某个数据中心的100台机器全部下线，这会让一个数据中心的订单集群变成完全不可用，这是不可接受的。发布50%的时候应该是让两个数据中心各发布50%。<br>当一个用户从一个数据中心迁移到另一个数据中心时，可以按照用户维度存储数据，也可以通过数据同步保证两个数据中心的数据一致。</p>
<h3 id="软件架构和大数据"><a href="#软件架构和大数据" class="headerlink" title="软件架构和大数据"></a>软件架构和大数据</h3><h3 id="软件架构和建筑架构"><a href="#软件架构和建筑架构" class="headerlink" title="软件架构和建筑架构"></a>软件架构和建筑架构</h3><h2 id="软件架构的应用"><a href="#软件架构的应用" class="headerlink" title="软件架构的应用"></a>软件架构的应用</h2><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><h3 id="交易系统"><a href="#交易系统" class="headerlink" title="交易系统"></a>交易系统</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/11/16/5-minutes-docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/16/5-minutes-docker/" class="post-title-link" itemprop="url">Docker容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-16 00:21:25" itemprop="dateCreated datePublished" datetime="2017-11-16T00:21:25+08:00">2017-11-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h1><h2 id="传统部署流程的问题"><a href="#传统部署流程的问题" class="headerlink" title="传统部署流程的问题"></a>传统部署流程的问题</h2><p>在早期的软件开发实践中，开发和运维团队的职责划分并不清晰。开发团队的成员在自己的本地环境上开发，通过持续集成环境构建出可部署的工件（Artifact），部署的工作由运维团队来完成。根据开发团队提供的文档，在生产环境上安装应用及其依赖的外部服务，比如数据库和消息中间件等。</p>
<p>这样的开发部署流程最大的问题在于，无法保证开发时和运行时环境的一致性。经常出现的问题是，应用在开发人员的开发环境上可以正常工作，到了生产环境中则会出现各种问题。有可能开发人员在本地环境上为应用添加了一个新的参数，但是忘了更新安装文档，导致运维团队安装的生产环境应用出现问题。</p>
<p>下图是传统的部署方式，可以看出，最大的问题在于手动维护安装文档，任何手动维护的文档从根本上来说都是不可信的，文档可能与代码失去同步。</p>
<p><img src="/2017/11/16/5-minutes-docker/Cgq2xl5zkHKAU5lwAABTrPBwwW8852.png"></p>
<p>开发和生产环境的这种不一致性，会随着应用的复杂性而加剧。从单体应用迁移到微服务架构，对应用部署的要求更高，需要部署的应用数量从一个变成多个，而且每个服务所使用的技术栈和依赖的外部服务都可能千差万别。如果以硬件虚拟化来实现，还需要为每个服务创建独立的操作系统镜像，这些镜像的管理、更新和维护都是一个巨大的挑战。</p>
<h2 id="容器化的优势"><a href="#容器化的优势" class="headerlink" title="容器化的优势"></a>容器化的优势</h2><p>容器化技术提供了一种更简洁的方式来描述可运行的应用，可运行对运维来说至关重要。以 Java 应用为例，开发人员在本地环境上进行开发和调试，通过持续集成构建出可部署的 JAR 文件。但对运维团队来说，这些 JAR 文件并不是可运行的，因为它们还缺少所依赖的运行时支持，最基本的运行时依赖是 JDK，Java 应用对依赖的 JDK 版本是有要求的，除此之外，Java 应用启动时还可能需要额外的参数，这些信息并不包含在 JAR 文件中。因此运维团队需要从开发团队中获取这些信息，开发团队通常使用文档来说明如何运行应用，而文档本身很容易与代码产生不一致。</p>
<p>使用容器化技术所创建的镜像包含了应用所依赖的全部内容。一个 Java 应用的镜像，除了包含应用本身的 JAR 文件之外，还包含所需的 JDK 和如何启动应用的信息。容器的镜像是自包含的，同时也是可运行的。运维团队所做的仅仅是从镜像中创建容器并运行。这就进一步明确开发和运维团队的职责，开发团队负责创建应用对应的镜像，而运维团队只负责管理基础设施和容器的运行。</p>
<p>如下图所示，在容器化的部署方式中，应用镜像是开发团队和运维团队的唯一交集。</p>
<p><img src="/2017/11/16/5-minutes-docker/CgpOIF5zkHKAM9yCAABEUV3eqZc348.png"></p>
<p>容器镜像的最大优势是不可变，不可变性在运维中的作用巨大，这一点和虚拟机镜像类似，但是容器镜像更加轻量级。在进行版本更新时，如果出现未预期的问题，只需要用上一个版本的镜像重新运行容器，就可以快速回退。当在生产环境中发现问题时，开发人员可以在本地环境上运行同样版本的镜像来重现问题。</p>
<p>容器化解决了不同环境之间的一致性问题，开发团队产出的应用镜像，经过测试团队的测试之后，被部署到生产环境中。开发、测试和生产环境使用的是同样的不可变镜像，这样的一致性对于应用的更新至关重要。</p>
<p>虽然容器对所运行的进程数量没有限制，但是一般容器只运行一个进程。为了运行应用，除了应用本身的容器之外，应用所需的其他服务也运行在各自的容器中，这就要求协调不同容器的运行。容器编排工具的作用就是解决这个问题，常见的容器编排工具包括 Kubernetes、Docker Swarm 和 Apache Mesos。</p>
<h1 id="Docker-的使用"><a href="#Docker-的使用" class="headerlink" title="Docker 的使用"></a>Docker 的使用</h1><p>在众多容器化技术中，Docker 是最流行的一个，采用客户端 — 服务器的架构。服务器端是 Docker 后台程序，负责构建、运行和分发容器；客户端则通过 REST API 与 Docker 后台程序交互。</p>
<p>Docker 中两个最重要的概念是镜像和容器，镜像是创建容器的只读模板，可以从 Docker 注册表中下载，也可以创建自定义镜像。Docker Hub 是默认的镜像注册表，包含了非常多可用的镜像，企业内部也可以搭建自己私有的注册表。镜像虽然是不可变的，但是可以在已有的镜像上进行定制，得到新的镜像，这也是通常创建镜像的方式。容器是镜像的可运行实例，从镜像中创建出来的容器，可以被启动、暂停、停止和删除。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Docker 的安装很简单。在本地开发环境中，Windows 和 MacOS 可以安装 Docker Desktop，对于 Docker Desktop 不支持的 Windows 版本，可以安装 Docker Toolbox；在 Linux 上则需要安装 Docker Engine。</p>
<p>安装完成之后，相关的操作可通过 docker 命令来执行。</p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>当使用 docker run 命令运行容器时需要指定镜像的名称。下面的代码是运行 Nginx 对应的镜像，nginx 是镜像的名称；镜像名称前面没有注册表的地址，默认从 Docker Hub 获取，镜像名称之后的 1.17 是镜像的标签，用来区分不同的版本；–name 参数用来指定容器的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nginx nginx:1.17</span><br></pre></td></tr></table></figure>



<p>docker run 运行的容器默认在前台运行，我们也可以使用 -d 参数让容器在后台运行。容器启动之后，可通过 docker ps 命令来查看运行容器的状态，容器运行之后，我们可以使用 docker exec 在容器中执行命令。下面的命令在名为 nginx的 容器中执行 hostname 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec nginx hostname</span><br></pre></td></tr></table></figure>

<p>上述命令在执行 hostname 之后就会退出。在开发中，可能需要在运行的容器上执行很多命令，这个时候可以运行一个交互式的 shell。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it nginx sh</span><br></pre></td></tr></table></figure>

<p>使用 docker start、docker pause、docker stop 和 docker rm 来启动、暂停、停止和删除容器。</p>
<p>Docker Desktop 提供了图形化界面来管理容器。</p>
<p>容器通常可以对外提供服务，为了在本地访问容器中的服务，我们需要把容器中开放的端口暴露到本地机器上。Nginx 容器暴露了 80 端口，可以使用 -p 参数来暴露端口。在下面的代码中，我们使用 -p 参数把容器的 80 端口暴露在本地机器上的 10080 端口，再使用 curl 来访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nginx -p 10080:80 nginx:1.17</span><br><span class="line">$ curl http://localhost:10080</span><br></pre></td></tr></table></figure>

<p>对于运行的容器，则可以通过 docker logs 命令来查看日志，如 docker logs nginx。</p>
<p>有些镜像在创建时提供了可以进行配置的环境变量。在运行容器时，可以使用 -e 参数来传递环境变量。下面的命令运行的是 MySQL 8 容器，并指定了 root 用户的密码和数据库名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=myrootpassword -e MYSQL_DATABASE=demo mysql:8</span><br></pre></td></tr></table></figure>



<p>运行容器的另外一个常见需求是在本地机器和容器中共享文件，我们可以使用 -v 参数来指定本机目录到容器目录的绑定关系。下面代码中的命令使用的是 OpenJDK 8 的镜像来编译当前目录下的 Java 源文件：</p>
<p> 使用 -v 参数把本机上的当前目录绑定到容器上的 &#x2F;tmp 路径上；<br> -w 参数设置容器中的工作目录；<br> –rm 参数的作用是在容器退出时自动删除该容器。</p>
<p>当该命令运行结束之后，可以在本机的当前目录下看到编译之后的 class 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v `pwd`:/tmp -w /tmp openjdk:8 javac Hello.java</span><br></pre></td></tr></table></figure>







<h2 id="创建-Docker-镜像"><a href="#创建-Docker-镜像" class="headerlink" title="创建 Docker 镜像"></a>创建 Docker 镜像</h2><p>在应用开发中，我们通常需要从已有的镜像中创建自定义的镜像，镜像的创建方式可通过 Dockerfile 文件来描述。以 Java 应用为例，我们需要以 OpenJDK 的镜像为基础，把 JAR 文件作为镜像的一部分，并设置正确的启动参数。</p>
<p>以 Spring Boot 应用为例，下面的 Dockerfile 文件被用来创建该应用的镜像。在 Dockerfile 中：</p>
<p> FROM 声明了基础的镜像名称；<br> ADD 用来添加应用的 JAR 文件到指定目录；<br> CMD 声明了容器启动时执行的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line">ADD target/*.jar /opt/app.jar</span><br><span class="line">CMD java -jar /opt/app.jar</span><br></pre></td></tr></table></figure>



<p>完成之后我们再通过 docker build 命令构建镜像，-t 参数为创建的镜像指定名称和标签，在构建时需要提供 Dockerfile 所在的目录，命令中的“.”表示当前目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myapp:1.0 .</span><br></pre></td></tr></table></figure>



<p>镜像创建完成之后，我们通过 docker run 命令来运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myapp:1.0</span><br></pre></td></tr></table></figure>



<h1 id="Docker-Compose-的使用"><a href="#Docker-Compose-的使用" class="headerlink" title="Docker Compose 的使用"></a>Docker Compose 的使用</h1><p>Docker Compose 是 Docker 提供的容器管理工具，相对于其他编排工具，该工具使用简单，适用于本地开发，可以同时启动多个容器，并定义容器之间的关联关系。</p>
<p>以一个使用 Spring Data JPA 的 Spring Boot 应用为例，该应用在运行时依赖数据库服务，而且应用需要通过网络访问该数据库服务。我们可以用 Docker Compose 来同时启动两个容器，并定义其中的关联。Docker Compose 使用的是 YAML 文件来声明容器。</p>
<p>下面代码中的 docker-compose.yml 文件是用来启动应用和 MySQL 服务器的。在 services 中定义了两个服务：db 服务使用的是 MySQL 8 镜像，同时声明了所需的环境变量；app 服务没有使用已有的镜像，而是要求通过 docker build 命令来构建出镜像。app 服务也有同样的环境变量，其中 MYSQL_HOST 的值是 db，是 MySQL 服务的名称。这是因为 Docker Compose 会用服务名称来作为容器的主机名，当 2 个容器出现在同一个网络中，这时 app 服务就可以访问到 MySQL 服务器了。depends_on 声明了 app 服务对 db 服务的依赖关系，这样可以保证正确的容器启动顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services: </span><br><span class="line">  db:</span><br><span class="line">    image: mysql:8</span><br><span class="line">    environment: </span><br><span class="line">      MYSQL_ROOT_PASSWORD: myrootpassword</span><br><span class="line">      MYSQL_USER: mysqluser</span><br><span class="line">      MYSQL_PASSWORD: mysqlpassword</span><br><span class="line">      MYSQL_DATABASE: demo  </span><br><span class="line">  app:</span><br><span class="line">    build: .  </span><br><span class="line">    environment: </span><br><span class="line">      MYSQL_HOST: db</span><br><span class="line">      MYSQL_USER: mysqluser</span><br><span class="line">      MYSQL_PASSWORD: mysqlpassword</span><br><span class="line">      MYSQL_DATABASE: demo</span><br><span class="line">    depends_on: </span><br><span class="line">      - db</span><br></pre></td></tr></table></figure>



<p>在 Spring Boot 应用的 application.properties 文件中，我们直接引用环境变量来配置数据库连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://$&#123;MYSQL_HOST&#125;:3306/$&#123;MYSQL_DATABASE&#125;</span><br><span class="line">spring.datasource.username=$&#123;MYSQL_USER&#125;</span><br><span class="line">spring.datasource.password=$&#123;MYSQL_PASSWORD&#125;</span><br></pre></td></tr></table></figure>



<p>使用 docker-compose up 命令可以运行 docker-compose.ym 文件描述的全部容器。</p>
<p>在上面代码的 docker-compose.yml 文件中，MySQL 相关的环境变量在两个服务的定义中重复出现。为了避免代码重复，我们可以把相同的环境变量放在一个文件中，如下面代码所示的 db.env 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_USER=mysqluser</span><br><span class="line">MYSQL_PASSWORD=mysqlpassword</span><br><span class="line">MYSQL_DATABASE=demo</span><br></pre></td></tr></table></figure>



<p>接着我们可以在 docker-compose.yml 文件中使用 env_file 来引用该文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services: </span><br><span class="line">  db:</span><br><span class="line">    image: mysql:8</span><br><span class="line">    environment: </span><br><span class="line">      MYSQL_ROOT_PASSWORD: myrootpassword</span><br><span class="line">    env_file: </span><br><span class="line">      - db.env</span><br><span class="line">  app:</span><br><span class="line">    build: .  </span><br><span class="line">    environment: </span><br><span class="line">      MYSQL_HOST: db</span><br><span class="line">    env_file: </span><br><span class="line">      - db.env</span><br><span class="line">    depends_on: </span><br><span class="line">      - db</span><br></pre></td></tr></table></figure>



<p>Docker 和 Docker Compose 是本专栏中会用到的重要工具。在此我们对这两个工具做了简要介绍，这对于本课时中示例应用的开发已经足够了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/29/CSS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/29/CSS3/" class="post-title-link" itemprop="url">CSS3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-29 20:37:19" itemprop="dateCreated datePublished" datetime="2017-10-29T20:37:19+08:00">2017-10-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><p><code>border-radius</code></p>
<p>每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的。</p>
<h4 id="盒阴影"><a href="#盒阴影" class="headerlink" title="盒阴影"></a>盒阴影</h4><p><code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>
<p>boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。  </p>
<ul>
<li>h-shadow	必需的。水平阴影的位置。允许负值   </li>
<li>v-shadow	必需的。垂直阴影的位置。允许负值</li>
<li>blur	可选。模糊距离</li>
<li>spread	可选。阴影的大小</li>
<li>color	可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表</li>
<li>inset	可选。从外层的阴影（开始时）改变阴影内侧阴影</li>
</ul>
<h4 id="边框图像"><a href="#边框图像" class="headerlink" title="边框图像"></a>边框图像</h4><p><code>border-image: source slice width outset repeat;</code></p>
<ul>
<li>border-image-source	用于指定要用于绘制边框的图像的位置</li>
<li>border-image-slice	图像边界向内偏移</li>
<li>border-image-width	图像边界的宽度</li>
<li>border-image-outset	用于指定在边框外部绘制 border-image-area 的量</li>
<li>border-image-repeat	这个例子演示了如何创建一个border-image 属性的按钮。</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h5 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h5><p>不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background-image: url(img_flwr.gif), url(paper.gif);</span><br><span class="line">	background-position: right bottom, left top;</span><br><span class="line">	background-repeat: no-repeat, repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以给不同的图片设置多个不同的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><p>background-size可以指定图像的大小。CSS3以前，背景图像大小由图像的实际大小决定。<br>CSS3中可以指定背景图片，重新在不同的环境中指定背景图片的大小。指定的大小是相对父元素的宽度和高度的百分比大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-size:80px 60px;</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p>指定背景图片的位置区域。content-box、padding-box、border-box区域内可以放置背景图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">	background-size:100% 100%;</span><br><span class="line">	background-origin:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="渐变-gradient"><a href="#渐变-gradient" class="headerlink" title="渐变 gradient"></a>渐变 gradient</h3><p>gradient可以在两个或多个指定颜色之间显示平稳的过渡。<br>CSS3中定义了两种类型的渐变</p>
<ul>
<li>线性渐变 Line Gradient  向下&#x2F;向上&#x2F;向左&#x2F;向右&#x2F;对角方向</li>
<li>径向渐变 Radial Gradient 由它们的中心定义</li>
</ul>
<h5 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h5><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。</p>
<p><code>background: linear-gradient(direction, color-stop1, color-stop2, ...); </code></p>
<p>线性渐变 - 从上到下 （默认情况）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  	background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  	background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  	background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  	background: linear-gradient(red, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线性渐变 - 从左到右</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(to right, red , blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性渐变 - 对角</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用角度</p>
<p><code>background: linear-gradient(angle, color-stop1, color-stop2);</code></p>
<p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。</p>
<p><img src="/2017/10/29/CSS3/angleGradient.jpg" alt="角度"></p>
<p>但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。换算公式 90 - x &#x3D; y 其中 x 为标准角度，y为非标准角度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(180deg, red, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多个颜色结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(red, green, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用透明度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */</span><br><span class="line">  background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/</span><br><span class="line">  background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/</span><br><span class="line">  background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复的线性渐变<br>repeating-linear-gradient() 函数用于重复线性渐变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -o-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* Firefox 3.6 - 15 */</span><br><span class="line">  background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* 标准的语法 */</span><br><span class="line">  background: repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h5><p>径向渐变由它的中心定义。</p>
<p>为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
<p><code>background: radial-gradient(center, shape size, start-color, ..., last-color); </code></p>
<p>径向渐变 - 颜色结点均匀分布（默认情况下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(red, green, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>径向渐变 - 颜色结点不均匀分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置形状</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h6 id="CSS3-font-face-规则"><a href="#CSS3-font-face-规则" class="headerlink" title="CSS3 @font-face 规则"></a>CSS3 @font-face 规则</h6><p>在CSS3之前，web设计师必须使用已在用户计算机上安装好的字体，不能够使用离线字体，不过通过CSS3，web设计师可以使用他们喜欢的任意字体。</p>
<p>当您找到或购买到希望使用的字体时，可将该字体文件存放到web服务器上，它会在需要时被自动下载到用户的计算机上。</p>
<p>您”自己的”的字体是在 CSS3 @font-face 规则中定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">   font-family: myFirstFont;</span><br><span class="line">   src: url(sansation_light.woff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">   font-family:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h3><h5 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h5><p>根据左（x轴）和顶部（y轴）位置给定的参数，从当前元素位置移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: translate(50px, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h5><p>在给定的读书顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: rotate(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h5><p>该元素增加或减少的大小，取决于宽度（x轴）和高度（y轴）的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: scale(2,4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="skew"><a href="#skew" class="headerlink" title="skew()"></a>skew()</h5><p>包含两个参数，分别表示X轴和Y轴倾斜角度，如果第二个参数为空，则默认为0，参数为负表示向相反的方向倾斜。</p>
<ul>
<li>skewX() 表示只在X轴（水平方向）倾斜</li>
<li>skewY() 表示只在Y轴（垂直方向）倾斜</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: skew(10deg, 30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h5><p>matrix()方法和2D变换方法合并成一个。<br>matrix()方法有6个参数，包含旋转、缩放、移动（平移）和倾斜功能。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: matrix(0.3, 0.5, -0.5, 0.3, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/" class="post-title-link" itemprop="url">高效操作DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-22 20:58:31" itemprop="dateCreated datePublished" datetime="2017-10-22T20:58:31+08:00">2017-10-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h1><p>DOM（Document Object Model） 文档对象模型。</p>
<p>是JavaScript操作HTML的接口。</p>
<p>DOM V3标准主要由3个部分组成</p>
<ul>
<li>DOM节点</li>
<li>DOM事件</li>
<li>选择区域</li>
</ul>
<p>DOM节点概念区分：</p>
<ul>
<li>标签是HTML的基本单位，比如div、li、p、input等</li>
<li>节点是DOM数的基本单位，有多种类型，比如注释节点、文本节点</li>
<li>元素是节点中的一种，与HTML标签相应，比如p标签会对应p元素</li>
</ul>
<h1 id="DOM操作耗时"><a href="#DOM操作耗时" class="headerlink" title="DOM操作耗时"></a>DOM操作耗时</h1><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>浏览器包括渲染引擎（浏览器内核）和JavaScript引擎，它们都是单线程，单线程的优势是开发方便，避免了多线程下的死锁、竞争等问题；劣势是失去了并发能力。</p>
<p>浏览器为了避免两个引擎同时修改页面而造成渲染结果不一致的情况，这两个引擎具有互斥性，在某一个时刻只有一个引擎在运行，另一个引擎被阻塞。</p>
<p>操作系统在进行线程切换时需要保存上一个线程执行时的状态信息，并读取下一个线程的状态信息，俗称上下文切换，这个操作相对而言是比较耗时的。</p>
<p>从JavaScript引擎切换到渲染引擎执行相应操作后，再切换回JavaScript引擎继续执行，会带来性能损耗。</p>
<h2 id="重新渲染"><a href="#重新渲染" class="headerlink" title="重新渲染"></a>重新渲染</h2><p>渲染过程中最耗时的两个步骤为重排（Reflow）与重绘（Repaint）。</p>
<p>渲染页面是将HTML和CSS分别解析成DOM树和CSSOM树，然后合并进行排布，再绘制成我们可见的页面，如果在操作DOM时涉及到元素、样式的修改，就会引起渲染引擎重新计算样式生成CSSOM树，同时还有可能触发对元素的重新排布（简称“重排”）和重新绘制（简称“重绘”）</p>
<p>影响到其他元素排布的操作就会引起重排，继而引发重绘。</p>
<p>比如：</p>
<ul>
<li>修改元素边距、大小</li>
<li>添加删除元素</li>
<li>改变窗口大小</li>
</ul>
<p>与之相反的操作只会引起重绘</p>
<p>比如：</p>
<ul>
<li>设置背景图片</li>
<li>修改字体颜色</li>
<li>改变visibility属性值</li>
</ul>
<h2 id="如何高效操作DOM"><a href="#如何高效操作DOM" class="headerlink" title="如何高效操作DOM"></a>如何高效操作DOM</h2><h3 id="在循环外操作元素"><a href="#在循环外操作元素" class="headerlink" title="在循环外操作元素"></a>在循环外操作元素</h3><p>不用在循环内操作元素，尽量在循环外操作元素。</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224635494.png" alt="image-20230319224635494"></p>
<h3 id="批量操作元素"><a href="#批量操作元素" class="headerlink" title="批量操作元素"></a>批量操作元素</h3><p>比如创建10000个元素，在节点中直接添加耗时会非常多。如果拼接到字符串中，则相对较少。</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224706991.png" alt="image-20230319224706991"></p>
<h3 id="缓存元素集合"><a href="#缓存元素集合" class="headerlink" title="缓存元素集合"></a>缓存元素集合</h3><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224956526.png" alt="image-20230319224956526"></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319225019237.png" alt="image-20230319225019237"></p>
<h2 id="其他减少耗时的方法"><a href="#其他减少耗时的方法" class="headerlink" title="其他减少耗时的方法"></a>其他减少耗时的方法</h2><ul>
<li>尽量不用使用复杂的匹配规则和复杂的样式。从而减少渲染引擎计算样式规则生成CSSOM树的时间</li>
<li>尽量减少重排和重绘影响的区域</li>
<li>使用CSS特效来实现动画效果</li>
</ul>
<h1 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>搜索输入框，绑定input元素的键盘事件，然后在监听函数中发送AJAX请求。直接在事件方法里调用接口，这样会触发性能问题，每输入一个字符，都会在事件里响应，调用一次接口，而在实际中，用户输入完整字符后调用接口才是有效的。</p>
<p>针对这种情况，需要一个“防抖”功能，为函数的执行设置一个合理的时间间隔，避免事件在时间间隔内频繁触发，同时又保证用户输入后能即时看到搜索结果。</p>
<p><strong>setTimeout函数来让函数延迟执行</strong></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319230223440.png" alt="image-20230319230223440"></p>
<p>这个函数可以抽取成公共函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共防抖</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">func, wait=<span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> args</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">        args = arg</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Promise形式返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">res</span>(result)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    <span class="title function_">rej</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许取消</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许立即执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flush</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>()</span><br><span class="line">        <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.<span class="property">cancel</span> = cancel</span><br><span class="line">    debounced.<span class="property">flush</span> = flush</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>场景：一个浏览页面，左侧目录，右侧文章，浏览文章时，左侧目录根据右侧浏览滚动位置高亮显示。</p>
<p>实现：计算出每级目录对应文章内容的高度，根据距离来判断需要高亮的章节。在滚动事件里实时根据滚动距离去判断，但这会影响性能，一滚动就会触发计算。</p>
<p><strong>“节流“功能</strong></p>
<p>设置在指定一段时间内只调用一次函数，从而降低函数调用频率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">func, wait=<span class="number">0</span>, execFirstCall</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> args</span><br><span class="line">    <span class="keyword">let</span> firstCallTimestamp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!firstCallTimestamp) </span><br><span class="line">            firstCallTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">        <span class="keyword">if</span> (!execFirstCall || !args) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set args&#x27;</span>, arg)</span><br><span class="line">            args = arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Promise形式返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title function_">async</span>(res, rej) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - firstCallTimestamp &gt;= wait) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   	<span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">res</span>(result)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    <span class="title function_">rej</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="title function_">cancel</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">                        <span class="title function_">res</span>(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                        <span class="title function_">rej</span>(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="title function_">cancel</span>()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, firstCallTimestamp + wait - <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许取消</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        args = <span class="literal">null</span></span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">        firstCallTimestamp = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许立即执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flush</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>()</span><br><span class="line">        <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    throttled.<span class="property">cancel</span> = cancel</span><br><span class="line">    throttled.<span class="property">flush</span> = flush</span><br><span class="line">    <span class="keyword">return</span> throttled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319232609530.png" alt="image-20230319232609530"></p>
<p>对上面代码中的”编辑“和”删除“进行事件监听。</p>
<p>如果数据量一旦增大，事件绑定占用的内存以及执行时间将会成线性增加，其实这些事件监听函数逻辑一致，只是参数不同而已，我们可以以事件代理或事件委托来进行优化。</p>
<p><strong>DOM事件触发流程</strong></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319232907645.png" alt="image-20230319232907645"></p>
<p><strong>代理事件</strong></p>
<p>对list中的事件同一处理，通过参数来识别不同的item</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319233155747.png" alt="image-20230319233155747"></p>
<h2 id="关于DOM事件标准"><a href="#关于DOM事件标准" class="headerlink" title="关于DOM事件标准"></a>关于DOM事件标准</h2><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319233256667.png" alt="image-20230319233256667"></p>
<p>上面三种方式的区别</p>
<p>方式1和方式2会覆盖前面的事件</p>
<p>推荐使用方式3，同一事件的监听函数互补影响，而且可以独立取消，调用顺序和监听顺序一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/" class="post-title-link" itemprop="url">HTML中易忽略的标签</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-19 20:02:26" itemprop="dateCreated datePublished" datetime="2017-10-19T20:02:26+08:00">2017-10-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h1><h2 id="自动刷新-x2F-跳转"><a href="#自动刷新-x2F-跳转" class="headerlink" title="自动刷新&#x2F;跳转"></a>自动刷新&#x2F;跳转</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5;URL=page2.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设要实现PPT自动播放的功能，只需在每个页面的meta标签内设置好下一个页面地址即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;60&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>比如每隔一分钟就需要刷新页面的大屏幕监控，也可以通过meta标签来实现，只需去掉后面的URL。</p>
<blockquote>
<p>使用这种方式，刷新和跳转是不可取消的，对刷新时间间隔或者需要手动取消的，推荐使用JavaScript定时器来实现。</p>
<p>如果只是想实现页面的定时刷新或跳转（比如某些页面缺乏访问权限，在x秒后跳回首页这样的场景），建议使用meta标签</p>
</blockquote>
<h1 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h1><h2 id="Hack手段：消息提醒"><a href="#Hack手段：消息提醒" class="headerlink" title="Hack手段：消息提醒"></a>Hack手段：消息提醒</h2><p>B&#x2F;S架构在处理某些场景，比如即时通信时，会变得比较麻烦，因为前后端通信深度依赖HTTP协议，而HTTP协议是采用”请求-响应“模式。一种低效的解决方案是客户端通过轮询机制获取最新消息，（HTML5下可以使用WebSocket协议）</p>
<p>HTML5标准发布之前，浏览器没有开放图标闪烁、弹出系统消息之类的接口，只能借助一些Hack手段，比如修改title标签来达到类似的效果。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msgNum = <span class="number">1</span> <span class="comment">//条数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">const</span> inerval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    count = (count + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (msgNum === <span class="number">0</span>) &#123;</span><br><span class="line">        doucument.<span class="property">title</span> += <span class="string">&#x27;聊天页面&#x27;</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> refix = count % <span class="number">2</span> ? <span class="string">`新消息(<span class="subst">$&#123;msgNum&#125;</span>)`</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">    doucument.<span class="property">title</span> = <span class="string">`<span class="subst">$&#123;prefix&#125;</span>聊天页面`</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<p>HTML5中可以使用Web notifications API弹出系统消息。</p>
<p>动态修改title标签，还可以将一些关键信息显示在标签上，（比如下载时的进度、当前操作步骤等）</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>性能问题的两方面原因：渲染速度慢、请求时间长。</p>
<p>合理地利用标签，可以在一定程度上提升渲染速度以及减少请求时间。</p>
<h1 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h1><h2 id="调整加载顺序提升渲染速度"><a href="#调整加载顺序提升渲染速度" class="headerlink" title="调整加载顺序提升渲染速度"></a>调整加载顺序提升渲染速度</h2><p>渲染引擎在解析HTML时，若遇到script标签引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至JavaScript引擎来执行对应代码，代码执行完成后切换至渲染引擎继续渲染页面。</p>
<h2 id="script标签的3个属性"><a href="#script标签的3个属性" class="headerlink" title="script标签的3个属性"></a>script标签的3个属性</h2><ul>
<li><p>async属性</p>
<p>立即请求文件，但不阻塞渲染属性，文件加载完毕后阻塞渲染引擎并立即执行文件内容。</p>
</li>
<li><p>defer属性</p>
<p>立即请求文件，但不阻塞渲染属性，等到解析完HTML之后再执行文件内容。</p>
</li>
<li><p>HTML5标准type属性</p>
<p>对应的值为module。</p>
<p>让浏览器按照ES6标准将文件当作模块进行解析，默认阻塞效果同defer，也可以配合async在请求完成后立即执行。</p>
</li>
</ul>
<p><img src="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/image-20230319203320817.png" alt="image-20230319203320817"></p>
<p>当渲染引擎解析HTML遇到script标签引入文件时，会立即渲染一次。</p>
<p>构建工具会把编译好的引用JavaScript代码的script标签放入到body标签底部。当渲染引擎执行到body底部时会先将已解析的内容渲染出来，然后再去请求响应的JavaScript文件。</p>
<p>如果时内联脚本（不通过src引用外部脚本文件），渲染引擎不好渲染。</p>
<h1 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h1><h2 id="通过预处理提升渲染速度"><a href="#通过预处理提升渲染速度" class="headerlink" title="通过预处理提升渲染速度"></a>通过预处理提升渲染速度</h2><ul>
<li><p>dns-prefetch</p>
<p>当link标签的rel属性值为”dns-prefetch“时，浏览器会对某个域名预先进行DNS解析并缓存。当浏览器再访问同一域名的资源时，可以减少通过域名查询ip的过程，从而提升速度。</p>
</li>
<li><p>preconnect</p>
<p>让浏览器在一个HTTP请求正式发给服务器前预先执行一些操作，包括DNS解析、TLS协商、TCP握手，通过消除往返延迟来为用户节省时间。</p>
</li>
<li><p>prefetch&#x2F;preload</p>
<p>两个值都是让浏览器预先下载并缓存某个资源，但不同的是：prefetch可能会在浏览器忙时被忽略，而preload则是一定会被预先下载</p>
</li>
<li><p>prerender</p>
<p>浏览器不仅会加载资源，还会解析执行页面，进行预渲染。</p>
<p><img src="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/image-20230319204750649.png" alt="image-20230319204750649"></p>
</li>
</ul>
<h1 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h1><h2 id="meta标签：提取关键信息"><a href="#meta标签：提取关键信息" class="headerlink" title="meta标签：提取关键信息"></a>meta标签：提取关键信息</h2><p>meta标签专门为搜索引擎设置一些描述信息，方便用户预览到搜索结果</p>
<p>在实际工作中，推荐使用一些关键字工具来挑选，比如Google trends、站长工具</p>
<h2 id="link标签：减少重复"><a href="#link标签：减少重复" class="headerlink" title="link标签：减少重复"></a>link标签：减少重复</h2><p>对于同一个页面会有多个网址，又或者存在某些重定向页面，比如：</p>
<p><a target="_blank" rel="noopener" href="https://xx.com/a.html">https://xx.com/a.html</a></p>
<p><a target="_blank" rel="noopener" href="https://xx.com/detail?id=a">https://xx.com/detail?id=a</a></p>
<p>可以使用link标签，避免搜索引擎抓取相同页面的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://xx.com/a.html&quot; rel=&quot;canonical&quot; &gt;</span><br></pre></td></tr></table></figure>

<p>合并网址的方式：比如使用站点地图，或者在HTTP请求响应头部添加rel&#x3D;”canonical”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fhclk"
      src="/images/avatar1.png">
  <p class="site-author-name" itemprop="name">fhclk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fhclk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fhclk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fhclk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
</body>
</html>
