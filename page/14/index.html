<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fhclk.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="拾荒者">
<meta property="og:url" content="http://fhclk.github.io/page/14/index.html">
<meta property="og:site_name" content="拾荒者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fhclk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fhclk.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>拾荒者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拾荒者</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">昨夜西风凋碧树，独上高楼，望尽天涯路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/03/19/CSS%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/19/CSS%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">CSS布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-19 23:38:59" itemprop="dateCreated datePublished" datetime="2018-03-19T23:38:59+08:00">2018-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h1><p>最常用的一种布局</p>
<p>实现效果就是将一个元素作为布局容器，通常设置一个较小的（最大）宽度来保证不同像素宽度屏幕下显示一致。</p>
<p>优势：</p>
<p>基本可以适配超过布局容器宽度的各种显示屏幕。</p>
<p>缺点：</p>
<p>过渡的冗余设计必然会带来浪费，屏幕宽度可以显示更多的内容，但是页面两侧却出现了大量的空白区域。</p>
<h1 id="2列布局"><a href="#2列布局" class="headerlink" title="2列布局"></a>2列布局</h1><p>将页面分成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满。</p>
<p>宽度较小的列父元素为次要布局容器。</p>
<p>宽度较大的列父元素为主要布局容器。</p>
<h1 id="3列布局"><a href="#3列布局" class="headerlink" title="3列布局"></a>3列布局</h1><p>按照左中右的顺序进行排列，通常中间列最宽，左右两列次之。</p>
<h1 id="布局实现"><a href="#布局实现" class="headerlink" title="布局实现"></a>布局实现</h1><p>单列布局通过将设置布局容器（最大）宽度以及左右边距为auto即可实现。</p>
<p>2列和3列布局方式。</p>
<ol>
<li>为了保证主要布局容器优先级，应将主要布局容器写在次要布局容器之前。</li>
<li>将布局容器进行水平排列。</li>
<li>设置宽度，即次要容器宽度固定，主要容器撑满。</li>
<li>消除布局方式的副作用，如浮动造成的高度塌陷。</li>
<li>为了在窄屏下也能正常显示，可以通过媒体查询进行优化。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/03/05/wx-applet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/05/wx-applet/" class="post-title-link" itemprop="url">微信.小程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-05 08:17:00" itemprop="dateCreated datePublished" datetime="2018-03-05T08:17:00+08:00">2018-03-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p>前往<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">小程序注册</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a> 注册小程序，一个邮箱账号对应一个小程序。<br>登录 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">微信公众平台</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com</a> ，在菜单 “设置”-“开发设置” 获取小程序的 AppID。</p>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=19020120">下载地址</a></p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/">官网开发文档</a></p>
<h4 id="设置服务器域名"><a href="#设置服务器域名" class="headerlink" title="设置服务器域名"></a>设置服务器域名</h4><p>小程序要与后端交互，需要登录“微信工作平台|小程序”，在“开发”-“开发设置”-“服务器域名”添加域名，并且服务器要支持HTTPS协议。<br>如果在开发过程中使用了web-view组件，需要在“开发设置”中的“业务域名”中添加域名，并且只有企业号对应的小程序才有此项功能，个人账户不能进行此项设置。<br><img src="/2018/03/05/wx-applet/wx-applet/domain.png" alt="域名设置">   </p>
<h3 id="成员管理"><a href="#成员管理" class="headerlink" title="成员管理"></a>成员管理</h3><p>在“管理”-“成员管理”里可以添加项目成员和体验成员，上传代码后在“版本管理”-“开发版本”中设置体验版本，已经添加的体验成员就可以扫描二维码体验小程序。    </p>
<h3 id="发布小程序"><a href="#发布小程序" class="headerlink" title="发布小程序"></a>发布小程序</h3><p>在小程序功能测试通过后，上传代码，在“开发版本”中提交审核，审核通过后在“审核版本”中发布到线上。<br><img src="/2018/03/05/wx-applet/wx-applet/publish.png" alt="发布小程序">   </p>
<p>发布成功后在微信里删除开发版本和预览版本，删除后台微信进程，重新打开微信，在小程序中搜索已发布的小程序，验证是否发布成功。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/" class="post-title-link" itemprop="url">读《聊聊架构》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-22 17:36:14" itemprop="dateCreated datePublished" datetime="2018-01-22T17:36:14+08:00">2018-01-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="认识架构"><a href="#认识架构" class="headerlink" title="认识架构"></a>认识架构</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="为什么会产生架构"><a href="#为什么会产生架构" class="headerlink" title="为什么会产生架构"></a>为什么会产生架构</h3><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="什么是抽象"><a href="#什么是抽象" class="headerlink" title="什么是抽象"></a>什么是抽象</h3><h3 id="识别问题"><a href="#识别问题" class="headerlink" title="识别问题"></a>识别问题</h3><p>遇到问题时，要识别出问题的主题，划分出问题的边界约束。<br>当遇到问题时，如果发现自己正在致力于把自己的工作完成，就要马上警惕起来，因为这样下去会演变成没有主人翁精神的工作态度。在面对概念的时候，也会不求甚解，最终导致无法真正的理解概念。作为软件工程师或架构师，我们大部分时候是要去解决别人的问题（用户的问题），“别人”是谁，是值得好好考虑的。</p>
<blockquote>
<p>发现问题永远比解决问题更加重要</p>
</blockquote>
<p>问题的主题是用户</p>
<h3 id="切分的原则"><a href="#切分的原则" class="headerlink" title="切分的原则"></a>切分的原则</h3><p>确定问题主题后，在解决问题的过程中，产生新的问题，需要做调整，而要采取新的行动解决问题，解决的方式就是架构拆分</p>
<h4 id="切分原则"><a href="#切分原则" class="headerlink" title="切分原则"></a>切分原则</h4><ol>
<li>被切分的生命周期，如果必须要生命周期的主题在连续时间内持续执行，而且不能够被打断并更换生命周期主体的话，就不能切分出去。这类生命周期是切分的最小粒度，受限于当前的技术水平无法进一步切分。（比如十月怀胎，不能10人怀胎1人1月）</li>
<li>每个生命周期的负责人，对所负责生命周期的权利和义务必须是对等的。</li>
<li>切分出来的生命周期，不应该超出一个自然人的负载。根据没人能力实际情况实际情况进行调整。切分出来的只能是非核心生命周期，这些生命周期必须是完整的，内聚的。</li>
<li>切分是内部活动，内部切分对整个系统的外部都是透明的</li>
</ol>
<h4 id="树和分层"><a href="#树和分层" class="headerlink" title="树和分层"></a>树和分层</h4><p>所有的架构拆分都应该形成树的结构，并且层次越少越好。其中节点的权责对等，如果出现不对等的情况要及时调整，保持效率。</p>
<h4 id="切分和建模"><a href="#切分和建模" class="headerlink" title="切分和建模"></a>切分和建模</h4><p>架构切分的过程就是建模的过程。随着业务和规模的增加，就要进行拆分。拆分就需要识别核心生命周期和非核心生命周期，把非核心生命周期切分出来。切分出来的非核心生命周期形成新的模型，核心生命周期模型把所有的模型通过树组织起来，形成新的模型</p>
<p>总结. </p>
<blockquote><p>1.架构切分的导火索是人的负载太重，也就是时间不够。<br>2.架构的切分实际就是对利益相关人的利益进行切分和合并，使得每个利益相关人的权责是对等的，每个利益相关人可以为自己的利益负责。<br>3.架构切分的最终结果都会体现在组织架构上，只有这样才能够让架构落地进行。<br>4.架构切分的结果一定是一棵树状，这也是为什么会产生分层。层数越多沟通越多，效率越低，分层要越少越好。尽可能变成一棵平衡树，才能让整个系统的效率最大化。</p>
</blockquote>

<h3 id="架构与流程"><a href="#架构与流程" class="headerlink" title="架构与流程"></a>架构与流程</h3><h3 id="什么是架构师"><a href="#什么是架构师" class="headerlink" title="什么是架构师"></a>什么是架构师</h3><p>架构师需要了解清楚业务，挖掘出核心生命周期，并确定核心生命周期的主体（架构师要发现问题主体，并确定核心问题）。在确定业务核心生命周期及核心生命周期主体之后，需要对核心生命周期进行分析，剥离非核心生命周期，根据当前人员状况，合理分配非核心生命周期的权责。<br>架构师要具备调动资源的能力。架构包括设计和执行层面。架构师需要有调动资源执行项目的权力，同时也有识别项目核心生命周期，思考核心生命周期主体，合理分配权力，保证效率。</p>
<h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h3 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h3><h3 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h3><p>软件的整个生命周期会发生切分，从而形成两个子生命周期：软件开发生命周期和软件运行生命周期。<br>软件运行生命周期才是核心生命周期，因为软件运行生命周期的主体和大的生命周期一致。<br>围绕软件的生命周期，可以切分出很多非核心生命周期：    </p>
<ol>
<li>软件开发生命周期，其中又可以切分出需求生命周期、代码开发生命周期、测试生命周期。</li>
<li>软件的运行生命周期。其中包含：<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;a.软件的访问生命周期。<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;b.软件的功能生命周期。<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;c.软件的监控生命周期。</li>
</ol>
<h4 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h4><blockquote>
<p>从软件的运行生命周期角度来说，一个可运行的独立部署单元才算是一个软件。</p>
</blockquote>
<h5 id="软件开发的增长"><a href="#软件开发的增长" class="headerlink" title="软件开发的增长"></a>软件开发的增长</h5><p>一个软件项目需要多人分工合作，就需要架构切分，软件开发的核心生命周期是编写代码，在这个核心生命周期下，软件开发生命周期可被切分成不同的非核心生命周期，每个非核心生命周期围绕核心生命周期组成树状架构，在时间和空间上并行开展工作，提升产量和速度。<br>不同的拆分方式，形成了不同的软件开发模式</p>
<h5 id="软件开发的迭代"><a href="#软件开发的迭代" class="headerlink" title="软件开发的迭代"></a>软件开发的迭代</h5><h4 id="软件开发的运行生命周期"><a href="#软件开发的运行生命周期" class="headerlink" title="软件开发的运行生命周期"></a>软件开发的运行生命周期</h4><p>软件功能的使用情况，会形成功能的访问生命周期，这个生命周期和业务的子生命周期相关。<br>软件启动后，运维要对系统进行监控，如zabbix。   </p>
<h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>软件架构就是通过对软件生命周期的拆分，在符合业务架构的前提下，以达到软件本身访问增长目的的方式。这个增长需要软件开发的增长，也需要软件运行的增长，由此达到所支撑业务的增长。<br>软件架构离不开软件开发团队的组织架构，这个组织架构是软件开发生命周期和软件运行生命周期的执行者。架构的核心生命周期就是架构的执行。    </p>
<h3 id="什么是软件架构师"><a href="#什么是软件架构师" class="headerlink" title="什么是软件架构师"></a>什么是软件架构师</h3><blockquote>
<p> 技术人员如果要成为架构师，就必须跳出技术的视角，换一个角度去看技术。要把时间花在研究生命周期规律和业务的增长上，花在选择合适的技术上，而不只是追求新潮的或自己喜欢的技术。     </p>
</blockquote>
<h3 id="业务、架构和技术三者的关系"><a href="#业务、架构和技术三者的关系" class="headerlink" title="业务、架构和技术三者的关系"></a>业务、架构和技术三者的关系</h3><p>先有业务问题，才会有技术来解决业务问题。而业务的长大要求，提高了对技术的要求，导致了对业务生命周期的拆分，以并行的方式提升效率，形成了架构，也形成了新的技术。所以在三者的关系里：<br>业务是核心，技术是解决业务问题的工具，而架构师让业务长大的组织方法。<br>架构需要用技术来实现拆分，而技术需要架构来合理组织，以提升效率。</p>
<p>选择技术时需要考虑的点：<br>1.当技术所要解决的问题和拆分出来要解决的问题完全匹配时，这是最完美的。<br>2.当技术所提供的能力远远超过需要解决的问题时，往往掌握技术和维护技术就会成为负担。<br>3.当技术所提供的能力和我们所要解决的问题部分匹配时，要判断是否要采用，最终还是要看成本。<br>所以，在架构拆分的基础之上，识别并平衡技术的能力，也是架构师所需要具备的能力之一。考虑的主要因素是长期的成本和收益。    </p>
<h3 id="软件研发"><a href="#软件研发" class="headerlink" title="软件研发"></a>软件研发</h3><p>软件所面对的共有三大业务领域及其所对应的架构。    </p>
<ol>
<li>业务领域，由业务组织架构来推动业务的架构，即业务生命周期的拆分。</li>
<li>软件开发业务领域，由软件开发的业务组织架构来推动软件的业务架构，如软件的研发流程、角色分工等。所形成的是软件开发模式，不同角色的分工模型。</li>
<li>软件运行业务领域，由软件的开发工程师来负责编写代码，形成软件的架构，并支撑软件的运行。对不同的软件开发工程师进行分工，形成不同的软件开发工程师组织架构，以支撑不同的软件，与软件的架构相匹配。</li>
</ol>
<p>在软件开发生命周期中，软件工程师和软件架构师是最重要的两个角色，软件工程师负责建设，软件架构师负责组织。<br>为了支持软件工程师的工作，软件架构师的主要职责包括以下几点：     </p>
<ol>
<li>理解业务组织架构，业务组织架构支撑并推进业务架构，背后的原因是对业务生命周期的拆分。     </li>
<li>根据业务生命周期的特点和软件开发生命周期的特点，形成软件开发本身的业务体系，以及对软件开发生命周期的拆分，也就是软件开发的业务架构。    </li>
<li>根据对业务生命周期以及软件开发生命周期的拆分，形成了和两者都相匹配的软件开发团队的组织架构。    </li>
<li>对软件进行架构拆分，匹配业务架构和软件开发的业务架构。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p1.png" alt="业务、软件开发业务和软件运行业务三者间的关系">.</li>
</ol>
<h3 id="软件的架构拆分"><a href="#软件的架构拆分" class="headerlink" title="软件的架构拆分"></a>软件的架构拆分</h3><h4 id="软件团队拆分"><a href="#软件团队拆分" class="headerlink" title="软件团队拆分"></a>软件团队拆分</h4><p>比较好的拆分方式：一个业务团队对应一个软件开发团队。<br>这个方式要求每个业务部门都有独立的软件开发团队来配合。每个软件开发团队只对应一个业务团队，这样所形成的软件边界都很清楚，沟通也很高效。业务团队和对应的软件开发团队能够形成合力，共同解决该团队的业务问题。<br>这种方式会让软件开发团队的组织也形成一棵组织架构树，并且这棵树和业务团队的组织架构是匹配的。      </p>
<h4 id="软件的拆分"><a href="#软件的拆分" class="headerlink" title="软件的拆分"></a>软件的拆分</h4><p>一个软件开发团队开发一个软件。这样每个软件的职责非常明确，沟通也会比较简单，这是最好的。这时形成的还是一棵树。软件和软件之间的关系，反映的就是组织和组织之间的关系，一一对应，还是一棵树。 </p>
<p>在拆分过程中，要避免不同的用户访问通道相互影响。因此，软件在访问通道的问题上不能重用。重用访问通道的结果，既损伤用户的利益，也损伤软件的利益，还会损伤软件开发团队和企业的利益。    </p>
<h4 id="软件开发的基础技术"><a href="#软件开发的基础技术" class="headerlink" title="软件开发的基础技术"></a>软件开发的基础技术</h4><p><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p2.png" alt="企业组织架构和软件架构_图片"><br>架构拆分的原则来源于业务自身的组织架构，使得软件架构保持和业务组织架构的匹配关系；其次来源于软件开发团队自身的组织架构；最后来源于用户的流量对软件本身的冲击。如果软件开发团队的组织架构和业务的组织架构一致，这就是损耗最小的方式，软件的架构也会更简单。</p>
<h3 id="如何写好代码"><a href="#如何写好代码" class="headerlink" title="如何写好代码"></a>如何写好代码</h3><p>内聚：内聚就是要确保一个事物的生命周期是完整的，而不是分裂的。所谓完整，就是指一个生命周期的主体，从生到死之间的整个过程中，所发生的行为和状态是累积在一个主体上的。<br>从流程角度讲，访问逻辑实际上就是实现业务流程的基础。每次访问都通过对不同角色的生命周期，也就是不同的业务逻辑进行访问，访问其实就是遍历架构树，形成业务流程，完成用户生命周期活动的推进。     </p>
<h4 id="业务逻辑分散的危害"><a href="#业务逻辑分散的危害" class="headerlink" title="业务逻辑分散的危害"></a>业务逻辑分散的危害</h4><ol>
<li>如果服务代码中混入了业务逻辑，则服务做了两件或者两件以上的事情。服务本身的责任是逻辑，这是顺序执行。加入了业务逻辑就表明做了两件或者两件以上的事情。可以分为以下两种情况：<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;a.两个不同的访问生命周期合并在一个服务中实现。<br>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;b.如果是有计算的逻辑的话，比如受益计算、订单金额计算等，那么这部分应该是业务代码需要完成的，不能交给服务代码来实现。这部分代码是需要单元测试的，而服务代码要和用户打交道就会有上下文相关的代码，因此不适合做单元测试。</li>
<li>黏合代码里面包含业务逻辑的话，也会做两件或者两件以上的事情，会和业务代码一样，遇到同样的问题。</li>
<li>存储代码里面如果混入了业务逻辑，则会导致业务逻辑进入到存储设备中。<br>存储一旦变成了逻辑计算的主体，绑定数据的逻辑计算就成了一个巨大的限制，会导致存储设备无法通过增加机器的方式横向扩展长大，只能换性能更好的机器纵向扩展，而纵向扩展不仅程度有限而且成本也较高。</li>
</ol>
<h4 id="业务逻辑内聚的好处"><a href="#业务逻辑内聚的好处" class="headerlink" title="业务逻辑内聚的好处"></a>业务逻辑内聚的好处</h4><h4 id="代码架构的实例"><a href="#代码架构的实例" class="headerlink" title="代码架构的实例"></a>代码架构的实例</h4><p>如图所示，Manager类实际就是黏合代码。<br>注意事项：      </p>
<ol>
<li>不能把业务模型当做数据对象来处理。业务模型关心的是其生命周期，数据是这些生命周期行为的状态。所以黏合代码需要把业务模型转换成存储设备的实体(entity)，实体和存储设备里面的存储粒度一一对应。比如在数据库中，每个实体对应一张表，并且跟着表的变化而变化，这样就保证存储设备的变更不会影响业务模型。同样业务模型不能拿来用作服务和用户之间的数据交换媒介，只能转换为DTO（Data Transfer Object）来使用。也就是说业务模型对用户是不可见的。DTO的目的是在用户的访问操作中传输数据，并和用户交互的视图保持一致。通过增加DTO可以保证用户的访问生命周期需求变化，并不会影响到业务模型，虽然用户的访问生命周期需要变化是最频繁的，但DTO解决了这个难题。     </li>
<li>服务代码里不要考虑代码的重用。针对不同的用户提供不同的服务，确保他们之间的访问生命周期是隔离的，避免相互影响。多个角色访问同一个接口，其中一个角色改了共有接口，势必会影响其他角色对该接口的正常使用。尽量给不同的角色不同的服务，既避免通道重用又降低沟通成本。服务多不是问题，服务的生命周期管理才是问题。    </li>
<li>业务模型是必须要重用的，因为这是所有用户访问的目标。业务模型总是围绕着核心生命周期展开的一棵树状结构。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p3.png" alt="案例"></li>
</ol>
<h4 id="代码误解"><a href="#代码误解" class="headerlink" title="代码误解"></a>代码误解</h4><p>服务代码、黏合代码和存储代码不能有逻辑。</p>
<h4 id="软件的拆分-1"><a href="#软件的拆分-1" class="headerlink" title="软件的拆分"></a>软件的拆分</h4><p>软件的拆分必须要和业务的拆分对应起来，此时就可看出业务生命周期分析的好处。软件的核心是模拟业务，而业务代码是按照业务的生命周期组织的，软件拆分的目的就是把软件的业务生命周期代码进行生命周期拆分。<br>不仅仅代码内部可以进行拆分，还可以直接把某些业务生命周期的代码拆分到另外一个软件中，并把相应的服务代码、管理者代码和存储代码一起拆分过去。这个拆分方式就形成了新的软件，而对原软件的影响仅仅是对被拆分出去的业务调用方式发生了变化而已，从本地调用变成了服务调用。<br>业务生命周期的分析既是软件拆分的大前提又是架构的基因。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是一种白盒测试，集成测试是一种黑盒测试。</p>
<h4 id="单元测试测什么"><a href="#单元测试测什么" class="headerlink" title="单元测试测什么"></a>单元测试测什么</h4><p>服务代码、管理者代码和存储代码都是不需要写单元测试的。单元测试是用来测试软件工程师自己写的逻辑，如果代码里面没有逻辑就不需要写单元测试。</p>
<h4 id="如何改造代码"><a href="#如何改造代码" class="headerlink" title="如何改造代码"></a>如何改造代码</h4><p>只要出现了模拟，单元测试就开始失效了。<br>对于一个逻辑“单元”，也就是方法，所依赖两个方面：一个是输入的参数，另一个是内部对外部的方法调用。只要确保输入参数不包含外部环境的上下文，同时内部代码对外部的调用也不包含对环境上下文的访问，这个方法就是可以单元测试的。</p>
<h4 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h4><ol>
<li>构建输入参数，并预测该输入所产生的输出。</li>
<li>调用要测试的目标方法，获取输出。</li>
<li>检测目标方法的输出是否和预测的输出一致。</li>
</ol>
<h3 id="软件架构和面向对象"><a href="#软件架构和面向对象" class="headerlink" title="软件架构和面向对象"></a>软件架构和面向对象</h3><h3 id="软件架构和设计模式"><a href="#软件架构和设计模式" class="headerlink" title="软件架构和设计模式"></a>软件架构和设计模式</h3><h4 id="设计模式和架构"><a href="#设计模式和架构" class="headerlink" title="设计模式和架构"></a>设计模式和架构</h4><p>创建型模式用生命周期来理解，就是把产生对象的生命周期单独拆分出来，即发生了架构分析。结构型模式则专注于对象的不同组合方式，而行为型则主要针对对象之间的沟通。<br>软件设计模式本身就是一个架构拆分的结果，只是这个拆分被标准化了，可以被重复使用而已。而设计模式在被使用的时候，则不需要再进行设计，直接使用即可。因此设计模式就变成了一个成熟的技巧或者技术了。软件设计模式这部分的代码其实是有自己的业务领域的，这个领域就是软件的访问生命周期。<br>只有从访问代码中剥离了所有服务业务的逻辑，才有可能讨论软件访问生命周期自身的业务模型。</p>
<h4 id="设计模式的误区"><a href="#设计模式的误区" class="headerlink" title="设计模式的误区"></a>设计模式的误区</h4><p>对于业务对象来说，业务对象表达的是业务的核心分工，是不同用户所访问的目标，这部分自然是要重用的。因为现实生活中，业务的分工就是这样的，执行业务的时候按照业务的访问流程组合不同的对象即可。但对于服务、黏合代码和存储而言，它们都有自己独特的业务问题，即它们处理访问通道的，目的并不是给大家共享，也不是访问的目标。而处理好通道问题，则是按照不同角度的用户来进行分析，提供不同的通道，让他们之间的访问互不影响，才能够服务好不同的要求。访问通道是不重用的。</p>
<h3 id="软件架构和软件框架"><a href="#软件架构和软件框架" class="headerlink" title="软件架构和软件框架"></a>软件架构和软件框架</h3><h4 id="访问类框架"><a href="#访问类框架" class="headerlink" title="访问类框架"></a>访问类框架</h4><p>MVC中的模型（Model）更多的是指对试图（View）的数据支持，一般用DTO（data transfer Object）来表达。而业务模型关注的是业务生命周期及其行为，业务模型的内部数据只是这些行为的结果。MVC中的模型和业务模型是连个不同的概念，不可混用。但是两者可以通过数据转换结合起来连接沟通使用，需要类似于适配器（Adapter）的模式（如ORM）来解决这个问题。</p>
<h4 id="业务类框架"><a href="#业务类框架" class="headerlink" title="业务类框架"></a>业务类框架</h4><p>为整个行业提供解决方案，而形成的一个行业的框架。如CRM（Customer Relationship Management），CRM把和用户打交道的基本规则封装起来，然后留给各企业按照自己企业的特点做一定变化的空间，最终所形成的就是一个行业的框架。</p>
<h4 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h4><p>框架基本上都是根据业务模型，或者设计模式等，把模型中稳定的部分进行封装，形成一个大的边界，但是具体内容仍留有余地。由于业务模型或者设计模式也是架构拆分的结果，因此框架同时也属于业务架构的一个具体实现。框架对业务模型中变化的部分，一般都会提供很容易的扩展方式，使得框架使用者可以根据自己业务的特殊性对框架进行扩展，而不需要全部从头开始编码。</p>
<h4 id="框架的特点"><a href="#框架的特点" class="headerlink" title="框架的特点"></a>框架的特点</h4><p>框架往往都是无法单独运行的。软件框架基本都是一个留有扩展余地，为其他代码所引用的代码或类库。<br>框架为方便本地定制，在本地进行改造，和自己的软件结合在一起。框架和服务的另一个区别：软件引用框架是本地引用的方式，而服务是用来远程调用的。<br>框架的背后总有一个模式存在，这个模式是来解决共同问题。    </p>
<h3 id="软件运维"><a href="#软件运维" class="headerlink" title="软件运维"></a>软件运维</h3><p>运维是软件真正的核心竞争力。</p>
<h4 id="软件运行生命周期"><a href="#软件运行生命周期" class="headerlink" title="软件运行生命周期"></a>软件运行生命周期</h4><p>软件的目的是为用户提供持续不断额访问，软件运行生命周期的核心是软件访问生命周期。<br>下图所示，软件生命周期分拆树，树的遍历顺序从左至右。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p4.png" alt="软件生命周期分拆树">     </p>
<h4 id="什么是软件运维"><a href="#什么是软件运维" class="headerlink" title="什么是软件运维"></a>什么是软件运维</h4><p>软件运行生命周期可以拆分成：软件运维生命周期和软件访问生命周期。其中软件访问生命周期是核心生命周期。运维生命周期是从软件开始部署开始，到软件结束服务为止。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p5.png" alt="软件生命周期分拆树">    </p>
<h4 id="运维的业务模型"><a href="#运维的业务模型" class="headerlink" title="运维的业务模型"></a>运维的业务模型</h4><p>运维的业务目标是保证用户的访问生命周期不受影响。     </p>
<h4 id="控制变化"><a href="#控制变化" class="headerlink" title="控制变化"></a>控制变化</h4><p>任何对软件的改变，都是风险，都需要运维的关注。<br>要做好变化的控制，首先要做的是：在软件周围设立隔离区，避免软件出现在不安全的地方。其中包括软件本身、硬件、网络和电力等。     </p>
<h6 id="如何隔离"><a href="#如何隔离" class="headerlink" title="如何隔离"></a>如何隔离</h6><p>拆分软件的运行环境，区分办公环境（开发）和生产环境（运行），生产环境是一套单独的设备环境。      </p>
<h6 id="控制变更"><a href="#控制变更" class="headerlink" title="控制变更"></a>控制变更</h6><ul>
<li>软件的变更    </li>
<li>硬件的变更</li>
<li>网络的变更</li>
<li>电力的变更</li>
</ul>
<h4 id="监控变更"><a href="#监控变更" class="headerlink" title="监控变更"></a>监控变更</h4><p>监控的目的实际上就是把系统内不同生命周期的当前运行状态，通过探测器传输出来，展示到可视或可感知的设备上，来供人查看。监控非常重要的指标是实时度。      </p>
<h4 id="预警变更"><a href="#预警变更" class="headerlink" title="预警变更"></a>预警变更</h4><p>预警内容分为两部分：    </p>
<ol>
<li>软件本身业务的预警，主要包括软件、硬件、网络和电力等设备。</li>
<li>软件所实现业务的预警。<blockquote>
<p>监控是生成预警的数据基础。对业务生命周期的理解则是生成预警的规则基础。<br>预警软件本身也是需要监控和预警的，也是预警的业务。</p>
</blockquote>
</li>
</ol>
<h4 id="主导变更"><a href="#主导变更" class="headerlink" title="主导变更"></a>主导变更</h4><p>在生成系统做变更，也需要有一个正向反馈环，这个正向反馈环核心环节就是监控和预警。   </p>
<h6 id="发布"><a href="#发布" class="headerlink" title="发布."></a>发布.</h6><p>一般第一次发布，就是该变更第一次在生产环境的应用，此时风险最大。因此要确保被影响的机器越少越好，把风险降到最低。首次发布时一般都选择可发布的最小单位，也就是一台机器。对于特别重要的软件，往往会在发布50%之后，经历一次业务高峰后再发布剩余的机器。因为即使该变更有问题，导致50%的机器在高峰期的压力下无法正常工作，还有剩下50%的机器能够支撑业务的运作。这意味着在建立集群的时候，必须要留有50%的冗余容量来做缓冲。</p>
<h3 id="软件访问生命周期"><a href="#软件访问生命周期" class="headerlink" title="软件访问生命周期"></a>软件访问生命周期</h3><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>集群就是组装有相同的软件，具备同样功能的一组计算机，组织在一起共同服务于客户的访问，它以横向扩展的方式提升软件访问能力。<br>应用集群后，所有用户不再只访问一台机器，变成了用户分散访问不同的机器，但还是访问同一个软件。因为集群内的机器功能都是一样的，相当于增加了访问通道，使得软件的访问容量得到了增长。<br>集群通过路由来指定用户对某一台计算机的访问。用户访问到达集群前端时做一个路由，把每个用户的请求按照预设的规则转发到集群中的某台机器，即可让用户的访问自动到达某台机器上的软件，转发预设的规则还需要考虑某台机器是否过忙，否则把用户的请求转发到过载的机器上反而影响用户的访问。<br>集群的路由主要考虑的因素是集群内机器的负载均衡问题，为了实现对集群内机器负载的感知，路由必须定时的检查集群内机器的健康和剩余访问容量。路由的引入使得用户并不知道自己访问的是一个集群，因为每次访问都只是访问一台机器，集群对用户是透明的。<br>集群出现后，用户的访问路径又做了一次架构拆分，在软件所部署的计算机之前增加了一个访问路由，这个路由负责把用户的请求按照转发规则转发给集群内的某台计算机。转发规则有很多种，比如按照访问的权重来路由，随机路由、散列路由等，各有各的优势和缺点。<br>集群虽好，但是要实现集群，对软件本身则有一个限制：要能够在不同的计算机之间保持用户的状态。比如用户本次访问的机器和上次不同，这个机器就不知道用户是谁，从而无法给用户服务，就要求用户再次登录。在这种情况下，用户感知到了集群的存在，集群就失去了意义。要做到集群对用户透明，软件本身还需要在用户的访问路径上做一个架构拆分，使得同一个集群的不同机器之间，能够共享用户的状态。只有做到这一点，才能够真正地让集群对用户透明。当然，还有一种路由转发规则是按照用户的来源固定给某台机器来服务，确保单个用户上次访问的目标计算机和当前要访问的目标计算机是同一台来避免这个问题。实现方式是按照访问来源地址对集群内机器数量做散列，这样某个来源地址所访问的机器就是固定的。   </p>
<h4 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h4><p>多数据中心可以看成是集群的集群，装有同一个软件的集群会同时部署在多个不同的数据中心，集群在不同的数据中心各复制了一份。<br>当一个数据中心出了问题，其他的数据中心可以接管，可以让软件保持持续运行，获得很长的运行生命周期，不会对用户的访问造成影响。<br>要做到用户在不同数据中心访问同一个软件，就必须在不同数据中心的前端放置一个路由，类似于前述的集群做法，为部署了同一个软件但位于不同数据中心的各个集群做路由。用户访问软件的路径又做了一次架构拆分，增加了数据中心的路由生命周期。<br>数据中心前置路由的路由策略和集群的路由策略有不同之处。集群的路由策略保障的是集群内机器访问的均衡，而数据中心前置路由的路由策略则是把数据中心所覆盖地区的用户访问归属到相应的数据中心。这就意味着在建数据中心时，要考虑的实际上是物理空间维度上用户的覆盖面，避免数据中心过小而用户过多，导致数据中心之间的负载不均衡。<br>同一个软件部署在多个数据中心的不同集群上，一般会重新定义一个名字，叫做池(Pool)，比如有两个数据中心shanghai-dc和beijing-dc，都分别有订单集群，它们的名字会是order-shanghai-dc和order-beijing-dc，但是它们都属于订单的集群，会有一个统一的名字，叫做订单池(Order Pool)，相当于一个集群池，方便和集群分开。多数据中心出现后，软件发布的目标不再是针对集群，而是针对池，集群是物理的，池可以认为是逻辑上的集群，多个数据中心里部署了同一个软件的计算机都属于同一个池。<br>多个数据中心的出现，对变更的发布也会造成影响。一个池会同时部署在多个数据中心，发布变更的时候不能把一个数据中心的集群全部关闭。比如上例中订单池在两个数据中心分别有一个集群，各100台机器。在软件发布到50%的时候，不能让某个数据中心的100台机器全部下线，这会让一个数据中心的订单集群变成完全不可用，这是不可接受的。发布50%的时候应该是让两个数据中心各发布50%。<br>当一个用户从一个数据中心迁移到另一个数据中心时，可以按照用户维度存储数据，也可以通过数据同步保证两个数据中心的数据一致。</p>
<h3 id="软件架构和大数据"><a href="#软件架构和大数据" class="headerlink" title="软件架构和大数据"></a>软件架构和大数据</h3><h3 id="软件架构和建筑架构"><a href="#软件架构和建筑架构" class="headerlink" title="软件架构和建筑架构"></a>软件架构和建筑架构</h3><h2 id="软件架构的应用"><a href="#软件架构的应用" class="headerlink" title="软件架构的应用"></a>软件架构的应用</h2><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><h3 id="交易系统"><a href="#交易系统" class="headerlink" title="交易系统"></a>交易系统</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/11/16/5-minutes-docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/16/5-minutes-docker/" class="post-title-link" itemprop="url">读《每天5分钟玩转Docker容器技术》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-16 00:21:25" itemprop="dateCreated datePublished" datetime="2017-11-16T00:21:25+08:00">2017-11-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="鸟瞰容器生态系统"><a href="#鸟瞰容器生态系统" class="headerlink" title="鸟瞰容器生态系统"></a>鸟瞰容器生态系统</h2><h3 id="容器生态系统"><a href="#容器生态系统" class="headerlink" title="容器生态系统"></a>容器生态系统</h3><p><img src="/2017/11/16/5-minutes-docker/image-20221221151300199.png" alt="image-20221221151300199"></p>
<h3 id="准备实验环境"><a href="#准备实验环境" class="headerlink" title="准备实验环境"></a>准备实验环境</h3><h3 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h3><h2 id="容器核心知识概述"><a href="#容器核心知识概述" class="headerlink" title="容器核心知识概述"></a>容器核心知识概述</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><h3 id="为什么需要容器"><a href="#为什么需要容器" class="headerlink" title="为什么需要容器"></a>为什么需要容器</h3><h3 id="容器是如何工作的"><a href="#容器是如何工作的" class="headerlink" title="容器是如何工作的"></a>容器是如何工作的</h3><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="镜像的内部结构"><a href="#镜像的内部结构" class="headerlink" title="镜像的内部结构"></a>镜像的内部结构</h3><h4 id="镜像的分层结构"><a href="#镜像的分层结构" class="headerlink" title="镜像的分层结构"></a>镜像的分层结构</h4><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><h3 id="RUN-vs-CMD-vs-ENTRYPOINT"><a href="#RUN-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="RUN vs CMD vs ENTRYPOINT"></a>RUN vs CMD vs ENTRYPOINT</h3><h4 id="Shell-和-Exec格式"><a href="#Shell-和-Exec格式" class="headerlink" title="Shell 和 Exec格式"></a>Shell 和 Exec格式</h4><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h3 id="分发镜像"><a href="#分发镜像" class="headerlink" title="分发镜像"></a>分发镜像</h3><h4 id="为镜像命名"><a href="#为镜像命名" class="headerlink" title="为镜像命名"></a>为镜像命名</h4><h4 id="使用公共-Registry"><a href="#使用公共-Registry" class="headerlink" title="使用公共 Registry"></a>使用公共 Registry</h4><h4 id="搭建本地-Registry"><a href="#搭建本地-Registry" class="headerlink" title="搭建本地 Registry"></a>搭建本地 Registry</h4><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><h4 id="让容器长期运行"><a href="#让容器长期运行" class="headerlink" title="让容器长期运行"></a>让容器长期运行</h4><h4 id="两种进入容器的方法"><a href="#两种进入容器的方法" class="headerlink" title="两种进入容器的方法"></a>两种进入容器的方法</h4><h4 id="运行容器的最佳实践"><a href="#运行容器的最佳实践" class="headerlink" title="运行容器的最佳实践"></a>运行容器的最佳实践</h4><h3 id="stop-x2F-start-x2F-restart-容器"><a href="#stop-x2F-start-x2F-restart-容器" class="headerlink" title="stop&#x2F;start&#x2F;restart 容器"></a>stop&#x2F;start&#x2F;restart 容器</h3><h3 id="pause-x2F-unpause-容器"><a href="#pause-x2F-unpause-容器" class="headerlink" title="pause&#x2F;unpause 容器"></a>pause&#x2F;unpause 容器</h3><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><h3 id="State-Machine"><a href="#State-Machine" class="headerlink" title="State Machine"></a>State Machine</h3><h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><h4 id="内存限额"><a href="#内存限额" class="headerlink" title="内存限额"></a>内存限额</h4><h4 id="CPU限额"><a href="#CPU限额" class="headerlink" title="CPU限额"></a>CPU限额</h4><h4 id="Block-IO带宽限额"><a href="#Block-IO带宽限额" class="headerlink" title="Block IO带宽限额"></a>Block IO带宽限额</h4><h3 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h3><h4 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h4><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><h3 id="none-网络"><a href="#none-网络" class="headerlink" title="none 网络"></a>none 网络</h3><h3 id="host-网络"><a href="#host-网络" class="headerlink" title="host 网络"></a>host 网络</h3><h3 id="bridge-网络"><a href="#bridge-网络" class="headerlink" title="bridge 网络"></a>bridge 网络</h3><h3 id="user-defined-网络"><a href="#user-defined-网络" class="headerlink" title="user-defined 网络"></a>user-defined 网络</h3><h3 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h3><h4 id="IP通信"><a href="#IP通信" class="headerlink" title="IP通信"></a>IP通信</h4><h4 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h4><h4 id="joined-容器"><a href="#joined-容器" class="headerlink" title="joined 容器"></a>joined 容器</h4><h3 id="将容器与外部世界连接"><a href="#将容器与外部世界连接" class="headerlink" title="将容器与外部世界连接"></a>将容器与外部世界连接</h3><h4 id="容器访问外部世界"><a href="#容器访问外部世界" class="headerlink" title="容器访问外部世界"></a>容器访问外部世界</h4><h4 id="外部世界访问容器"><a href="#外部世界访问容器" class="headerlink" title="外部世界访问容器"></a>外部世界访问容器</h4><h2 id="Docker存储"><a href="#Docker存储" class="headerlink" title="Docker存储"></a>Docker存储</h2><h3 id="storage-driver"><a href="#storage-driver" class="headerlink" title="storage driver"></a>storage driver</h3><h3 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h3><h4 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind mount"></a>bind mount</h4><h4 id="docker-managed-volume"><a href="#docker-managed-volume" class="headerlink" title="docker managed volume"></a>docker managed volume</h4><h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><h4 id="容器与host共享数据"><a href="#容器与host共享数据" class="headerlink" title="容器与host共享数据"></a>容器与host共享数据</h4><h4 id="容器之间共享数据"><a href="#容器之间共享数据" class="headerlink" title="容器之间共享数据"></a>容器之间共享数据</h4><h3 id="volume-container"><a href="#volume-container" class="headerlink" title="volume container"></a>volume container</h3><h3 id="data-packed-volume-container"><a href="#data-packed-volume-container" class="headerlink" title="data-packed volume container"></a>data-packed volume container</h3><h3 id="Data-Volume-生命周期管理"><a href="#Data-Volume-生命周期管理" class="headerlink" title="Data Volume 生命周期管理"></a>Data Volume 生命周期管理</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><h4 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h4><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><h2 id="多主机管理"><a href="#多主机管理" class="headerlink" title="多主机管理"></a>多主机管理</h2><h3 id="实验环境描述"><a href="#实验环境描述" class="headerlink" title="实验环境描述"></a>实验环境描述</h3><h3 id="安装-Docker-Machine"><a href="#安装-Docker-Machine" class="headerlink" title="安装 Docker Machine"></a>安装 Docker Machine</h3><h3 id="创建-Machine"><a href="#创建-Machine" class="headerlink" title="创建 Machine"></a>创建 Machine</h3><h3 id="管理-Machine"><a href="#管理-Machine" class="headerlink" title="管理 Machine"></a>管理 Machine</h3><h2 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h2><h3 id="libnetwork-amp-CNM"><a href="#libnetwork-amp-CNM" class="headerlink" title="libnetwork &amp; CNM"></a>libnetwork &amp; CNM</h3><h3 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h3><h4 id="实验环境描述-1"><a href="#实验环境描述-1" class="headerlink" title="实验环境描述"></a>实验环境描述</h4><h4 id="创建-overlay-网络"><a href="#创建-overlay-网络" class="headerlink" title="创建 overlay 网络"></a>创建 overlay 网络</h4><h4 id="在-overlay-中运行容器"><a href="#在-overlay-中运行容器" class="headerlink" title="在 overlay 中运行容器"></a>在 overlay 中运行容器</h4><h4 id="overlay-网络连接性"><a href="#overlay-网络连接性" class="headerlink" title="overlay 网络连接性"></a>overlay 网络连接性</h4><h4 id="overlay-网络隔离"><a href="#overlay-网络隔离" class="headerlink" title="overlay 网络隔离"></a>overlay 网络隔离</h4><h4 id="overlay-IPAM"><a href="#overlay-IPAM" class="headerlink" title="overlay IPAM"></a>overlay IPAM</h4><h3 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a>macvlan</h3><h4 id="准备实验环境-1"><a href="#准备实验环境-1" class="headerlink" title="准备实验环境"></a>准备实验环境</h4><h4 id="创建-macvlan-网络"><a href="#创建-macvlan-网络" class="headerlink" title="创建 macvlan 网络"></a>创建 macvlan 网络</h4><h4 id="macvlan-网络结构分析"><a href="#macvlan-网络结构分析" class="headerlink" title="macvlan 网络结构分析"></a>macvlan 网络结构分析</h4><h4 id="用-sub-interface-实现多-macvlan-网络"><a href="#用-sub-interface-实现多-macvlan-网络" class="headerlink" title="用 sub-interface 实现多 macvlan 网络"></a>用 sub-interface 实现多 macvlan 网络</h4><h4 id="macvlan-网络间的隔离和连通"><a href="#macvlan-网络间的隔离和连通" class="headerlink" title="macvlan 网络间的隔离和连通"></a>macvlan 网络间的隔离和连通</h4><h3 id="finnel"><a href="#finnel" class="headerlink" title="finnel"></a>finnel</h3><h3 id="weave"><a href="#weave" class="headerlink" title="weave"></a>weave</h3><h3 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h3><h3 id="比较各种网络方案"><a href="#比较各种网络方案" class="headerlink" title="比较各种网络方案"></a>比较各种网络方案</h3><h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><h3 id="Docker自带的监控子命令"><a href="#Docker自带的监控子命令" class="headerlink" title="Docker自带的监控子命令"></a>Docker自带的监控子命令</h3><h3 id="sysdig"><a href="#sysdig" class="headerlink" title="sysdig"></a>sysdig</h3><h3 id="Weave-Scope"><a href="#Weave-Scope" class="headerlink" title="Weave Scope"></a>Weave Scope</h3><h3 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h3><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><h3 id="比较不同的监控工具"><a href="#比较不同的监控工具" class="headerlink" title="比较不同的监控工具"></a>比较不同的监控工具</h3><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><h3 id="Docker-logs"><a href="#Docker-logs" class="headerlink" title="Docker logs"></a>Docker logs</h3><h3 id="Docker-logging-driver"><a href="#Docker-logging-driver" class="headerlink" title="Docker logging driver"></a>Docker logging driver</h3><h3 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h3><h3 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h3><h3 id="Craylog"><a href="#Craylog" class="headerlink" title="Craylog"></a>Craylog</h3><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><h3 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h3><h3 id="实践-Rex-Ray-driver"><a href="#实践-Rex-Ray-driver" class="headerlink" title="实践 Rex-Ray driver"></a>实践 Rex-Ray driver</h3><h4 id="安装-Rex-Ray"><a href="#安装-Rex-Ray" class="headerlink" title="安装 Rex-Ray"></a>安装 Rex-Ray</h4><h4 id="配置-VirtualBox"><a href="#配置-VirtualBox" class="headerlink" title="配置 VirtualBox"></a>配置 VirtualBox</h4><h4 id="创建-Rex-Ray-volume"><a href="#创建-Rex-Ray-volume" class="headerlink" title="创建 Rex-Ray volume"></a>创建 Rex-Ray volume</h4><h4 id="使用-Rex-Ray-volume"><a href="#使用-Rex-Ray-volume" class="headerlink" title="使用 Rex-Ray volume"></a>使用 Rex-Ray volume</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/29/CSS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/29/CSS3/" class="post-title-link" itemprop="url">CSS3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-29 20:37:19" itemprop="dateCreated datePublished" datetime="2017-10-29T20:37:19+08:00">2017-10-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><p><code>border-radius</code></p>
<p>每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的。</p>
<h4 id="盒阴影"><a href="#盒阴影" class="headerlink" title="盒阴影"></a>盒阴影</h4><p><code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>
<p>boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。  </p>
<ul>
<li>h-shadow	必需的。水平阴影的位置。允许负值   </li>
<li>v-shadow	必需的。垂直阴影的位置。允许负值</li>
<li>blur	可选。模糊距离</li>
<li>spread	可选。阴影的大小</li>
<li>color	可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表</li>
<li>inset	可选。从外层的阴影（开始时）改变阴影内侧阴影</li>
</ul>
<h4 id="边框图像"><a href="#边框图像" class="headerlink" title="边框图像"></a>边框图像</h4><p><code>border-image: source slice width outset repeat;</code></p>
<ul>
<li>border-image-source	用于指定要用于绘制边框的图像的位置</li>
<li>border-image-slice	图像边界向内偏移</li>
<li>border-image-width	图像边界的宽度</li>
<li>border-image-outset	用于指定在边框外部绘制 border-image-area 的量</li>
<li>border-image-repeat	这个例子演示了如何创建一个border-image 属性的按钮。</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h5 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h5><p>不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background-image: url(img_flwr.gif), url(paper.gif);</span><br><span class="line">	background-position: right bottom, left top;</span><br><span class="line">	background-repeat: no-repeat, repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以给不同的图片设置多个不同的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><p>background-size可以指定图像的大小。CSS3以前，背景图像大小由图像的实际大小决定。<br>CSS3中可以指定背景图片，重新在不同的环境中指定背景图片的大小。指定的大小是相对父元素的宽度和高度的百分比大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-size:80px 60px;</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p>指定背景图片的位置区域。content-box、padding-box、border-box区域内可以放置背景图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">	background-size:100% 100%;</span><br><span class="line">	background-origin:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="渐变-gradient"><a href="#渐变-gradient" class="headerlink" title="渐变 gradient"></a>渐变 gradient</h3><p>gradient可以在两个或多个指定颜色之间显示平稳的过渡。<br>CSS3中定义了两种类型的渐变</p>
<ul>
<li>线性渐变 Line Gradient  向下&#x2F;向上&#x2F;向左&#x2F;向右&#x2F;对角方向</li>
<li>径向渐变 Radial Gradient 由它们的中心定义</li>
</ul>
<h5 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h5><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。</p>
<p><code>background: linear-gradient(direction, color-stop1, color-stop2, ...); </code></p>
<p>线性渐变 - 从上到下 （默认情况）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  	background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  	background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  	background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  	background: linear-gradient(red, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线性渐变 - 从左到右</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(to right, red , blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性渐变 - 对角</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用角度</p>
<p><code>background: linear-gradient(angle, color-stop1, color-stop2);</code></p>
<p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。</p>
<p><img src="/2017/10/29/CSS3/angleGradient.jpg" alt="角度"></p>
<p>但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。换算公式 90 - x &#x3D; y 其中 x 为标准角度，y为非标准角度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(180deg, red, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多个颜色结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: linear-gradient(red, green, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用透明度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */</span><br><span class="line">  background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/</span><br><span class="line">  background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/</span><br><span class="line">  background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复的线性渐变<br>repeating-linear-gradient() 函数用于重复线性渐变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* Opera 11.1 - 12.0 */</span><br><span class="line">  background: -o-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* Firefox 3.6 - 15 */</span><br><span class="line">  background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  /* 标准的语法 */</span><br><span class="line">  background: repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h5><p>径向渐变由它的中心定义。</p>
<p>为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
<p><code>background: radial-gradient(center, shape size, start-color, ..., last-color); </code></p>
<p>径向渐变 - 颜色结点均匀分布（默认情况下）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(red, green, blue); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>径向渐变 - 颜色结点不均匀分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置形状</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */</span><br><span class="line">  background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */</span><br><span class="line">  background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */</span><br><span class="line">  background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h6 id="CSS3-font-face-规则"><a href="#CSS3-font-face-规则" class="headerlink" title="CSS3 @font-face 规则"></a>CSS3 @font-face 规则</h6><p>在CSS3之前，web设计师必须使用已在用户计算机上安装好的字体，不能够使用离线字体，不过通过CSS3，web设计师可以使用他们喜欢的任意字体。</p>
<p>当您找到或购买到希望使用的字体时，可将该字体文件存放到web服务器上，它会在需要时被自动下载到用户的计算机上。</p>
<p>您”自己的”的字体是在 CSS3 @font-face 规则中定义的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">   font-family: myFirstFont;</span><br><span class="line">   src: url(sansation_light.woff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">   font-family:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h3><h5 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h5><p>根据左（x轴）和顶部（y轴）位置给定的参数，从当前元素位置移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: translate(50px, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h5><p>在给定的读书顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: rotate(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h5><p>该元素增加或减少的大小，取决于宽度（x轴）和高度（y轴）的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: scale(2,4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="skew"><a href="#skew" class="headerlink" title="skew()"></a>skew()</h5><p>包含两个参数，分别表示X轴和Y轴倾斜角度，如果第二个参数为空，则默认为0，参数为负表示向相反的方向倾斜。</p>
<ul>
<li>skewX() 表示只在X轴（水平方向）倾斜</li>
<li>skewY() 表示只在Y轴（垂直方向）倾斜</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: skew(10deg, 30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h5><p>matrix()方法和2D变换方法合并成一个。<br>matrix()方法有6个参数，包含旋转、缩放、移动（平移）和倾斜功能。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: matrix(0.3, 0.5, -0.5, 0.3, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/" class="post-title-link" itemprop="url">高效操作DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-22 20:58:31" itemprop="dateCreated datePublished" datetime="2017-10-22T20:58:31+08:00">2017-10-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h1><p>DOM（Document Object Model） 文档对象模型。</p>
<p>是JavaScript操作HTML的接口。</p>
<p>DOM V3标准主要由3个部分组成</p>
<ul>
<li>DOM节点</li>
<li>DOM事件</li>
<li>选择区域</li>
</ul>
<p>DOM节点概念区分：</p>
<ul>
<li>标签是HTML的基本单位，比如div、li、p、input等</li>
<li>节点是DOM数的基本单位，有多种类型，比如注释节点、文本节点</li>
<li>元素是节点中的一种，与HTML标签相应，比如p标签会对应p元素</li>
</ul>
<h1 id="DOM操作耗时"><a href="#DOM操作耗时" class="headerlink" title="DOM操作耗时"></a>DOM操作耗时</h1><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><p>浏览器包括渲染引擎（浏览器内核）和JavaScript引擎，它们都是单线程，单线程的优势是开发方便，避免了多线程下的死锁、竞争等问题；劣势是失去了并发能力。</p>
<p>浏览器为了避免两个引擎同时修改页面而造成渲染结果不一致的情况，这两个引擎具有互斥性，在某一个时刻只有一个引擎在运行，另一个引擎被阻塞。</p>
<p>操作系统在进行线程切换时需要保存上一个线程执行时的状态信息，并读取下一个线程的状态信息，俗称上下文切换，这个操作相对而言是比较耗时的。</p>
<p>从JavaScript引擎切换到渲染引擎执行相应操作后，再切换回JavaScript引擎继续执行，会带来性能损耗。</p>
<h2 id="重新渲染"><a href="#重新渲染" class="headerlink" title="重新渲染"></a>重新渲染</h2><p>渲染过程中最耗时的两个步骤为重排（Reflow）与重绘（Repaint）。</p>
<p>渲染页面是将HTML和CSS分别解析成DOM树和CSSOM树，然后合并进行排布，再绘制成我们可见的页面，如果在操作DOM时涉及到元素、样式的修改，就会引起渲染引擎重新计算样式生成CSSOM树，同时还有可能触发对元素的重新排布（简称“重排”）和重新绘制（简称“重绘”）</p>
<p>影响到其他元素排布的操作就会引起重排，继而引发重绘。</p>
<p>比如：</p>
<ul>
<li>修改元素边距、大小</li>
<li>添加删除元素</li>
<li>改变窗口大小</li>
</ul>
<p>与之相反的操作只会引起重绘</p>
<p>比如：</p>
<ul>
<li>设置背景图片</li>
<li>修改字体颜色</li>
<li>改变visibility属性值</li>
</ul>
<h2 id="如何高效操作DOM"><a href="#如何高效操作DOM" class="headerlink" title="如何高效操作DOM"></a>如何高效操作DOM</h2><h3 id="在循环外操作元素"><a href="#在循环外操作元素" class="headerlink" title="在循环外操作元素"></a>在循环外操作元素</h3><p>不用在循环内操作元素，尽量在循环外操作元素。</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224635494.png" alt="image-20230319224635494"></p>
<h3 id="批量操作元素"><a href="#批量操作元素" class="headerlink" title="批量操作元素"></a>批量操作元素</h3><p>比如创建10000个元素，在节点中直接添加耗时会非常多。如果拼接到字符串中，则相对较少。</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224706991.png" alt="image-20230319224706991"></p>
<h3 id="缓存元素集合"><a href="#缓存元素集合" class="headerlink" title="缓存元素集合"></a>缓存元素集合</h3><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319224956526.png" alt="image-20230319224956526"></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319225019237.png" alt="image-20230319225019237"></p>
<h2 id="其他减少耗时的方法"><a href="#其他减少耗时的方法" class="headerlink" title="其他减少耗时的方法"></a>其他减少耗时的方法</h2><ul>
<li>尽量不用使用复杂的匹配规则和复杂的样式。从而减少渲染引擎计算样式规则生成CSSOM树的时间</li>
<li>尽量减少重排和重绘影响的区域</li>
<li>使用CSS特效来实现动画效果</li>
</ul>
<h1 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h1><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>搜索输入框，绑定input元素的键盘事件，然后在监听函数中发送AJAX请求。直接在事件方法里调用接口，这样会触发性能问题，每输入一个字符，都会在事件里响应，调用一次接口，而在实际中，用户输入完整字符后调用接口才是有效的。</p>
<p>针对这种情况，需要一个“防抖”功能，为函数的执行设置一个合理的时间间隔，避免事件在时间间隔内频繁触发，同时又保证用户输入后能即时看到搜索结果。</p>
<p><strong>setTimeout函数来让函数延迟执行</strong></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319230223440.png" alt="image-20230319230223440"></p>
<p>这个函数可以抽取成公共函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共防抖</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">func, wait=<span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> args</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">debounced</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">        args = arg</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Promise形式返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">res</span>(result)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    <span class="title function_">rej</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许取消</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许立即执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flush</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>()</span><br><span class="line">        <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.<span class="property">cancel</span> = cancel</span><br><span class="line">    debounced.<span class="property">flush</span> = flush</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>场景：一个浏览页面，左侧目录，右侧文章，浏览文章时，左侧目录根据右侧浏览滚动位置高亮显示。</p>
<p>实现：计算出每级目录对应文章内容的高度，根据距离来判断需要高亮的章节。在滚动事件里实时根据滚动距离去判断，但这会影响性能，一滚动就会触发计算。</p>
<p><strong>“节流“功能</strong></p>
<p>设置在指定一段时间内只调用一次函数，从而降低函数调用频率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">func, wait=<span class="number">0</span>, execFirstCall</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> args</span><br><span class="line">    <span class="keyword">let</span> firstCallTimestamp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!firstCallTimestamp) </span><br><span class="line">            firstCallTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">        <span class="keyword">if</span> (!execFirstCall || !args) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set args&#x27;</span>, arg)</span><br><span class="line">            args = arg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Promise形式返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title function_">async</span>(res, rej) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - firstCallTimestamp &gt;= wait) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   	<span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                    <span class="title function_">res</span>(result)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    <span class="title function_">rej</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="title function_">cancel</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = <span class="built_in">setTimeout</span>(<span class="title function_">async</span>() =&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">const</span> result = <span class="keyword">await</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">                        <span class="title function_">res</span>(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                        <span class="title function_">rej</span>(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="title function_">cancel</span>()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, firstCallTimestamp + wait - <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许取消</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        args = <span class="literal">null</span></span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">        firstCallTimestamp = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//允许立即执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flush</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">cancel</span>()</span><br><span class="line">        <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    throttled.<span class="property">cancel</span> = cancel</span><br><span class="line">    throttled.<span class="property">flush</span> = flush</span><br><span class="line">    <span class="keyword">return</span> throttled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319232609530.png" alt="image-20230319232609530"></p>
<p>对上面代码中的”编辑“和”删除“进行事件监听。</p>
<p>如果数据量一旦增大，事件绑定占用的内存以及执行时间将会成线性增加，其实这些事件监听函数逻辑一致，只是参数不同而已，我们可以以事件代理或事件委托来进行优化。</p>
<p><strong>DOM事件触发流程</strong></p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319232907645.png" alt="image-20230319232907645"></p>
<p><strong>代理事件</strong></p>
<p>对list中的事件同一处理，通过参数来识别不同的item</p>
<p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319233155747.png" alt="image-20230319233155747"></p>
<h2 id="关于DOM事件标准"><a href="#关于DOM事件标准" class="headerlink" title="关于DOM事件标准"></a>关于DOM事件标准</h2><p><img src="/2017/10/22/%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9CDOM/image-20230319233256667.png" alt="image-20230319233256667"></p>
<p>上面三种方式的区别</p>
<p>方式1和方式2会覆盖前面的事件</p>
<p>推荐使用方式3，同一事件的监听函数互补影响，而且可以独立取消，调用顺序和监听顺序一致。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/" class="post-title-link" itemprop="url">HTML中易忽略的标签</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-19 20:02:26" itemprop="dateCreated datePublished" datetime="2017-10-19T20:02:26+08:00">2017-10-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h1><h2 id="自动刷新-x2F-跳转"><a href="#自动刷新-x2F-跳转" class="headerlink" title="自动刷新&#x2F;跳转"></a>自动刷新&#x2F;跳转</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5;URL=page2.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设要实现PPT自动播放的功能，只需在每个页面的meta标签内设置好下一个页面地址即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;60&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>比如每隔一分钟就需要刷新页面的大屏幕监控，也可以通过meta标签来实现，只需去掉后面的URL。</p>
<blockquote>
<p>使用这种方式，刷新和跳转是不可取消的，对刷新时间间隔或者需要手动取消的，推荐使用JavaScript定时器来实现。</p>
<p>如果只是想实现页面的定时刷新或跳转（比如某些页面缺乏访问权限，在x秒后跳回首页这样的场景），建议使用meta标签</p>
</blockquote>
<h1 id="title标签"><a href="#title标签" class="headerlink" title="title标签"></a>title标签</h1><h2 id="Hack手段：消息提醒"><a href="#Hack手段：消息提醒" class="headerlink" title="Hack手段：消息提醒"></a>Hack手段：消息提醒</h2><p>B&#x2F;S架构在处理某些场景，比如即时通信时，会变得比较麻烦，因为前后端通信深度依赖HTTP协议，而HTTP协议是采用”请求-响应“模式。一种低效的解决方案是客户端通过轮询机制获取最新消息，（HTML5下可以使用WebSocket协议）</p>
<p>HTML5标准发布之前，浏览器没有开放图标闪烁、弹出系统消息之类的接口，只能借助一些Hack手段，比如修改title标签来达到类似的效果。代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msgNum = <span class="number">1</span> <span class="comment">//条数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">const</span> inerval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    count = (count + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (msgNum === <span class="number">0</span>) &#123;</span><br><span class="line">        doucument.<span class="property">title</span> += <span class="string">&#x27;聊天页面&#x27;</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> refix = count % <span class="number">2</span> ? <span class="string">`新消息(<span class="subst">$&#123;msgNum&#125;</span>)`</span> : <span class="string">&quot;&quot;</span></span><br><span class="line">    doucument.<span class="property">title</span> = <span class="string">`<span class="subst">$&#123;prefix&#125;</span>聊天页面`</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<p>HTML5中可以使用Web notifications API弹出系统消息。</p>
<p>动态修改title标签，还可以将一些关键信息显示在标签上，（比如下载时的进度、当前操作步骤等）</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>性能问题的两方面原因：渲染速度慢、请求时间长。</p>
<p>合理地利用标签，可以在一定程度上提升渲染速度以及减少请求时间。</p>
<h1 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h1><h2 id="调整加载顺序提升渲染速度"><a href="#调整加载顺序提升渲染速度" class="headerlink" title="调整加载顺序提升渲染速度"></a>调整加载顺序提升渲染速度</h2><p>渲染引擎在解析HTML时，若遇到script标签引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至JavaScript引擎来执行对应代码，代码执行完成后切换至渲染引擎继续渲染页面。</p>
<h2 id="script标签的3个属性"><a href="#script标签的3个属性" class="headerlink" title="script标签的3个属性"></a>script标签的3个属性</h2><ul>
<li><p>async属性</p>
<p>立即请求文件，但不阻塞渲染属性，文件加载完毕后阻塞渲染引擎并立即执行文件内容。</p>
</li>
<li><p>defer属性</p>
<p>立即请求文件，但不阻塞渲染属性，等到解析完HTML之后再执行文件内容。</p>
</li>
<li><p>HTML5标准type属性</p>
<p>对应的值为module。</p>
<p>让浏览器按照ES6标准将文件当作模块进行解析，默认阻塞效果同defer，也可以配合async在请求完成后立即执行。</p>
</li>
</ul>
<p><img src="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/image-20230319203320817.png" alt="image-20230319203320817"></p>
<p>当渲染引擎解析HTML遇到script标签引入文件时，会立即渲染一次。</p>
<p>构建工具会把编译好的引用JavaScript代码的script标签放入到body标签底部。当渲染引擎执行到body底部时会先将已解析的内容渲染出来，然后再去请求响应的JavaScript文件。</p>
<p>如果时内联脚本（不通过src引用外部脚本文件），渲染引擎不好渲染。</p>
<h1 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h1><h2 id="通过预处理提升渲染速度"><a href="#通过预处理提升渲染速度" class="headerlink" title="通过预处理提升渲染速度"></a>通过预处理提升渲染速度</h2><ul>
<li><p>dns-prefetch</p>
<p>当link标签的rel属性值为”dns-prefetch“时，浏览器会对某个域名预先进行DNS解析并缓存。当浏览器再访问同一域名的资源时，可以减少通过域名查询ip的过程，从而提升速度。</p>
</li>
<li><p>preconnect</p>
<p>让浏览器在一个HTTP请求正式发给服务器前预先执行一些操作，包括DNS解析、TLS协商、TCP握手，通过消除往返延迟来为用户节省时间。</p>
</li>
<li><p>prefetch&#x2F;preload</p>
<p>两个值都是让浏览器预先下载并缓存某个资源，但不同的是：prefetch可能会在浏览器忙时被忽略，而preload则是一定会被预先下载</p>
</li>
<li><p>prerender</p>
<p>浏览器不仅会加载资源，还会解析执行页面，进行预渲染。</p>
<p><img src="/2017/10/19/HTML%E4%B8%AD%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E6%A0%87%E7%AD%BE/image-20230319204750649.png" alt="image-20230319204750649"></p>
</li>
</ul>
<h1 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h1><h2 id="meta标签：提取关键信息"><a href="#meta标签：提取关键信息" class="headerlink" title="meta标签：提取关键信息"></a>meta标签：提取关键信息</h2><p>meta标签专门为搜索引擎设置一些描述信息，方便用户预览到搜索结果</p>
<p>在实际工作中，推荐使用一些关键字工具来挑选，比如Google trends、站长工具</p>
<h2 id="link标签：减少重复"><a href="#link标签：减少重复" class="headerlink" title="link标签：减少重复"></a>link标签：减少重复</h2><p>对于同一个页面会有多个网址，又或者存在某些重定向页面，比如：</p>
<p><a target="_blank" rel="noopener" href="https://xx.com/a.html">https://xx.com/a.html</a></p>
<p><a target="_blank" rel="noopener" href="https://xx.com/detail?id=a">https://xx.com/detail?id=a</a></p>
<p>可以使用link标签，避免搜索引擎抓取相同页面的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://xx.com/a.html&quot; rel=&quot;canonical&quot; &gt;</span><br></pre></td></tr></table></figure>

<p>合并网址的方式：比如使用站点地图，或者在HTTP请求响应头部添加rel&#x3D;”canonical”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/15/react-native/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/15/react-native/" class="post-title-link" itemprop="url">React Native</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-15 16:31:32" itemprop="dateCreated datePublished" datetime="2017-10-15T16:31:32+08:00">2017-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/08/24/read-react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/24/read-react/" class="post-title-link" itemprop="url">React</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-24 23:52:48" itemprop="dateCreated datePublished" datetime="2017-08-24T23:52:48+08:00">2017-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="node和npm"><a href="#node和npm" class="headerlink" title="node和npm"></a>node和npm</h3><ol>
<li><p>node	</p>
<p> node包管理器</p>
</li>
<li><p>npm</p>
<p> <code>npm install -g &lt;package&gt;</code> 安装全局包<br> <code>npm install &lt;package&gt;</code> 安装本地包</p>
<p> node包安装完后会保存在node_modules&#x2F;文件夹下，并且会添加到package.json中</p>
<p> <code>npm init -y</code> 创建npm项目和package.json文件</p>
<p> <code>npm install</code> 从依赖文件package.json中安装node包</p>
<p> <code>npm install --save-dev</code> –save-dev 标记该node包只是用作开发环境的一部分，并不会作为产品代码发布</p>
</li>
</ol>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="创建react项目"><a href="#创建react项目" class="headerlink" title="创建react项目"></a>创建react项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><h4 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;;</span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.reander(</span><br><span class="line">	&lt;App /&gt;,</span><br><span class="line">	document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">	module.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ShoppingList extends React.Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		&lt;div className=&quot;shopping-list&quot;&gt;</span><br><span class="line">			&lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">			&lt;ul&gt;</span><br><span class="line">				&lt;li&gt;Instagram&lt;/li&gt;</span><br><span class="line">				&lt;li&gt;WhatsApp&lt;/li&gt;</span><br><span class="line">				&lt;li&gt;Oculus&lt;/li&gt;</span><br><span class="line">			&lt;/ul&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用法： &lt;ShoppingList name=&quot;mark&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="函数定义组件"><a href="#函数定义组件" class="headerlink" title="函数定义组件"></a>函数定义组件</h4><p>为只有render方法的组件提供的一种简便的定义组件的方法。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Square(props) &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;button className=&quot;square&quot; onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">			&#123;props.value&#125;</span><br><span class="line">		&lt;/button&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化事件处理函数。这里把 <code>onClick=&#123; () =&gt; props.onClick() &#125;</code> 直接修改为 <code>onClick=&#123;props.onClick&#125;</code> ，注意不能写成 <code>onClick=&#123;props.onClick()&#125;</code>否则<code>porps.onClick</code>方法会在Square组件渲染时被直接触发而不是等到Board组件渲染完成时通过点击触发，又因为此时Board组件正在渲染中（即Board组件的render方法正在调用），又触发父组件onClick中调用setState()会再次调用render方法导致死循环。     </p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/2017/08/24/read-react/lifecycle.png" alt="生命周期">     </p>
<h4 id="正确使用state"><a href="#正确使用state" class="headerlink" title="正确使用state"></a>正确使用state</h4><p>构造函数是唯一能够初始化state的地方。</p>
<ul>
<li><p>不要直接更新状态，应当使用setState()</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Wrong，此代码不会重新渲染组件</span><br><span class="line">this.state.comment = &#x27;Hello&#x27;;</span><br><span class="line">// Correct</span><br><span class="line">this.setState(&#123;comment: &#x27;Hello&#x27;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>状态更新可能是异步的<br>  React可以将多个setState()调用合并成一个调用来提高性能。<br>  因为this.props和this.state可能是异步更新的，你不应该依靠它们的值来计算下一个状态。      </p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">	counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Correct</span><br><span class="line">this.setState((prevState, props) =&gt; &#123;</span><br><span class="line">	counter: prevState.counter + props.increment</span><br><span class="line">&#125;);</span><br><span class="line">// Correct</span><br><span class="line">this.setState(function(prevState, props) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		counter: prevState.counter + props.increment</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>状态更新合并</p>
<p>  当调用setState()时，React将提供的对象合并到当前状态。 </p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">	super(props);</span><br><span class="line">	this.state = &#123;</span><br><span class="line">		posts: [],</span><br><span class="line">		comments: []</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">	fetchPost().then(response =&gt; &#123;</span><br><span class="line">		this.setState(&#123;</span><br><span class="line">			posts: response.posts</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	fetchPost().then(response =&gt; &#123;</span><br><span class="line">		this.setState(&#123;</span><br><span class="line">			comments: response.comments</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里的合并是浅合并，也就是说this.setState({comments})完整保留了this.state.posts，但完全替换了this.state.comments。</p>
</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>React元素的事件处理和DOM元素的很相似。但是有一些语法上的不同：</p>
<ul>
<li>React事件绑定属性的命名采用驼峰式写法，而不是小写。   </li>
<li>如果采用JSX的语法需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素的写法）</li>
<li>在React中，不能使用返回false的方式阻止默认行为，必须明确使用preventDefault</li>
</ul>
<p>在React中，JSX回调函数中的this，类方法默认不会绑定this的。如果忘记绑定this.handleClick并把它传入onClick，当你调用这个函数的时候，this的值是undefined。<br>两种不用绑定this的方法，属性初始化器语法和箭头函数。      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		this.state = &#123;</span><br><span class="line">			isToggleOn: true</span><br><span class="line">		&#125;;</span><br><span class="line">		this.handleClick1 = this.handleClick1.bind(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick1() &#123;</span><br><span class="line">		this.setState((prevState) =&gt; &#123;</span><br><span class="line">			isToggleOn: !prevState.isToggleOn</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick2 = (e) =&gt; &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick3(e) &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;button onClick=&#123;this.handleClick1&#125;&gt;</span><br><span class="line">					&#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">				&lt;button onClick=&#123;this.handleClick2&#125;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">				&lt;button onClick=&#123;(e) =&gt; this.handleClick3(e)&#125;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;/button&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用箭头函数，每次Toggle渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。      </p>
<h4 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deleteRow(rowId, event) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="列表和keys"><a href="#列表和keys" class="headerlink" title="列表和keys"></a>列表和keys</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo) =&gt;</span><br><span class="line">  &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当元素没有确定的id时，你可以使用他的序列号索引index作为key。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo, index) =&gt;</span><br><span class="line">  &lt;li key=&#123;index&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作键值，因为这样做会导致性能的负面影响，还可能引起组件状态问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/21/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/21/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B/" class="post-title-link" itemprop="url">读《大型网站技术架构：核心原理与案例分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-21 14:10:13" itemprop="dateCreated datePublished" datetime="2017-06-21T14:10:13+08:00">2017-06-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="大型网站架构演化"><a href="#大型网站架构演化" class="headerlink" title="大型网站架构演化"></a>大型网站架构演化</h2><h3 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h3><h3 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h3><h4 id="初始阶段的网站架构"><a href="#初始阶段的网站架构" class="headerlink" title="初始阶段的网站架构"></a>初始阶段的网站架构</h4><h4 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h4><h4 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h4><h4 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h4><h4 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h4><h4 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h4><h4 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h4><h4 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h4><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><h4 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h4><h3 id="大型网站架构演化的价值观"><a href="#大型网站架构演化的价值观" class="headerlink" title="大型网站架构演化的价值观"></a>大型网站架构演化的价值观</h3><h4 id="大型网站架构技术的核心价值是随网站所需灵活应对"><a href="#大型网站架构技术的核心价值是随网站所需灵活应对" class="headerlink" title="大型网站架构技术的核心价值是随网站所需灵活应对"></a>大型网站架构技术的核心价值是随网站所需灵活应对</h4><h4 id="驱动大型网站技术发展的主要力量是网站的业务发展"><a href="#驱动大型网站技术发展的主要力量是网站的业务发展" class="headerlink" title="驱动大型网站技术发展的主要力量是网站的业务发展"></a>驱动大型网站技术发展的主要力量是网站的业务发展</h4><h3 id="网站架构设计误区"><a href="#网站架构设计误区" class="headerlink" title="网站架构设计误区"></a>网站架构设计误区</h3><h4 id="一味追随大公司的解决方案"><a href="#一味追随大公司的解决方案" class="headerlink" title="一味追随大公司的解决方案"></a>一味追随大公司的解决方案</h4><h4 id="为了技术而技术"><a href="#为了技术而技术" class="headerlink" title="为了技术而技术"></a>为了技术而技术</h4><h4 id="企图用技术解决所有问题"><a href="#企图用技术解决所有问题" class="headerlink" title="企图用技术解决所有问题"></a>企图用技术解决所有问题</h4><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h2><h3 id="网站架构模式"><a href="#网站架构模式" class="headerlink" title="网站架构模式"></a>网站架构模式</h3><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><h4 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h4><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><h3 id="架构模式在新浪微博的应用"><a href="#架构模式在新浪微博的应用" class="headerlink" title="架构模式在新浪微博的应用"></a>架构模式在新浪微博的应用</h3><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站核心架构要素"><a href="#大型网站核心架构要素" class="headerlink" title="大型网站核心架构要素"></a>大型网站核心架构要素</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="瞬间响应：网站的高性能架构"><a href="#瞬间响应：网站的高性能架构" class="headerlink" title="瞬间响应：网站的高性能架构"></a>瞬间响应：网站的高性能架构</h2><h3 id="网站性能测试"><a href="#网站性能测试" class="headerlink" title="网站性能测试"></a>网站性能测试</h3><h4 id="不同视角下的网站性能"><a href="#不同视角下的网站性能" class="headerlink" title="不同视角下的网站性能"></a>不同视角下的网站性能</h4><h4 id="性能测试指标"><a href="#性能测试指标" class="headerlink" title="性能测试指标"></a>性能测试指标</h4><h4 id="性能测试方法"><a href="#性能测试方法" class="headerlink" title="性能测试方法"></a>性能测试方法</h4><h4 id="性能测试报告"><a href="#性能测试报告" class="headerlink" title="性能测试报告"></a>性能测试报告</h4><h4 id="性能测试策略"><a href="#性能测试策略" class="headerlink" title="性能测试策略"></a>性能测试策略</h4><h3 id="Web前端性能优化"><a href="#Web前端性能优化" class="headerlink" title="Web前端性能优化"></a>Web前端性能优化</h3><h4 id="浏览器访问优化"><a href="#浏览器访问优化" class="headerlink" title="浏览器访问优化"></a>浏览器访问优化</h4><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><h3 id="应用服务器性能优化"><a href="#应用服务器性能优化" class="headerlink" title="应用服务器性能优化"></a>应用服务器性能优化</h3><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><h4 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h4><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><h3 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h3><h4 id="机械硬盘-vs-固态硬盘"><a href="#机械硬盘-vs-固态硬盘" class="headerlink" title="机械硬盘 vs 固态硬盘"></a>机械硬盘 vs 固态硬盘</h4><h4 id="B-树-vs-LSM树"><a href="#B-树-vs-LSM树" class="headerlink" title="B+树 vs LSM树"></a>B+树 vs LSM树</h4><h4 id="RAID-vs-HDFS"><a href="#RAID-vs-HDFS" class="headerlink" title="RAID vs HDFS"></a>RAID vs HDFS</h4><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><h2 id="万无一失：网站的高可用框架"><a href="#万无一失：网站的高可用框架" class="headerlink" title="万无一失：网站的高可用框架"></a>万无一失：网站的高可用框架</h2><h3 id="网站可用性的度量与考核"><a href="#网站可用性的度量与考核" class="headerlink" title="网站可用性的度量与考核"></a>网站可用性的度量与考核</h3><h4 id="网站可用性度量"><a href="#网站可用性度量" class="headerlink" title="网站可用性度量"></a>网站可用性度量</h4><h4 id="网站可用性考核"><a href="#网站可用性考核" class="headerlink" title="网站可用性考核"></a>网站可用性考核</h4><h3 id="高可用的网站架构"><a href="#高可用的网站架构" class="headerlink" title="高可用的网站架构"></a>高可用的网站架构</h3><h3 id="高可用的应用"><a href="#高可用的应用" class="headerlink" title="高可用的应用"></a>高可用的应用</h3><h4 id="通过负载均衡进行无状态服务的失效转移"><a href="#通过负载均衡进行无状态服务的失效转移" class="headerlink" title="通过负载均衡进行无状态服务的失效转移"></a>通过负载均衡进行无状态服务的失效转移</h4><h4 id="应用服务器集群的Session管理"><a href="#应用服务器集群的Session管理" class="headerlink" title="应用服务器集群的Session管理"></a>应用服务器集群的Session管理</h4><h3 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h3><h3 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h3><h4 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h4><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h4 id="失效转移"><a href="#失效转移" class="headerlink" title="失效转移"></a>失效转移</h4><h3 id="高可用网站的软件质量保证"><a href="#高可用网站的软件质量保证" class="headerlink" title="高可用网站的软件质量保证"></a>高可用网站的软件质量保证</h3><h4 id="网站发布"><a href="#网站发布" class="headerlink" title="网站发布"></a>网站发布</h4><h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><h4 id="预发布验证"><a href="#预发布验证" class="headerlink" title="预发布验证"></a>预发布验证</h4><h4 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h4><h4 id="自动化发布"><a href="#自动化发布" class="headerlink" title="自动化发布"></a>自动化发布</h4><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><h3 id="网站运行监控"><a href="#网站运行监控" class="headerlink" title="网站运行监控"></a>网站运行监控</h3><h4 id="监控数据采集"><a href="#监控数据采集" class="headerlink" title="监控数据采集"></a>监控数据采集</h4><h4 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h4><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><h2 id="永无止境：网站的伸缩性架构"><a href="#永无止境：网站的伸缩性架构" class="headerlink" title="永无止境：网站的伸缩性架构"></a>永无止境：网站的伸缩性架构</h2><h3 id="网站架构的伸缩性设计"><a href="#网站架构的伸缩性设计" class="headerlink" title="网站架构的伸缩性设计"></a>网站架构的伸缩性设计</h3><h4 id="不同功能进行物理分离实现伸缩"><a href="#不同功能进行物理分离实现伸缩" class="headerlink" title="不同功能进行物理分离实现伸缩"></a>不同功能进行物理分离实现伸缩</h4><h4 id="单一功能通过集群规模实现伸缩"><a href="#单一功能通过集群规模实现伸缩" class="headerlink" title="单一功能通过集群规模实现伸缩"></a>单一功能通过集群规模实现伸缩</h4><h3 id="应用服务器集群的伸缩性设计"><a href="#应用服务器集群的伸缩性设计" class="headerlink" title="应用服务器集群的伸缩性设计"></a>应用服务器集群的伸缩性设计</h3><h4 id="HTTP重定向负载均衡"><a href="#HTTP重定向负载均衡" class="headerlink" title="HTTP重定向负载均衡"></a>HTTP重定向负载均衡</h4><h4 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h4><h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><h4 id="IP负载均衡"><a href="#IP负载均衡" class="headerlink" title="IP负载均衡"></a>IP负载均衡</h4><h4 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h4><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><h3 id="分布式缓存集群的伸缩性设计"><a href="#分布式缓存集群的伸缩性设计" class="headerlink" title="分布式缓存集群的伸缩性设计"></a>分布式缓存集群的伸缩性设计</h3><h4 id="Memcached分布式缓存集群的访问模型"><a href="#Memcached分布式缓存集群的访问模型" class="headerlink" title="Memcached分布式缓存集群的访问模型"></a>Memcached分布式缓存集群的访问模型</h4><h4 id="Memcached分布式缓存集群的伸缩性挑战"><a href="#Memcached分布式缓存集群的伸缩性挑战" class="headerlink" title="Memcached分布式缓存集群的伸缩性挑战"></a>Memcached分布式缓存集群的伸缩性挑战</h4><h4 id="分布式缓存的一致性Hash算法"><a href="#分布式缓存的一致性Hash算法" class="headerlink" title="分布式缓存的一致性Hash算法"></a>分布式缓存的一致性Hash算法</h4><h3 id="数据存储服务器集群的伸缩性设计"><a href="#数据存储服务器集群的伸缩性设计" class="headerlink" title="数据存储服务器集群的伸缩性设计"></a>数据存储服务器集群的伸缩性设计</h3><h4 id="关系数据库集群的伸缩性设计"><a href="#关系数据库集群的伸缩性设计" class="headerlink" title="关系数据库集群的伸缩性设计"></a>关系数据库集群的伸缩性设计</h4><h4 id="NoSQL数据库的伸缩性设计"><a href="#NoSQL数据库的伸缩性设计" class="headerlink" title="NoSQL数据库的伸缩性设计"></a>NoSQL数据库的伸缩性设计</h4><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><h2 id="随需应变：网站的可扩展架构"><a href="#随需应变：网站的可扩展架构" class="headerlink" title="随需应变：网站的可扩展架构"></a>随需应变：网站的可扩展架构</h2><h3 id="构建可扩展的网站架构"><a href="#构建可扩展的网站架构" class="headerlink" title="构建可扩展的网站架构"></a>构建可扩展的网站架构</h3><h3 id="利用分布式消息队列降低系统耦合性"><a href="#利用分布式消息队列降低系统耦合性" class="headerlink" title="利用分布式消息队列降低系统耦合性"></a>利用分布式消息队列降低系统耦合性</h3><h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><h3 id="利用分布式服务打造可复用的业务平台"><a href="#利用分布式服务打造可复用的业务平台" class="headerlink" title="利用分布式服务打造可复用的业务平台"></a>利用分布式服务打造可复用的业务平台</h3><h4 id="Web-Service-与企业级分布式服务"><a href="#Web-Service-与企业级分布式服务" class="headerlink" title="Web Service 与企业级分布式服务"></a>Web Service 与企业级分布式服务</h4><h4 id="大型网站分布式服务的需求与特点"><a href="#大型网站分布式服务的需求与特点" class="headerlink" title="大型网站分布式服务的需求与特点"></a>大型网站分布式服务的需求与特点</h4><h4 id="分布式服务框架设计"><a href="#分布式服务框架设计" class="headerlink" title="分布式服务框架设计"></a>分布式服务框架设计</h4><h3 id="可扩展的数据结构"><a href="#可扩展的数据结构" class="headerlink" title="可扩展的数据结构"></a>可扩展的数据结构</h3><h3 id="利用开放平台建设网站生态圈"><a href="#利用开放平台建设网站生态圈" class="headerlink" title="利用开放平台建设网站生态圈"></a>利用开放平台建设网站生态圈</h3><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><h2 id="固若金汤：网站的安全架构"><a href="#固若金汤：网站的安全架构" class="headerlink" title="固若金汤：网站的安全架构"></a>固若金汤：网站的安全架构</h2><h3 id="道高一尺魔高一丈的网站应用攻击与防御"><a href="#道高一尺魔高一丈的网站应用攻击与防御" class="headerlink" title="道高一尺魔高一丈的网站应用攻击与防御"></a>道高一尺魔高一丈的网站应用攻击与防御</h3><h4 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h4><h4 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h4><h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><h4 id="其他攻击和漏洞"><a href="#其他攻击和漏洞" class="headerlink" title="其他攻击和漏洞"></a>其他攻击和漏洞</h4><h4 id="Web应用防火墙"><a href="#Web应用防火墙" class="headerlink" title="Web应用防火墙"></a>Web应用防火墙</h4><h4 id="网站安全漏铜扫描"><a href="#网站安全漏铜扫描" class="headerlink" title="网站安全漏铜扫描"></a>网站安全漏铜扫描</h4><h3 id="信息加密技术及密钥安全管理"><a href="#信息加密技术及密钥安全管理" class="headerlink" title="信息加密技术及密钥安全管理"></a>信息加密技术及密钥安全管理</h3><h4 id="单向三列加密"><a href="#单向三列加密" class="headerlink" title="单向三列加密"></a>单向三列加密</h4><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><h4 id="密钥安全管理"><a href="#密钥安全管理" class="headerlink" title="密钥安全管理"></a>密钥安全管理</h4><h3 id="信息过滤与反垃圾"><a href="#信息过滤与反垃圾" class="headerlink" title="信息过滤与反垃圾"></a>信息过滤与反垃圾</h3><h4 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h4><h4 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h4><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><h3 id="电子商务风险控制"><a href="#电子商务风险控制" class="headerlink" title="电子商务风险控制"></a>电子商务风险控制</h3><h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><h4 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h4><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="淘宝网的架构演化案例分析"><a href="#淘宝网的架构演化案例分析" class="headerlink" title="淘宝网的架构演化案例分析"></a>淘宝网的架构演化案例分析</h2><h3 id="淘宝网的业务发展历程"><a href="#淘宝网的业务发展历程" class="headerlink" title="淘宝网的业务发展历程"></a>淘宝网的业务发展历程</h3><h3 id="淘宝网技术架构演化"><a href="#淘宝网技术架构演化" class="headerlink" title="淘宝网技术架构演化"></a>淘宝网技术架构演化</h3><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><h2 id="维基百科的高性能架构设计分析"><a href="#维基百科的高性能架构设计分析" class="headerlink" title="维基百科的高性能架构设计分析"></a>维基百科的高性能架构设计分析</h2><h3 id="Wikipedia-网站整体架构"><a href="#Wikipedia-网站整体架构" class="headerlink" title="Wikipedia 网站整体架构"></a>Wikipedia 网站整体架构</h3><h3 id="Wikipedia-性能优化策略"><a href="#Wikipedia-性能优化策略" class="headerlink" title="Wikipedia 性能优化策略"></a>Wikipedia 性能优化策略</h3><h4 id="Wikipedia-前端性能优化"><a href="#Wikipedia-前端性能优化" class="headerlink" title="Wikipedia 前端性能优化"></a>Wikipedia 前端性能优化</h4><h4 id="Wikipedia-服务端性能优化"><a href="#Wikipedia-服务端性能优化" class="headerlink" title="Wikipedia 服务端性能优化"></a>Wikipedia 服务端性能优化</h4><h4 id="Wikipedia-后端性能优化"><a href="#Wikipedia-后端性能优化" class="headerlink" title="Wikipedia 后端性能优化"></a>Wikipedia 后端性能优化</h4><h2 id="海量分布式存储系统Doris的高可用架构设计分析"><a href="#海量分布式存储系统Doris的高可用架构设计分析" class="headerlink" title="海量分布式存储系统Doris的高可用架构设计分析"></a>海量分布式存储系统Doris的高可用架构设计分析</h2><h3 id="分布式存储系统的高可用架构"><a href="#分布式存储系统的高可用架构" class="headerlink" title="分布式存储系统的高可用架构"></a>分布式存储系统的高可用架构</h3><h3 id="不同故障情况下的高可用解决方案"><a href="#不同故障情况下的高可用解决方案" class="headerlink" title="不同故障情况下的高可用解决方案"></a>不同故障情况下的高可用解决方案</h3><h4 id="分布式存储系统的故障分类"><a href="#分布式存储系统的故障分类" class="headerlink" title="分布式存储系统的故障分类"></a>分布式存储系统的故障分类</h4><h4 id="正常情况下系统访问结构"><a href="#正常情况下系统访问结构" class="headerlink" title="正常情况下系统访问结构"></a>正常情况下系统访问结构</h4><h4 id="瞬时故障的高可用解决方案"><a href="#瞬时故障的高可用解决方案" class="headerlink" title="瞬时故障的高可用解决方案"></a>瞬时故障的高可用解决方案</h4><h4 id="临时故障的高可用解决方案"><a href="#临时故障的高可用解决方案" class="headerlink" title="临时故障的高可用解决方案"></a>临时故障的高可用解决方案</h4><h4 id="永久故障的高可用解决方案"><a href="#永久故障的高可用解决方案" class="headerlink" title="永久故障的高可用解决方案"></a>永久故障的高可用解决方案</h4><h2 id="网购秒杀系统架构设计案例分析"><a href="#网购秒杀系统架构设计案例分析" class="headerlink" title="网购秒杀系统架构设计案例分析"></a>网购秒杀系统架构设计案例分析</h2><h3 id="秒杀活动的技术挑战"><a href="#秒杀活动的技术挑战" class="headerlink" title="秒杀活动的技术挑战"></a>秒杀活动的技术挑战</h3><h3 id="秒杀系统的应对策略"><a href="#秒杀系统的应对策略" class="headerlink" title="秒杀系统的应对策略"></a>秒杀系统的应对策略</h3><h3 id="秒杀系统架构设计"><a href="#秒杀系统架构设计" class="headerlink" title="秒杀系统架构设计"></a>秒杀系统架构设计</h3><h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站典型故障案例分析"><a href="#大型网站典型故障案例分析" class="headerlink" title="大型网站典型故障案例分析"></a>大型网站典型故障案例分析</h2><h3 id="写日志也会引发故障"><a href="#写日志也会引发故障" class="headerlink" title="写日志也会引发故障"></a>写日志也会引发故障</h3><h3 id="高并发访问数据库引发的故障"><a href="#高并发访问数据库引发的故障" class="headerlink" title="高并发访问数据库引发的故障"></a>高并发访问数据库引发的故障</h3><h3 id="高并发情况下锁引发的故障"><a href="#高并发情况下锁引发的故障" class="headerlink" title="高并发情况下锁引发的故障"></a>高并发情况下锁引发的故障</h3><h3 id="缓存引发的故障"><a href="#缓存引发的故障" class="headerlink" title="缓存引发的故障"></a>缓存引发的故障</h3><h3 id="应用启动不同步引发的故障"><a href="#应用启动不同步引发的故障" class="headerlink" title="应用启动不同步引发的故障"></a>应用启动不同步引发的故障</h3><h3 id="大文件读写独占磁盘引发的故障"><a href="#大文件读写独占磁盘引发的故障" class="headerlink" title="大文件读写独占磁盘引发的故障"></a>大文件读写独占磁盘引发的故障</h3><h3 id="滥用生产环境引发的故障"><a href="#滥用生产环境引发的故障" class="headerlink" title="滥用生产环境引发的故障"></a>滥用生产环境引发的故障</h3><h3 id="不规范的流程引发的故障"><a href="#不规范的流程引发的故障" class="headerlink" title="不规范的流程引发的故障"></a>不规范的流程引发的故障</h3><h3 id="不好的编程习惯引发的故障"><a href="#不好的编程习惯引发的故障" class="headerlink" title="不好的编程习惯引发的故障"></a>不好的编程习惯引发的故障</h3><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><h1 id="架构师"><a href="#架构师" class="headerlink" title="架构师"></a>架构师</h1><h2 id="架构师领导艺术"><a href="#架构师领导艺术" class="headerlink" title="架构师领导艺术"></a>架构师领导艺术</h2><h3 id="关注人而不是产品"><a href="#关注人而不是产品" class="headerlink" title="关注人而不是产品"></a>关注人而不是产品</h3><h3 id="发掘人的优秀"><a href="#发掘人的优秀" class="headerlink" title="发掘人的优秀"></a>发掘人的优秀</h3><h3 id="共享美好蓝图"><a href="#共享美好蓝图" class="headerlink" title="共享美好蓝图"></a>共享美好蓝图</h3><h3 id="共同参与架构"><a href="#共同参与架构" class="headerlink" title="共同参与架构"></a>共同参与架构</h3><h3 id="学会妥协"><a href="#学会妥协" class="headerlink" title="学会妥协"></a>学会妥协</h3><h3 id="成就他人"><a href="#成就他人" class="headerlink" title="成就他人"></a>成就他人</h3><h2 id="网站架构师职场攻略"><a href="#网站架构师职场攻略" class="headerlink" title="网站架构师职场攻略"></a>网站架构师职场攻略</h2><h3 id="发现问题，寻找突破"><a href="#发现问题，寻找突破" class="headerlink" title="发现问题，寻找突破"></a>发现问题，寻找突破</h3><h3 id="提出问题，寻求支持"><a href="#提出问题，寻求支持" class="headerlink" title="提出问题，寻求支持"></a>提出问题，寻求支持</h3><h3 id="解决问题，达成绩效"><a href="#解决问题，达成绩效" class="headerlink" title="解决问题，达成绩效"></a>解决问题，达成绩效</h3><h2 id="漫话网站架构师"><a href="#漫话网站架构师" class="headerlink" title="漫话网站架构师"></a>漫话网站架构师</h2><h3 id="按作用划分架构师"><a href="#按作用划分架构师" class="headerlink" title="按作用划分架构师"></a>按作用划分架构师</h3><h3 id="按效果划分架构师"><a href="#按效果划分架构师" class="headerlink" title="按效果划分架构师"></a>按效果划分架构师</h3><h3 id="按职责角色划分架构师"><a href="#按职责角色划分架构师" class="headerlink" title="按职责角色划分架构师"></a>按职责角色划分架构师</h3><h3 id="安关注层次划分架构师"><a href="#安关注层次划分架构师" class="headerlink" title="安关注层次划分架构师"></a>安关注层次划分架构师</h3><h3 id="安关注层次划分架构师-1"><a href="#安关注层次划分架构师-1" class="headerlink" title="安关注层次划分架构师"></a>安关注层次划分架构师</h3><h3 id="安口碑划分架构师"><a href="#安口碑划分架构师" class="headerlink" title="安口碑划分架构师"></a>安口碑划分架构师</h3><h3 id="非主流方式划分架构师"><a href="#非主流方式划分架构师" class="headerlink" title="非主流方式划分架构师"></a>非主流方式划分架构师</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fhclk"
      src="/images/avatar1.png">
  <p class="site-author-name" itemprop="name">fhclk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fhclk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fhclk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fhclk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
</body>
</html>
