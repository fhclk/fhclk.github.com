<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fhclk.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="拾荒者">
<meta property="og:url" content="http://fhclk.github.io/page/5/index.html">
<meta property="og:site_name" content="拾荒者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fhclk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fhclk.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>拾荒者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拾荒者</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">昨夜西风凋碧树，独上高楼，望尽天涯路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/03/JavaScript%E4%B8%AD%E7%9A%84this%E3%80%81call%E5%92%8Capply/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/03/JavaScript%E4%B8%AD%E7%9A%84this%E3%80%81call%E5%92%8Capply/" class="post-title-link" itemprop="url">JavaScript中的this、call和apply</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-03 16:13:48" itemprop="dateCreated datePublished" datetime="2017-06-03T16:13:48+08:00">2017-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-04 16:00:22" itemprop="dateModified" datetime="2019-06-04T16:00:22+08:00">2019-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。      </p>
<h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4中：</p>
<ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li>Function.prototype.call或Function.prototype.apply调用</li>
</ul>
<h5 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h5><p>当作为对象的方法被调用时，this指向该对象。      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var obj = &#123;</span><br><span class="line">... a: 1,</span><br><span class="line">... getA: function() &#123;</span><br><span class="line">..... console.log(this === obj);</span><br><span class="line">..... console.log(this.a);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.getA()</span><br><span class="line">true</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的this总是指向全局对象。在浏览器的JavaScript中，这个全局对象是window对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">window.name = &quot;globalName&quot;;</span><br><span class="line">var getName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getName());</span><br><span class="line"></span><br><span class="line">var myObj = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;,</span><br><span class="line">	getName: function() &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getName1 = myObj.getName;</span><br><span class="line">console.log(getName1());</span><br><span class="line">console.log(myObj.getName());</span><br><span class="line"></span><br><span class="line">//	输出</span><br><span class="line">//	globalName</span><br><span class="line">//	globalName</span><br><span class="line">// 	sven</span><br></pre></td></tr></table></figure>

<p>有种情况，比如在div节点的事件函数内部，有个局部的callback方法，callback被视为普通函数调用，callback内部的this指向了window，但我们往往是想让它指向该div节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;this is a div&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	window.id = &#x27;window&#x27;;</span><br><span class="line">	document.getElementById(&#x27;div1&#x27;).onclick = function() &#123;</span><br><span class="line">		alert(this.id);   //div1</span><br><span class="line">		var callback = function() &#123;</span><br><span class="line">			alert(this.id);   //window</span><br><span class="line">		&#125;</span><br><span class="line">		callback();</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>一种简单的解决方案，可以用一个变量保存div节点的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#x27;div1&#x27;).onclick = function() &#123;</span><br><span class="line">	alert(this.id);   //div1</span><br><span class="line">	var that = this;</span><br><span class="line">	var callback = function() &#123;</span><br><span class="line">		alert(that.id);   //window</span><br><span class="line">	&#125;</span><br><span class="line">	callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">	&quot;use strict&quot;</span><br><span class="line">	alert(this);    //undefined</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h5 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h5><p>JavaScript中没有类，但是可以从构造器中创建对象，同时也提供了new运算符，使得构造器看起来更像一个类。<br>除了宿主提供的一些内置函数，大部分JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass = function() &#123;</span><br><span class="line">... this.name = &#x27;sven&#x27;;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj = new MyClass();</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#x27;sven&#x27;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass = function() &#123;</span><br><span class="line">... this.name = &#x27;sven&#x27;;</span><br><span class="line">... return &#123;</span><br><span class="line">..... name: &#x27;anne&#x27;,</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj = new MyClass();</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#x27;anne&#x27;</span><br></pre></td></tr></table></figure>

<p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass = function() &#123;</span><br><span class="line">... this.name = &#x27;sven&#x27;;</span><br><span class="line">... return &#x27;anne&#x27;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj = new MyClass()</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#x27;sven&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="Function-prototype-call或Function-prototype-apply调用"><a href="#Function-prototype-call或Function-prototype-apply调用" class="headerlink" title="Function.prototype.call或Function.prototype.apply调用"></a>Function.prototype.call或Function.prototype.apply调用</h5><p>跟普通的函数调用相比，用Function.prototype.call或Function.prototype.apply可以动态地改变传入函数的this。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; var obj1 = &#123;</span><br><span class="line">... name: &#x27;sven&#x27;,</span><br><span class="line">... getName: function() &#123;</span><br><span class="line">..... return this.name;</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj2 = &#123;</span><br><span class="line">... name: &#x27;anne&#x27;,</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; obj1.getName()</span><br><span class="line">&#x27;sven&#x27;</span><br><span class="line">&gt; obj1.getName.call(obj2)</span><br><span class="line">&#x27;anne&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><h5 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h5><p>它们的作用一模一样，区别仅在于传入参数形式的不同。<br>apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以是类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; var func = function(a,b,c) &#123;</span><br><span class="line">... console.log([a,b,c])</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; func.apply(null, [1,2,3])</span><br><span class="line">[ 1, 2, 3 ]</span><br><span class="line">undefined</span><br><span class="line">//参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列 表中的 a、b、c</span><br><span class="line">&gt; func.apply(null, 1,2,3)</span><br><span class="line">TypeError: CreateListFromArrayLike called on non-object</span><br></pre></td></tr></table></figure>

<p>call是包装在apply上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call来传送参数。<br>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a,b,c) &#123;</span><br><span class="line">	console.log(a,b,c);</span><br><span class="line">	alert(this === window);   //true</span><br><span class="line">&#125;</span><br><span class="line">func.apply(null, [1,2,3]);</span><br></pre></td></tr></table></figure>

<p>但如果是在严格模式下，函数体内的 this 还是为 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var func = function(a,b,c) &#123;</span><br><span class="line">	&quot;use strict&quot;</span><br><span class="line">	console.log(a,b,c)</span><br><span class="line">	console.log(this === window);</span><br><span class="line">	console.log(this === null);</span><br><span class="line">&#125;</span><br><span class="line">func.apply(null, [1,2,3])</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">1 2 3</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.max.apply(null,[1,23,5,2,3,6])</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<h4 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h4><h5 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h5><p>场景一：      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">	name: &#x27;anne&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">window.name = &#x27;window&#x27;;</span><br><span class="line">var getName = function() &#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line">getName.call(obj1);</span><br><span class="line">getName.call(obj2);</span><br><span class="line">//输出</span><br><span class="line">window</span><br><span class="line">sven</span><br><span class="line">anne</span><br></pre></td></tr></table></figure>

<p>场景二：在div事件中的内部函数中，修正this        </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#x27;div1&#x27;).onclick = function() &#123;</span><br><span class="line">	console.log(this.id);</span><br><span class="line">	var func = function() &#123;</span><br><span class="line">		console.log(&#x27;id:&#x27; + this.id);</span><br><span class="line">	&#125;</span><br><span class="line">	func();</span><br><span class="line">	func.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">div1</span><br><span class="line">id:undefined</span><br><span class="line">id:div1</span><br></pre></td></tr></table></figure>

<h5 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h5><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向，即使没有原生的Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(context) &#123;</span><br><span class="line">	var self = this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return self.apply(context, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var func = function() &#123;</span><br><span class="line">	alert(this.name);    //输出sven</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>带有参数的Function.prototype.bind</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function() &#123;</span><br><span class="line">	var self = this;   //保存原函数</span><br><span class="line">	var context = [].shift.call(arguments);  //需要绑定的this上下文</span><br><span class="line">	var args = [].slice.call(arguments);  //剩余的参数转成数组</span><br><span class="line">	return function() &#123;  //返回一个新函数</span><br><span class="line">		return self.apply(context, [].concat.call(args, [].slice.call(arguments)));</span><br><span class="line">		//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span><br><span class="line">		//并且组合两次分别传入的参数，作为新函数的参数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &#x27;sven&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">var func = function(a,b,c,d) &#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">	console.log([a,b,c,d]);</span><br><span class="line">&#125;.bind(obj, 1,2);</span><br><span class="line">func(3, 4);</span><br><span class="line">//输出</span><br><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h5 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var A = function(name) &#123;</span><br><span class="line">	this.name = name</span><br><span class="line">&#125;</span><br><span class="line">var B = function() &#123;</span><br><span class="line">	A.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.getName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var b = new B(&#x27;sven&#x27;);</span><br><span class="line">console.log(b.getName());</span><br><span class="line">//输出</span><br><span class="line">sven</span><br></pre></td></tr></table></figure>

<p>另一种常用的场景。<br>函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组， 所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常 会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用 Array.prototype.push:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">	Array.prototype.push.call(arguments, 3);</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;)(1,2)</span><br><span class="line">//输出</span><br><span class="line">Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></table></figure>

<p>我们可以把“任意”对象传入 Array.prototype.push。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Array.prototype.push.call(a, &#x27;first&#x27;)</span><br><span class="line">1</span><br><span class="line">&gt; a.length</span><br><span class="line">1</span><br><span class="line">&gt; a[0]</span><br><span class="line">&#x27;first&#x27;</span><br><span class="line">&gt; typeof a</span><br><span class="line">&#x27;object&#x27;</span><br></pre></td></tr></table></figure>

<p>这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版 本的 IE 浏览器中执行，必须显式地给对象 a 设置length 属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123; </span><br><span class="line">	length: 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面我们之所以把“任意”两字加了双引号，是因为可以借用 Array.prototype.push 方法的对象还要满足以下两个条件</p>
<ol>
<li>对象本身要可以存取属性;</li>
<li>对象的 length 属性可读写。</li>
</ol>
<p>注：函数对象的length属性是只读属性，并不满足要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; var func = function()&#123;&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Array.prototype.push.call(func, &#x27;first&#x27;)</span><br><span class="line">TypeError: Cannot assign to read only property &#x27;length&#x27; of function &#x27;function()&#123;&#125;&#x27;</span><br><span class="line">    at Function.push (&lt;anonymous&gt;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/01/13/IONIC3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/13/IONIC3/" class="post-title-link" itemprop="url">Ionic3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-13 14:57:58" itemprop="dateCreated datePublished" datetime="2017-01-13T14:57:58+08:00">2017-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-26 14:53:44" itemprop="dateModified" datetime="2019-01-26T14:53:44+08:00">2019-01-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="官网文档"><a href="#官网文档" class="headerlink" title="官网文档"></a>官网文档</h3><p><a target="_blank" rel="noopener" href="https://ionicframework.com/docs/">Ionic Framework</a><br><a target="_blank" rel="noopener" href="https://ionicframework.com/docs/v3/">Ionic3</a></p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/7222ddf1ce84">IonicBlog</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1baf40713c1c">ionic3 教程</a>    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/12/21/angular4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/21/angular4/" class="post-title-link" itemprop="url">angular4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-21 09:58:38" itemprop="dateCreated datePublished" datetime="2016-12-21T09:58:38+08:00">2016-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-30 14:11:12" itemprop="dateModified" datetime="2019-01-30T14:11:12+08:00">2019-01-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="学习教程"><a href="#学习教程" class="headerlink" title="学习教程"></a>学习教程</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008754631">Angular 4.x 修仙之路</a><br><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/home.html">TypeScript</a>    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/11/17/JavaScript4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/17/JavaScript4/" class="post-title-link" itemprop="url">JavaScript（ES6）4  --日期和时间、数学运算、正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-17 09:48:02" itemprop="dateCreated datePublished" datetime="2016-11-17T09:48:02+08:00">2016-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-18 17:55:38" itemprop="dateModified" datetime="2019-02-18T17:55:38+08:00">2019-02-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><h4 id="构造Date对象"><a href="#构造Date对象" class="headerlink" title="构造Date对象"></a>构造Date对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; new Date()   //当前日期</span><br><span class="line">Sun Feb 17 2019 09:56:01 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">//在JavaScript中，月份是从0开始的。 0=1月</span><br><span class="line">&gt; new Date(2015, 0)</span><br><span class="line">Thu Jan 01 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14)</span><br><span class="line">Sat Feb 14 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13)</span><br><span class="line">Sat Feb 14 2015 13:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13, 30)</span><br><span class="line">Sat Feb 14 2015 13:30:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13, 30, 5);</span><br><span class="line">Sat Feb 14 2015 13:30:05 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(2015, 1, 14, 13, 30, 5, 500);</span><br><span class="line">Sat Feb 14 2015 13:30:05 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">//传入毫秒数</span><br><span class="line">&gt; new Date(0)</span><br><span class="line">Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(1000)</span><br><span class="line">Thu Jan 01 1970 08:00:01 GMT+0800 (中国标准时间)</span><br><span class="line">&gt; new Date(1463443200000)</span><br><span class="line">Tue May 17 2016 08:00:00 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>
<p>在JavaScript内部，时间都是以UTC存储的，然后根据当地时间（有计算机操作系统决定）进行格式化。</p>
<h4 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h4><p>Moment.js库有两个版本：一种支持时区，一种不支持。由于支持时区的版本很大（它包含全世界所有的时区信息），日常工作中可以选择不支持时区的版本。</p>
<h5 id="引用Moment-js的方式"><a href="#引用Moment-js的方式" class="headerlink" title="引用Moment.js的方式"></a>引用Moment.js的方式</h5><p><a target="_blank" rel="noopener" href="http://momentjs.cn/">Moment.js中文文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// html文件中引用</span><br><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// Node中，npm 安装</span><br><span class="line">npm install -save moment-timezone</span><br><span class="line">const moment = require(&#x27;moment-timezone&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="日期的组成"><a href="#日期的组成" class="headerlink" title="日期的组成"></a>日期的组成</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; const d = new Date(Date.UTC(1815,9,10))</span><br><span class="line">undefined</span><br><span class="line">&gt; d</span><br><span class="line">1815-10-10T00:00:00.000Z</span><br><span class="line">&gt; d.getFullYear()</span><br><span class="line">1815</span><br><span class="line">&gt; d.getMonth()</span><br><span class="line">9</span><br><span class="line">&gt; d.getDate()</span><br><span class="line">10</span><br><span class="line">&gt; d.getDay()</span><br><span class="line">2</span><br><span class="line">&gt; d.getHours()</span><br><span class="line">8</span><br><span class="line">&gt; d.getMinutes()</span><br><span class="line">0</span><br><span class="line">&gt; d.getSeconds()</span><br><span class="line">0</span><br><span class="line">&gt; d.getMilliseconds()</span><br><span class="line">0</span><br><span class="line">&gt; d.getUTCFullYear()</span><br><span class="line">1815</span><br><span class="line">&gt; d.getUTCMounth()</span><br><span class="line">TypeError: d.getUTCMounth is not a function</span><br><span class="line">&gt; d.getUTCMonth()</span><br><span class="line">9</span><br><span class="line">&gt; d.getUTCDate()</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h5 id="日期的比较"><a href="#日期的比较" class="headerlink" title="日期的比较"></a>日期的比较</h5><p>简单的日期比较，如日期A和日期B谁在前谁在后？可以使用JavaScript内建的比较运算符。因为Date实例是以数值存储日期的，所以比较运算符比较的是它们的数值大小。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; const d1 = new Date(1996, 2, 1)</span><br><span class="line">undefined</span><br><span class="line">&gt; const d2 = new Date(2009, 4, 27)</span><br><span class="line">undefined</span><br><span class="line">&gt; d1 &gt; d2</span><br><span class="line">false</span><br><span class="line">&gt; d2 &gt; d1</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h5 id="日期的四则运算"><a href="#日期的四则运算" class="headerlink" title="日期的四则运算"></a>日期的四则运算</h5><p>因为日期只是一些数字，所以可以将日期相减从而获取它们相差的毫秒数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; const d1 = new Date(1996, 2, 1)</span><br><span class="line">undefined</span><br><span class="line">&gt; const d2 = new Date(2009, 4, 27)</span><br><span class="line">undefined</span><br><span class="line">&gt; d1 - d2</span><br><span class="line">-417744000000</span><br><span class="line">&gt; d2 - d1</span><br><span class="line">417744000000</span><br></pre></td></tr></table></figure>

<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="格式化数字"><a href="#格式化数字" class="headerlink" title="格式化数字"></a>格式化数字</h3><h5 id="固定小数"><a href="#固定小数" class="headerlink" title="固定小数"></a>固定小数</h5><p>Number.prototype.toFixed，函数的输出结果是对指定小数进行四舍五入的结果。          </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; const x = 19.51;</span><br><span class="line">undefined</span><br><span class="line">&gt; x.toFixed(3);</span><br><span class="line">&#x27;19.510&#x27;</span><br><span class="line">&gt; x.toFixed(2);</span><br><span class="line">&#x27;19.51&#x27;</span><br><span class="line">&gt; x.toFixed(1);</span><br><span class="line">&#x27;19.5&#x27;</span><br><span class="line">&gt; x.toFixed(0);</span><br><span class="line">&#x27;20&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="指数符号"><a href="#指数符号" class="headerlink" title="指数符号"></a>指数符号</h5><p>Number.prototype.toExponential，函数的输出结果是四舍五入。指定的精度是小数位的个数。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const y = 3800.5;</span><br><span class="line">undefined</span><br><span class="line">&gt; y.toExponential(4);</span><br><span class="line">&#x27;3.8005e+3&#x27;</span><br><span class="line">&gt; y.toExponential(3);</span><br><span class="line">&#x27;3.801e+3&#x27;</span><br><span class="line">&gt; y.toExponential(2);</span><br><span class="line">&#x27;3.80e+3&#x27;</span><br><span class="line">&gt; y.toExponential(1);</span><br><span class="line">&#x27;3.8e+3&#x27;</span><br><span class="line">&gt; y.toExponential(0);</span><br><span class="line">&#x27;4e+3&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="固定精度"><a href="#固定精度" class="headerlink" title="固定精度"></a>固定精度</h5><p>Number.prototype.toPrecision，函数输出的结果是四舍五入，同时有一个指定位数的精度。必要时，输出会是指数。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; let z = 1000;</span><br><span class="line">undefined</span><br><span class="line">&gt; z.toPrecision(5);</span><br><span class="line">&#x27;1000.0&#x27;</span><br><span class="line">&gt; z.toPrecision(4);</span><br><span class="line">&#x27;1000&#x27;</span><br><span class="line">&gt; z.toPrecision(3);</span><br><span class="line">&#x27;1.00e+3&#x27;</span><br><span class="line">&gt; z.toPrecision(2);</span><br><span class="line">&#x27;1.0e+3&#x27;</span><br><span class="line">&gt; z.toPr</span><br></pre></td></tr></table></figure>

<h5 id="不同进制"><a href="#不同进制" class="headerlink" title="不同进制"></a>不同进制</h5><p>Number.prototype.toString，函数可以接受一个指定进制（从2到36）从而实现格式化。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const x = 12;</span><br><span class="line">undefined</span><br><span class="line">&gt; x.toString();</span><br><span class="line">&#x27;12&#x27;</span><br><span class="line">&gt; x.toString(10);</span><br><span class="line">&#x27;12&#x27;</span><br><span class="line">&gt; x.toString(16);</span><br><span class="line">&#x27;c&#x27;</span><br><span class="line">&gt; x.toString(8);</span><br><span class="line">&#x27;14&#x27;</span><br><span class="line">&gt; x.toString(2);</span><br><span class="line">&#x27;1100&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>有一些很常用且重要的常量可以用作Math对象的属性来使用。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.E;      //自然对数的底</span><br><span class="line">2.718281828459045        //圆周率</span><br><span class="line">&gt; Math.PI;</span><br><span class="line">3.141592653589793</span><br><span class="line"> </span><br><span class="line">// 常用对数这些值也都可以通过调用库方法来计算出</span><br><span class="line">&gt; Math.LN2      // 2的自然对数</span><br><span class="line">0.6931471805599453      </span><br><span class="line">&gt; Math.LN10;       // 10的自然对数</span><br><span class="line">2.302585092994046</span><br><span class="line">&gt; Math.LOG2E        // 以2为底的Math.E的对数</span><br><span class="line">1.4426950408889634</span><br><span class="line">&gt; Math.LOG10E        // 以10为底的Math.E的对数</span><br><span class="line">0.4342944819032518</span><br><span class="line"></span><br><span class="line">// 代数常数 </span><br><span class="line">&gt; Math.SQRT1_2       // 1/2 的平方根</span><br><span class="line">0.7071067811865476</span><br><span class="line">&gt; Math.SQRT2			 // 2的平方根</span><br><span class="line">1.4142135623730951</span><br></pre></td></tr></table></figure>

<h4 id="代数函数"><a href="#代数函数" class="headerlink" title="代数函数"></a>代数函数</h4><h5 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h5><p>Math.pow<br><img src="/2016/11/17/JavaScript4/pow.png" alt="幂函数"></p>
<h5 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h5><p>Math.log，在JavaScript中log表示自然对数。<br><img src="/2016/11/17/JavaScript4/log.png" alt="对数函数"></p>
<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><p><img src="/2016/11/17/JavaScript4/other.png" alt="其他函数"><br><img src="/2016/11/17/JavaScript4/other2.png" alt="其他函数"></p>
<h5 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h5><p>Math.random，函数会生成一个大于0且小于1的伪随机数字。它无法设置随机种子。<br><img src="/2016/11/17/JavaScript4/random.png" alt="伪随机数"><br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/seedrandom">seedrandom.js库</a>，使用随机种子来产生随机数       </p>
<h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><p><img src="/2016/11/17/JavaScript4/sin.png" alt="数字三角函数"></p>
<h4 id="双曲线函数"><a href="#双曲线函数" class="headerlink" title="双曲线函数"></a>双曲线函数</h4><p><img src="/2016/11/17/JavaScript4/sinh.png" alt="数字双曲线函数"><br><img src="/2016/11/17/JavaScript4/tanh.png" alt="数字双曲线函数"> </p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/10/12/JavaScript3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/12/JavaScript3/" class="post-title-link" itemprop="url">JavaScript（ES6）3  --异常处理、迭代器和生成器、异步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-12 21:46:20" itemprop="dateCreated datePublished" datetime="2016-10-12T21:46:20+08:00">2016-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-17 09:45:56" itemprop="dateModified" datetime="2019-02-17T09:45:56+08:00">2019-02-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异常和错误处理"><a href="#异常和错误处理" class="headerlink" title="异常和错误处理"></a>异常和错误处理</h2><h4 id="Error对象"><a href="#Error对象" class="headerlink" title="Error对象"></a>Error对象</h4><p>JavaScript有一个内建的Error对象，它可以用来处理任意类型的错误。可以在创建Error实例的时候提供一些错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; const err = new Error(&#x27;invalid email&#x27;)</span><br><span class="line">undefined</span><br><span class="line">&gt; err instanceof Error</span><br><span class="line">true </span><br></pre></td></tr></table></figure>
<h4 id="使用try和catch处理异常"><a href="#使用try和catch处理异常" class="headerlink" title="使用try和catch处理异常"></a>使用try和catch处理异常</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; function validateEmail(email) &#123;</span><br><span class="line">... return email.match(/@/) ? email : new Error(`invalid email: $&#123;email&#125;`);</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const email = null;</span><br><span class="line">undefined</span><br><span class="line">&gt; try &#123;</span><br><span class="line">... const validatedEmail = validateEmail(email);</span><br><span class="line">... if (validatedEmail instanceof Error) &#123;</span><br><span class="line">..... console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">..... &#125; else &#123;</span><br><span class="line">..... console.log(`valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;catch(err) &#123;</span><br><span class="line">... console.error(`Error: $&#123;err.message&#125;`);</span><br><span class="line">... &#125;</span><br><span class="line">Error: Cannot read property &#x27;match&#x27; of null</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>在JavaScript中，可以抛出任何值：数字、字符串、或其他任何类型。不过抛出Error实例可以更方便地处理异常。<br>通过throw抛出异常，调用throw的时候，当前函数会立即停止执行。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; function billPay(amount, payee, account) &#123;</span><br><span class="line">... if (amount &gt; account.balance)</span><br><span class="line">... 	throw new Error(&#x27;insufficient funds&#x27;);</span><br><span class="line">... account.transfer(payee, amount);</span><br><span class="line">... &#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常处理和调用栈"><a href="#异常处理和调用栈" class="headerlink" title="异常处理和调用栈"></a>异常处理和调用栈</h4><p>函数a调用函数b，函数b调用函数c，当函数c正在执行的时候，a和b都未完成，这种未完成的嵌套函数调用就叫做调用栈。<br>函数中发生错误时，错误会沿着调用栈传递，直到被捕获。错误可以在调用栈的任一级别被捕获。如果它们没有被捕获，JavaScript解释器就会强行终止程序。          </p>
<h4 id="try-…-catch-…-finally"><a href="#try-…-catch-…-finally" class="headerlink" title="try … catch … finally"></a>try … catch … finally</h4><p>catch中的代码只有在发生错误的时候才会执行。不管是否发生错误，finally中的代码都会被执行。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; try &#123;</span><br><span class="line">... console.log(&#x27;this line is excuted...&#x27;);</span><br><span class="line">... throw new Error(&#x27;whoops&#x27;);</span><br><span class="line">... console.log(&#x27;this line is not...&#x27;);</span><br><span class="line">... &#125;catch(err) &#123;</span><br><span class="line">... console.log(&#x27;there was an error...&#x27;);</span><br><span class="line">... &#125;finally &#123;</span><br><span class="line">... console.log(&#x27;...always executed&#x27;);</span><br><span class="line">... &#125;</span><br><span class="line">this line is excuted...</span><br><span class="line">there was an error...</span><br><span class="line">...always executed</span><br><span class="line">undefined</span><br><span class="line">&gt; try &#123;</span><br><span class="line">... console.log(&#x27;this line is excuted...&#x27;);</span><br><span class="line">... &#125;finally &#123;</span><br><span class="line">... console.log(&#x27;...always executed&#x27;);</span><br><span class="line">... &#125;</span><br><span class="line">this line is excuted...</span><br><span class="line">...always executed</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><p>数组可以通过values()方法获取迭代器。迭代器有next()方法，next返回的对象中有两个属性：value和done。当运行结束时，返回的对象中value的值为undefined。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; const books = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];</span><br><span class="line">undefined</span><br><span class="line">&gt; books</span><br><span class="line">(3) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&gt; const bv = books.values();</span><br><span class="line">undefined</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: &quot;a&quot;, done: false&#125;</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: &quot;b&quot;, done: false&#125;</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: &quot;c&quot;, done: false&#125;</span><br><span class="line">&gt; bv.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h4><p>如果一个类提供了一个符号方法Symbol.iterator，这个方法返回一个具有迭代行为的对象（比如：对象有next方法，同时next方法返回一个包含value和done的对象），那么这个类就是可迭代的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Log &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        this.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line">    add(message) &#123;</span><br><span class="line">        this.messages.push(message);</span><br><span class="line">    &#125;</span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        return this.messages.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const log = new Log();</span><br><span class="line">undefined</span><br><span class="line">&gt; log.add(&#x27;first day at sea&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; log.add(&#x27;spotted whale&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; log.add(&#x27;spotted another vessel&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; for (let entry of log) &#123;</span><br><span class="line">    console.log(`$&#123;entry&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">VM554:2 first day at sea</span><br><span class="line">VM554:2 spotted whale</span><br><span class="line">VM554:2 spotted another vessel</span><br></pre></td></tr></table></figure>
<p>也可以编写自己的迭代器。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Log &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        this.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line">    add(message) &#123;</span><br><span class="line">        this.messages.push(message);</span><br><span class="line">    &#125;</span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        let i = 0;</span><br><span class="line">        const messages = this.messages;</span><br><span class="line">        return &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                if (i &gt;= messages.length) &#123;</span><br><span class="line">                    return &#123;value: undefined, done: true&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                return &#123;value: messages[i++], done: false&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是使用迭代器来控制其运行的函数。生成器提供了两种能力：首先：是控制函数执行的能力，使函数能够分布执行；其次，是与执行中的函数对话的能力。<br>生成器与一般的函数有两个不同的地方： </p>
<ul>
<li>函数可以通过使用域（yield），在其运行的任意时刻将控制权交还给调用方。</li>
<li>调用生成器的时候，它并不立即执行。而是会回到迭代器中。函数会在调用迭代器的next方法时执行。</li>
</ul>
<p>在JavaScript中，生成器需要在function关键字后添加一个通配符（*）来指明；其他语法跟普通函数一样。如果一个函数是生成器，就可以在return中添加yield关键字。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; function* rainbow() &#123;</span><br><span class="line">    yield &#x27;red&#x27;;</span><br><span class="line">    yield &#x27;orange&#x27;;</span><br><span class="line">    yield &#x27;yellow&#x27;;</span><br><span class="line">    yield &#x27;green&#x27;;</span><br><span class="line">    yield &#x27;blue&#x27;;</span><br><span class="line">    yield &#x27;indigo&#x27;;</span><br><span class="line">    yield &#x27;violet&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const it = rainbow();</span><br><span class="line">undefined</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;red&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;orange&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;yellow&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;green&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;blue&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;indigo&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: &quot;violet&quot;, done: false&#125;</span><br><span class="line">&gt; it.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用for … of循环迭代器。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (let color of rainbow()) &#123;</span><br><span class="line">    console.log(color);</span><br><span class="line">&#125;</span><br><span class="line">VM1240:2 red</span><br><span class="line">VM1240:2 orange</span><br><span class="line">VM1240:2 yellow</span><br><span class="line">VM1240:2 green</span><br><span class="line">VM1240:2 blue</span><br><span class="line">VM1240:2 indigo</span><br><span class="line">VM1240:2 violet</span><br></pre></td></tr></table></figure>

<h5 id="yield-表达式和双向交流"><a href="#yield-表达式和双向交流" class="headerlink" title="yield 表达式和双向交流"></a>yield 表达式和双向交流</h5><p>yield是一个表达式，ta可以计算出一个值，它计算的是调用方每次在生成器的迭代器上调用next时提供的参数。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; function* interrogate() &#123;</span><br><span class="line">    const name = yield &quot;What is your name?&quot;;</span><br><span class="line">    const color = yield &quot;What is your favorite color?&quot;;</span><br><span class="line">    return `$&#123;name&#125;&#x27;s favorite color is $&#123;color&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const inte = interrogate();</span><br><span class="line">undefined</span><br><span class="line">&gt; inte.next();</span><br><span class="line">&#123;value: &quot;What is your name?&quot;, done: false&#125;</span><br><span class="line">&gt; inte.next(&#x27;Ethan&#x27;);</span><br><span class="line">&#123;value: &quot;What is your favorite color?&quot;, done: false&#125;</span><br><span class="line">&gt; inte.next(&#x27;orange&#x27;);</span><br><span class="line">&#123;value: &quot;Ethan&#x27;s favorite color is orange&quot;, done: true&#125;</span><br><span class="line">&gt; inte.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>不能通过箭头函数来创建生成器，必须使用function*关键字</p>
<h5 id="生成器和返回值"><a href="#生成器和返回值" class="headerlink" title="生成器和返回值"></a>生成器和返回值</h5><p>yield表达式本身不能让生成器结束，即使它是生成器的最后一个语句。在生成器的任何位置调用return都会使done的值变成true，而value的值则是任何被返回的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function* abc() &#123;</span><br><span class="line">    yield &#x27;a&#x27;;</span><br><span class="line">    yield &#x27;b&#x27;;</span><br><span class="line">    return &#x27;c&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">const ab = abc();</span><br><span class="line">undefined</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: &quot;a&quot;, done: false&#125;</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: &quot;b&quot;, done: false&#125;</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: &quot;c&quot;, done: true&#125;</span><br><span class="line">ab.next();</span><br><span class="line">&#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个行为是正确的，但要记住，使用生成器的东西并不总会在意done为true时value的值。比如，如果在for … of循环中用它，那么‘c’是不会被打印出来的。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let ab of abc()) &#123;</span><br><span class="line">    console.log(ab);</span><br><span class="line">&#125;</span><br><span class="line">VM1809:2 a</span><br><span class="line">VM1809:2 b</span><br></pre></td></tr></table></figure>
<p>建议不要在return中提供一个对生成器有意义的值。如果想在生成器之外使用某个值，应该调用yield；return应该只被用做提前停止生成器。出于这个原因，通常建议：在生成器中调用return的时候，不提供返回值。</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>在调用一个基于promise的异步函数时，它会返回一个promise实例。其中只可能发生两件事：被满足（success）或被拒绝（failure）。promise可以保证只有一件事会发生，而结果只会发生一次（如果满足，那么只会被满足一次，如果拒绝，也只会被拒绝一次）。一旦promise被满足或者被拒绝了，就会认为它被处理了。<br>创建一个带有函数的promise实例，它应该包括一个resolve和一个reject回调函数。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt; function countdown(seconds) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        for (let i = seconds; i &gt;=0; i--) &#123;</span><br><span class="line">            setTimeout(function() &#123;</span><br><span class="line">                if (i &gt; 0) console.log(i + &#x27;...&#x27;);</span><br><span class="line">                else resolve(console.log(&#x27;Go!&#x27;));</span><br><span class="line">            &#125;, (seconds - i) * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; countdown(5).then(function() &#123;</span><br><span class="line">    console.log(&#x27;countdown completed successfully&#x27;);</span><br><span class="line">&#125;,function(err) &#123;</span><br><span class="line">    console.log(&#x27;countdown experienced an error:&#x27; + err.message);</span><br><span class="line">&#125;);</span><br><span class="line">Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">VM218:5 5...</span><br><span class="line">VM218:5 4...</span><br><span class="line">VM218:5 3...</span><br><span class="line">VM218:5 2...</span><br><span class="line">VM218:5 1...</span><br><span class="line">VM218:6 Go!</span><br><span class="line">VM434:2 countdown completed successfully</span><br><span class="line">&gt; const p = countdown(5);</span><br><span class="line">undefined</span><br><span class="line">VM218:5 5...</span><br><span class="line">VM218:5 4...</span><br><span class="line">VM218:5 3...</span><br><span class="line">VM218:5 2...</span><br><span class="line">VM218:5 1...</span><br><span class="line">VM218:6 Go!</span><br><span class="line">&gt; p.then(function() &#123;</span><br><span class="line">    console.log(&#x27;countdown completed successfully&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">VM562:2 countdown completed successfully</span><br><span class="line">Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br><span class="line">p.catch(function(err) &#123;</span><br><span class="line">    console.log(&#x27;countdown experienced an error: &#x27; + err.message);</span><br><span class="line">&#125;);</span><br><span class="line">Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件发射器可以广播事件，任何愿意监听（或者“订阅”）这些事件的人都可以去做这件事。创建自己的事件系统，Node提供了内建支持。如果使用浏览器，jQuery同样提供了一个事件机制（<a target="_blank" rel="noopener" href="http://api.jquery.com/category/events/%EF%BC%89">http://api.jquery.com/category/events/）</a>     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&gt; const EventEmitter = require(&#x27;events&#x27;).EventEmitter;</span><br><span class="line">undefined</span><br><span class="line">&gt; class Countdown extends EventEmitter &#123;</span><br><span class="line">... constructor(seconds, superstitious) &#123;</span><br><span class="line">..... super();</span><br><span class="line">..... this.seconds = seconds;</span><br><span class="line">..... this.superstitious = !!superstitious;</span><br><span class="line">..... &#125;</span><br><span class="line">... go() &#123;</span><br><span class="line">..... const countdown = this;</span><br><span class="line">..... return new Promise(function(resolve, reject) &#123;</span><br><span class="line">....... for (let i = countdown.seconds; i &gt;= 0; i--) &#123;</span><br><span class="line">......... setTimeout(function() &#123;</span><br><span class="line">........... if (countdown.superstitious &amp;&amp; i === 13)</span><br><span class="line">........... return reject(new Error(&#x27;definitely not counting that&#x27;));</span><br><span class="line">........... countdown.emit(&#x27;tick&#x27;,i);</span><br><span class="line">........... if(i === 0) resolve();</span><br><span class="line">........... &#125;, (countdown.seconds-i)*1000);</span><br><span class="line">......... &#125;</span><br><span class="line">....... &#125;);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const c = new Countdown(5);</span><br><span class="line">undefined</span><br><span class="line">&gt; c.on(&#x27;tick&#x27;, function(i) &#123;</span><br><span class="line">... if (i&gt;0) console.log(i + &#x27;...&#x27;);</span><br><span class="line">... &#125;);</span><br><span class="line">Countdown &#123;</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125;,</span><br><span class="line">  _events: &#123; tick: [Function] &#125;,</span><br><span class="line">  _eventsCount: 1,</span><br><span class="line">  _maxListeners: undefined,</span><br><span class="line">  seconds: 5,</span><br><span class="line">  superstitious: false &#125;</span><br><span class="line">&gt; c.go().then(function() &#123;</span><br><span class="line">... console.log(&#x27;go!&#x27;);</span><br><span class="line">... &#125;).catch(function(err) &#123;</span><br><span class="line">... console.log(err.message);</span><br><span class="line">... &#125;)</span><br><span class="line">Promise &#123;</span><br><span class="line">  &lt;pending&gt;,</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125; &#125;</span><br><span class="line">&gt; 5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">go!</span><br><span class="line">&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="promise链"><a href="#promise链" class="headerlink" title="promise链"></a>promise链</h5><p>promise的一个优点就是它可以被链式调用；也就是说，当一个promise被满足时，可以立即用它调用另一个返回promise的函数，以此类推。promise链的一个好处是不用在每一步都捕获错误；如果错误可能发生在链中的任何一环，promise链都会停止，继而调到catch中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt; function launch() &#123;</span><br><span class="line">... return new Promise(function(resolve, reject) &#123;</span><br><span class="line">..... console.log(&#x27;lift off&#x27;);</span><br><span class="line">..... setTimeout(function() &#123;</span><br><span class="line">....... resolve(&#x27;in orbit&#x27;);</span><br><span class="line">....... &#125;, 2*1000);</span><br><span class="line">..... &#125;);</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const c1 = new Countdown(5);</span><br><span class="line">&gt; c1.go().then(launch).then(function(msg)&#123;console.log(msg);&#125;).catch(function(err) &#123;console.error(&#x27;houston, we have a problem ....&#x27;);&#125;)</span><br><span class="line">Promise &#123;</span><br><span class="line">  &lt;pending&gt;,</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125; &#125;</span><br><span class="line">&gt; 5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">0...</span><br><span class="line">lift off</span><br><span class="line">in orbit</span><br></pre></td></tr></table></figure>
<h5 id="避免不被处理的promise"><a href="#避免不被处理的promise" class="headerlink" title="避免不被处理的promise"></a>避免不被处理的promise</h5><p>promise可以简化异步代码，同时确保回调函数不会被多次调用，但却不能避免那些因为promise没有被处理而产生的问题（没被处理指在这个promise中，既没有调用resolve，也没有调用reject）。有种方式可以避免这种错误，就是给promise一个特定的超时。如果promise没有在一段合理的时间内被处理，就会自动被拒绝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; function addTimeout(fn, timeout) &#123;</span><br><span class="line">... if (timeout === undefined) timeout = 1000;  //默认时间</span><br><span class="line">... return function(...args) &#123;</span><br><span class="line">..... return new Promise(function(resolve, reject) &#123;</span><br><span class="line">....... const tid = setTimeout(reject, timeout, new Error(&#x27;promise timed out&#x27;)); </span><br><span class="line">....... fn(...args).then(function(...args) &#123;</span><br><span class="line">......... clearTimeout(tid);</span><br><span class="line">......... resolve(...args);</span><br><span class="line">......... &#125;).catch(function(...args) &#123;</span><br><span class="line">......... clearTimeout(tid);</span><br><span class="line">......... reject(...args);</span><br><span class="line">......... &#125;);</span><br><span class="line">....... &#125;);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; c1.go().then(addTimeout(launch, 4*1000)).then(function(msg) &#123;console.log(msg);&#125;).catch(function(err) &#123; console.error(&#x27;houston, we have a problem: &#x27; + err.message); &#125;);</span><br><span class="line">Promise &#123;</span><br><span class="line">  &lt;pending&gt;,</span><br><span class="line">  domain: </span><br><span class="line">   Domain &#123;</span><br><span class="line">     domain: null,</span><br><span class="line">     _events: &#123; error: [Function: debugDomainError] &#125;,</span><br><span class="line">     _eventsCount: 1,</span><br><span class="line">     _maxListeners: undefined,</span><br><span class="line">     members: [] &#125; &#125;</span><br><span class="line">&gt; 5...</span><br><span class="line">4...</span><br><span class="line">3...</span><br><span class="line">2...</span><br><span class="line">1...</span><br><span class="line">0...</span><br><span class="line">lift off</span><br><span class="line">in orbit</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/09/29/JavaScript2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/29/JavaScript2/" class="post-title-link" itemprop="url">JavaScript（ES6）2  --数组、对象、映射和集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-29 11:33:58" itemprop="dateCreated datePublished" datetime="2016-09-29T11:33:58+08:00">2016-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-18 17:53:14" itemprop="dateModified" datetime="2019-02-18T17:53:14+08:00">2019-02-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>JavaScript中的数组可以是非齐次的，及数组中的元素可以是不同类型的。</p>
<h4 id="末尾添加或删除元素"><a href="#末尾添加或删除元素" class="headerlink" title="末尾添加或删除元素"></a>末尾添加或删除元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.push(&#x27;a&#x27;);   //末尾添加元素，返回数组长度</span><br><span class="line">arr.pop();     //末尾删除元素，返回删除的元素</span><br></pre></td></tr></table></figure>
<h4 id="起始添加和删除元素"><a href="#起始添加和删除元素" class="headerlink" title="起始添加和删除元素"></a>起始添加和删除元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">arr.unshift(&#x27;a&#x27;);     //起始添加元素，返回数组长度</span><br><span class="line">arr.shift();			  //起始删除元素，返回删除的元素</span><br></pre></td></tr></table></figure>
<h4 id="获取子数组"><a href="#获取子数组" class="headerlink" title="获取子数组"></a>获取子数组</h4><p>slice  有两个参数，第一个是数组的起始位置，第二个是终止位置（不包含），如果省略终止位置，则返回从当前位置到数组末尾的所有元素。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.slice(3);  		//返回[4, 5], arr没改动</span><br><span class="line">arr.slice(2, 4);    //返回[3, 4], arr没改动</span><br><span class="line">arr.slice(-2);      //返回[4, 5], arr没改动</span><br></pre></td></tr></table></figure>
<h4 id="从任意位置添加或删除元素"><a href="#从任意位置添加或删除元素" class="headerlink" title="从任意位置添加或删除元素"></a>从任意位置添加或删除元素</h4><p>splice 允许对当前数组进行修改，可以从任何一个下标添加和删除元素，第一个参数是下标位置，第二个参数是要删除的元素个数，（如果不想删除任何元素就传入0），其他参数则是要添加到数组中的元素。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [1,5,7];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 5, 7 ]</span><br><span class="line">&gt; arr.splice(1,0,2,3,4)</span><br><span class="line">[]</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 2, 3, 4, 5, 7 ]</span><br><span class="line">&gt; arr.splice(5,0,6)</span><br><span class="line">[]</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 2, 3, 4, 5, 6, 7 ]</span><br><span class="line">&gt; arr.splice(1,2)</span><br><span class="line">[ 2, 3 ]</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 4, 5, 6, 7 ]</span><br><span class="line">&gt; arr.splice(2,1,&#x27;a&#x27;,&#x27;b&#x27;);</span><br><span class="line">[ 5 ]</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 4, &#x27;a&#x27;, &#x27;b&#x27;, 6, 7 ]</span><br></pre></td></tr></table></figure>
<h4 id="数组内的分割和替换"><a href="#数组内的分割和替换" class="headerlink" title="数组内的分割和替换"></a>数组内的分割和替换</h4><p>copyWithin 会将数组中一串有序的元素复制到数组的另一个位置，复制的同时会覆盖原来数组中的内容。这个方法第一个参数表明要复制到哪里（目标位置），第二个参数是从哪里开始复制，最后一个（可选）参数是复制到哪里结束。位置是负数的话，表式反向计数。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [1,2,3,4];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr.copyWithin(1,2);</span><br><span class="line">[ 1, 3, 4, 4 ]</span><br><span class="line">&gt; arr.copyWithin(2,0,2);</span><br><span class="line">[ 1, 3, 1, 3 ]</span><br><span class="line">&gt; arr.copyWithin(0,-3,-1);</span><br><span class="line">[ 3, 1, 1, 3 ]</span><br></pre></td></tr></table></figure>
<h4 id="用指定值填充数组"><a href="#用指定值填充数组" class="headerlink" title="用指定值填充数组"></a>用指定值填充数组</h4><p>fill 可以将一个固定值赋给数组中任意位置元素（修改当前数组）。这个方法跟数组构造器（可以指定数组的初始大小）结合起来非常实用。可以任意指定一个起始位置和结束位置，然后填充这部分的数组值（下标可以为负值）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = new Array(5).fill(1);</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 1, 1, 1, 1 ]</span><br><span class="line">&gt; arr.fill(&#x27;a&#x27;)</span><br><span class="line">[ &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;a&#x27; ]</span><br><span class="line">&gt; arr.fill(&#x27;b&#x27;,1)</span><br><span class="line">[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27; ]</span><br><span class="line">&gt; arr.fill(&#x27;c&#x27;,2,4)</span><br><span class="line">[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;c&#x27;, &#x27;b&#x27; ]</span><br><span class="line">&gt; arr.fill(5.5, -4)</span><br><span class="line">[ &#x27;a&#x27;, 5.5, 5.5, 5.5, 5.5 ]</span><br><span class="line">&gt; arr.fill(0,-3,-1)</span><br><span class="line">[ &#x27;a&#x27;, 5.5, 0, 0, 5.5 ]</span><br></pre></td></tr></table></figure>
<h4 id="数组反转和排序"><a href="#数组反转和排序" class="headerlink" title="数组反转和排序"></a>数组反转和排序</h4><p>reverse 颠倒当前数组的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [1,2,3,4,5];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr.reverse()</span><br><span class="line">[ 5, 4, 3, 2, 1 ]</span><br><span class="line">&gt; arr</span><br><span class="line">[ 5, 4, 3, 2, 1 ]</span><br></pre></td></tr></table></figure>
<p>sort 对当前数组进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [5,3,2,4,1]</span><br><span class="line">undefined</span><br><span class="line">&gt; arr.sort()</span><br><span class="line">[ 1, 2, 3, 4, 5 ]</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>
<p>sort函数可以指定一个排序函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [&#123;name:&#x27;Suzanne&#x27;&#125;,&#123;name:&#x27;Jim&#x27;&#125;,&#123;name:&#x27;Trevor&#x27;&#125;,&#123;name:&#x27;Amanda&#x27;&#125;];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ &#123; name: &#x27;Suzanne&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Jim&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Trevor&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Amanda&#x27; &#125; ]</span><br><span class="line">&gt; arr.sort()</span><br><span class="line">[ &#123; name: &#x27;Suzanne&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Jim&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Trevor&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Amanda&#x27; &#125; ]</span><br><span class="line">&gt; arr.sort((a,b) =&gt; a.name &gt; b.name)</span><br><span class="line">[ &#123; name: &#x27;Amanda&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Jim&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Suzanne&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Trevor&#x27; &#125; ]</span><br><span class="line">&gt; arr.sort((a,b) =&gt; a.name[1] &lt; b.name[1])</span><br><span class="line">[ &#123; name: &#x27;Suzanne&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Trevor&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Amanda&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Jim&#x27; &#125; ]</span><br></pre></td></tr></table></figure>
<h4 id="数组搜索"><a href="#数组搜索" class="headerlink" title="数组搜索"></a>数组搜索</h4><ol>
<li>indexOf<br>返回跟所要查找的内容完全相同的第一个元素的下标。-1表示未找到。第一个参数是要查找的元素，第二个是从哪个位置开始查找。<br><code>lasIndexOf()</code> 从数组的末尾开始查找</li>
<li>findIndex<br>返回跟所要查找的内容完全相同的第一个元素的下标。-1表示未找到。findIndex更灵活，它可以指定一个函数来表示元素是否匹配。findIndex不能指定查找的起始位置</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [&#123;id:5,name:&#x27;Judith&#x27;&#125;,&#123;id:7,name:&#x27;Francis&#x27;&#125;];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ &#123; id: 5, name: &#x27;Judith&#x27; &#125;, &#123; id: 7, name: &#x27;Francis&#x27; &#125; ]</span><br><span class="line">&gt; arr.findIndex(o =&gt; o.id == 5)</span><br><span class="line">0</span><br><span class="line">&gt; arr.findIndex(o =&gt; o.name === &#x27;Francis&#x27;);</span><br><span class="line">1</span><br><span class="line">&gt; arr.findIndex(o =&gt; o === 3);</span><br><span class="line">-1</span><br><span class="line">&gt; arr.findIndex(o =&gt; o.id === 17);</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>find<br>find允许指定一个函数来进行查找，只不过它会返回元素本身而非元素下标（没找到是返回null）</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [&#123;id:5,name:&#x27;Judith&#x27;&#125;,&#123;id:7,name:&#x27;Francis&#x27;&#125;];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ &#123; id: 5, name: &#x27;Judith&#x27; &#125;, &#123; id: 7, name: &#x27;Francis&#x27; &#125; ]</span><br><span class="line">&gt; arr.find(o =&gt; o.id === 5)</span><br><span class="line">&#123; id: 5, name: &#x27;Judith&#x27; &#125;</span><br><span class="line">&gt; arr.find(o =&gt; o.id === 15)</span><br><span class="line">undefined</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>find和findIndex会把数组的每一个元素作为第一个参数，其他参数还有当前元素的下标和数组本身。   </p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [1,17,16,5,4,16,10,3,49];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 17, 16, 5, 4, 16, 10, 3, 49 ]</span><br><span class="line">&gt; arr.find((x, i) =&gt; i &gt; 2 &amp;&amp; Number.isInteger(Math.sqrt(x)));</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="4">
<li>some<br>判断数组中是否有某个元素，一旦找到就会停止查找，找到返回true，否则返回false</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &gt; const arr = [1,17,16,5,4,16,10,3,49];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, 17, 16, 5, 4, 16, 10, 3, 49 ]</span><br><span class="line">&gt; arr.some(x =&gt; x%3 == 0)</span><br><span class="line">true</span><br><span class="line">&gt; arr.some(x =&gt; x%9 == 0)</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>every<br>当数组中的每个元素都符合条件时，every方法才会返回true，否则返回false。当every方法发现一个不符合条件的元素时，就会停止查找并返回false。  </p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [2, 6, 16, 36];</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ 2, 6, 16, 36 ]</span><br><span class="line">&gt; arr.every( o =&gt; o%2 == 0)</span><br><span class="line">true</span><br><span class="line">&gt; arr.every( o =&gt; Number.isInteger(Math.sqrt(o)))</span><br><span class="line">false</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="数组的基本操作：-map和filter"><a href="#数组的基本操作：-map和filter" class="headerlink" title="数组的基本操作： map和filter"></a>数组的基本操作： map和filter</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map可以把元素转换成数组。任何时候如果数组格式与所需要的格式不一样，就用map。map和filter都不会修改原始数组，而是返回数组的拷贝。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const cart = [&#123;name:&#x27;Widget&#x27;, price:9.95&#125;, &#123;name:&#x27;Gadget&#x27;, price:22.95&#125;];</span><br><span class="line">undefined</span><br><span class="line">&gt; cart</span><br><span class="line">[ &#123; name: &#x27;Widget&#x27;, price: 9.95 &#125;,</span><br><span class="line">  &#123; name: &#x27;Gadget&#x27;, price: 22.95 &#125; ]</span><br><span class="line">&gt; const names = cart.map(x =&gt; x.name)</span><br><span class="line">undefined</span><br><span class="line">&gt; names</span><br><span class="line">[ &#x27;Widget&#x27;, &#x27;Gadget&#x27; ]</span><br><span class="line">&gt; const prices = cart.map(x =&gt; x.price)</span><br><span class="line">undefined</span><br><span class="line">&gt; prices</span><br><span class="line">[ 9.95, 22.95 ]</span><br><span class="line">&gt; const discountPrices = prices.map(x =&gt; x * 0.8)</span><br><span class="line">undefined</span><br><span class="line">&gt; discountPrices</span><br><span class="line">[ 7.96, 18.36 ]</span><br></pre></td></tr></table></figure>
<p>数组的每个元素在调用提供方法时都会传入三个参数：元素本身、元素的下标、数组本身（不常用）。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; const items = [&#x27;Widget&#x27;, &#x27;Gadget&#x27;];</span><br><span class="line">undefined</span><br><span class="line">&gt; const prices = [9.95, 22.95];</span><br><span class="line">undefined</span><br><span class="line">&gt; const cart = items.map((x, i) =&gt; (&#123;name:x, price:prices[i]&#125;))</span><br><span class="line">undefined</span><br><span class="line">&gt; cart</span><br><span class="line">[ &#123; name: &#x27;Widget&#x27;, price: 9.95 &#125;,</span><br><span class="line">  &#123; name: &#x27;Gadget&#x27;, price: 22.95 &#125; ]</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter用来删除数组中不需要的元素。它返回一个删除了某些元素的数组。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt; const cards = [];</span><br><span class="line">undefined</span><br><span class="line">&gt; for (let suit of [&#x27;H&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;S&#x27;])</span><br><span class="line">... for (let value=1; value&lt;=13; value++)</span><br><span class="line">... cards.push(&#123;suit,value&#125;)</span><br><span class="line">52</span><br><span class="line">&gt; cards</span><br><span class="line">[ &#123; suit: &#x27;H&#x27;, value: 1 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 2 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 3 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 4 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 5 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 6 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 7 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 8 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 9 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 10 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 11 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 12 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 13 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 1 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 2 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 3 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 4 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 5 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 6 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 7 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 8 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 9 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 10 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 11 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 12 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 13 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 1 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 2 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 3 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 4 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 5 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 6 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 7 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 8 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 9 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 10 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 11 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 12 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 13 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 1 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 2 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 3 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 4 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 5 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 6 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 7 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 8 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 9 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 10 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 11 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 12 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 13 &#125; ]</span><br><span class="line">&gt; cards.filter(x =&gt; x.value === 2)</span><br><span class="line">[ &#123; suit: &#x27;H&#x27;, value: 2 &#125;,</span><br><span class="line">  &#123; suit: &#x27;C&#x27;, value: 2 &#125;,</span><br><span class="line">  &#123; suit: &#x27;D&#x27;, value: 2 &#125;,</span><br><span class="line">  &#123; suit: &#x27;S&#x27;, value: 2 &#125; ]</span><br><span class="line">&gt; cards.filter(x =&gt; x.value &gt; 10 &amp;&amp; x.suit === &#x27;H&#x27;)</span><br><span class="line">[ &#123; suit: &#x27;H&#x27;, value: 11 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 12 &#125;,</span><br><span class="line">  &#123; suit: &#x27;H&#x27;, value: 13 &#125; ]</span><br></pre></td></tr></table></figure>
<h3 id="数组魔法-reduce"><a href="#数组魔法-reduce" class="headerlink" title="数组魔法 reduce"></a>数组魔法 reduce</h3><p>reduce像map和filter一样，允许提供一个可以控制输出的函数。在reduce中，第一个参数是累加值，表示数组将被归纳成的值。第二个参数是当前元素，第三个是当前元素的下标，第四个是数组。除了回调函数外，reduce还可以接收一个累加值的初始值（可选）。未指定累积值得初始值时，即累加结果的初始值是undefined，reduce会把数组的第一个元素当做初始值，然后从第二个元素开始调用函数。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [5, 7, 2, 4]</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ 5, 7, 2, 4 ]</span><br><span class="line">&gt; const sum = arr.reduce((a,x) =&gt; a += x, 0)</span><br><span class="line">undefined</span><br><span class="line">&gt; sum</span><br><span class="line">18</span><br><span class="line">&gt; const sum1 = arr.reduce((a,x) =&gt; a += x)</span><br><span class="line">undefined</span><br><span class="line">&gt; su</span><br></pre></td></tr></table></figure>
<h3 id="数组方法，已删除或者未定义的元素"><a href="#数组方法，已删除或者未定义的元素" class="headerlink" title="数组方法，已删除或者未定义的元素"></a>数组方法，已删除或者未定义的元素</h3><p>当数组中的元素未被赋值或已被删除时，map、filter和reduce就不会调用所传入的函数。   </p>
<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>join方法拼接字符串。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const arr = [1, null, &#x27;hello&#x27;,&#x27;word&#x27;,true,undefined]</span><br><span class="line">undefined</span><br><span class="line">&gt; arr</span><br><span class="line">[ 1, null, &#x27;hello&#x27;, &#x27;word&#x27;, true, undefined ]</span><br><span class="line">&gt; arr.join()</span><br><span class="line">&#x27;1,,hello,word,true,&#x27;</span><br><span class="line">&gt; arr.join(&#x27;,&#x27;)</span><br><span class="line">&#x27;1,,hello,word,true,&#x27;</span><br><span class="line">&gt; arr.join(&#x27;&#x27;)</span><br><span class="line">&#x27;1hellowordtrue&#x27;</span><br><span class="line">&gt; arr.join(&#x27;--&#x27;)</span><br><span class="line">&#x27;1----hello--word--true--&#x27;</span><br></pre></td></tr></table></figure>


<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>跟数组一样，JavaScript中对象也是一种容器。数组和对象之间的区别：    </p>
<ul>
<li>数组包含值，使用数字做索引；而对象包含属性，使用字符串和符号作为索引。</li>
<li>数组是有序的；对象是无序的。</li>
</ul>
<h4 id="属性枚举"><a href="#属性枚举" class="headerlink" title="属性枚举"></a>属性枚举</h4><h5 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a>for … in</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; const SYM = Symbol();</span><br><span class="line">undefined</span><br><span class="line">&gt; const o = &#123; a: 1, b: 2, c: 3, SYM: 4&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; o</span><br><span class="line">&#123; a: 1, b: 2, c: 3, SYM: 4 &#125;</span><br><span class="line">&gt; for (let prop in o) &#123;</span><br><span class="line">... if (!o.hasOwnProperty(prop)) continue;</span><br><span class="line">... console.log(`$&#123;prop&#125;: $&#123;o[prop]&#125;`);</span><br><span class="line">... &#125;</span><br><span class="line">a: 1</span><br><span class="line">b: 2</span><br><span class="line">c: 3</span><br><span class="line">SYM: 4</span><br><span class="line">undefined</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>使用hasOwnProperty可以避免一些对象含有一些意料之外的属性。   </p>
<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h5><p>Object.keys提供一种方式来获取对象中所有可枚举的字符串属性，并将结果封装成一个数组。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; const SYM = Symbol();</span><br><span class="line">undefined</span><br><span class="line">&gt; const o = &#123; a: 1, b: 2, c: 3, SYM: 4&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; o</span><br><span class="line">&#123; a: 1, b: 2, c: 3, SYM: 4 &#125;</span><br><span class="line">&gt; Object.keys(o)</span><br><span class="line">[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;SYM&#x27; ]</span><br><span class="line">&gt; Object.keys(o).forEach(prop =&gt; console.log(`$&#123;prop&#125;: $&#123;o[prop]&#125;`));</span><br><span class="line">a: 1</span><br><span class="line">b: 2</span><br><span class="line">c: 3</span><br><span class="line">SYM: 4</span><br><span class="line">undefined</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>


<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h4 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Car &#123;</span><br><span class="line">... constructor() &#123;</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; let car = new Car();</span><br><span class="line">undefined</span><br><span class="line">&gt; car instanceof Car;</span><br><span class="line">true</span><br><span class="line">&gt; car instanceof Array;</span><br><span class="line">false</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>this关键字是某个具体实例。    </p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>在JavaScript中，可以给私有属性加上下划线前缀（_），但这只是一种约定俗成的做法，它能让大家快速识别出哪些代码访问了被保护的属性，但实际并未进行限制。如果确实想要强制属性私有化，可以使用一个WeakMap的实例，它是被作用域保护的。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const Car = (function() &#123;</span><br><span class="line">    const carProps = new WeakMap();</span><br><span class="line">    class Car &#123;</span><br><span class="line">      constructor(make, model) &#123;</span><br><span class="line">         this.make = make;</span><br><span class="line">         this.model = model;</span><br><span class="line">         this._userGears = [&#x27;P&#x27;, &#x27;N&#x27;, &#x27;R&#x27;, &#x27;D&#x27;];</span><br><span class="line">         carProps.set(this, &#123;userGear: this._userGears[0]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      get userGear() &#123;</span><br><span class="line">         return carProps.get(this).userGear;</span><br><span class="line">      &#125;</span><br><span class="line">      set userGear(value) &#123;</span><br><span class="line">         if (this._userGears.indexOf(value) &lt; 0)</span><br><span class="line">         throw new Error(`Invalid gear: $&#123;value&#125;`);</span><br><span class="line">         carProps.get(this).userGear = value;</span><br><span class="line">      &#125;</span><br><span class="line">      shift(gear) &#123; this.userGear = gear; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Car;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">&gt; const car1 = new Car()</span><br><span class="line">undefined</span><br><span class="line">&gt; car1</span><br><span class="line">Car &#123;</span><br><span class="line">  make: undefined,</span><br><span class="line">  model: undefined,</span><br><span class="line">  _userGears: [ &#x27;P&#x27;, &#x27;N&#x27;, &#x27;R&#x27;, &#x27;D&#x27; ] &#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<h4 id="类即函数"><a href="#类即函数" class="headerlink" title="类即函数"></a>类即函数</h4><p>class 是ES6引入的语法糖。</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>在类的实例中，当引用一个方法时，实际上是在引用原型方法。例如Car的实例中的shift方法，引用的是一个原型方法，并且会看到它被写成Car.prototype.shift。（类似的，数组的forEach函数会被写成Array.prototype.forEach）。  </p>
<p>使用数字符号（#）来描述原型方法已经成为一种普遍的约定。例如，Car.prototype.shift被简单地写成Car#shift。   </p>
<p>每个函数都有一个叫作prototype的特殊属性。一般的函数不需要使用原型，但是对于那些作为对象构造器的函数，就至关重要。当使用关键字new来创建一个新的实例时，新创建的对象可以访问其构造器的原型对象。对象实例会将它存储在自己的<code>__proto__</code>属性中。       </p>
<p>关于原型，有个重要的机制叫作动态调度（“调度”是方法调用的另一种说法）。当试图访问对象的某个属性或者方法时，如果它不存在于当前对象中，JavaScript会检查它是否存在于对象原型中。因为同一个类的所有实例公用同一个原型，如果原型中存在某个属性或者方法，则该类的所有实例都可以访问这个属性或方法。  </p>
<p>通常不要在类的原型中设置数据属性，因为所有的实例都会共享这些属性的值。但是如果该值被设置在任意一个实例中，那么它就只在特定的实例中存在，而原型中不存在，这会引发困惑和产生bug。所以如果需要给对象实例初始化一些数据，最好是通过构造器来设置。     </p>
<p>在实例中定义的方法会覆盖掉原型中的定义，JavaScript的检查顺序是先实例后原型。      </p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法经常用来执行一些与类相关的任务，而非跟具体的实例相关。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Car &#123;</span><br><span class="line">... static getNextVin() &#123;</span><br><span class="line">..... return Car.nextVin++;</span><br><span class="line">..... &#125;</span><br><span class="line">... constructor(make, model) &#123;</span><br><span class="line">..... this.make = make;</span><br><span class="line">..... this.model = model;</span><br><span class="line">..... this.vin = Car.getNextVin();</span><br><span class="line">..... &#125;</span><br><span class="line">... static areSimilar(car1, car2) &#123;</span><br><span class="line">..... return car1.make === car2.make &amp;&amp; car1.model === car2.model;</span><br><span class="line">..... &#125;</span><br><span class="line">... static areSame(car1, car2) &#123;</span><br><span class="line">..... return car1.vin === car2.vin;</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Car.nextVin</span><br><span class="line">undefined</span><br><span class="line">&gt; Car.nextVin = 0;</span><br><span class="line">0</span><br><span class="line">&gt; const car1 = new Car(&#x27;Tesla&#x27;,&#x27;S&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; const car2 = new Car(&#x27;Mazda&#x27;,&#x27;3&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; const car3 = new Car(&#x27;Mazda&#x27;,&#x27;3&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; car1.vin</span><br><span class="line">0</span><br><span class="line">&gt; car2.vin</span><br><span class="line">1</span><br><span class="line">&gt; car3</span><br><span class="line">Car &#123; make: &#x27;Mazda&#x27;, model: &#x27;3&#x27;, vin: 2 &#125;</span><br><span class="line">&gt; Car.areSimilar(car1, car2);</span><br><span class="line">false</span><br><span class="line">&gt; Car.areSimilar(car2, car3);</span><br><span class="line">true</span><br><span class="line">&gt; Car.areSame(car2, car3);</span><br><span class="line">false</span><br><span class="line">&gt; Car.areSame(car2, car2);</span><br><span class="line">true</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>当创建一个类的实例时，它继承了类原型中所有的功能。尽管如此，它并没有就此打住：如果一个方法没有在对象原型中找到其定义，它会检查原型的原型。这样就建立了一个原型链。JavaScript会沿着原型链走下去，直到某个原型满足需求。如果找不到这样的原型，程序最终会报错。      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Vehicle &#123;</span><br><span class="line">... constructor() &#123;</span><br><span class="line">..... this.passengers = [];</span><br><span class="line">..... console.log(&#x27;Vehicle created&#x27;);</span><br><span class="line">..... &#125;</span><br><span class="line">... addPassenger(p) &#123;</span><br><span class="line">..... this.passengers.push(p);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; class VCar extends Vehicle &#123;</span><br><span class="line">... constructor() &#123;</span><br><span class="line">..... super();</span><br><span class="line">..... console.log(&#x27;VCar created&#x27;);</span><br><span class="line">..... &#125;</span><br><span class="line">... deployAirbags() &#123;</span><br><span class="line">..... console.log(&#x27;BWOOSH!&#x27;);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>JavaScript中所有对象都是基类Object的实例</p>
<h2 id="maps和sets"><a href="#maps和sets" class="headerlink" title="maps和sets"></a>maps和sets</h2><h3 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h3><p>maps用来存放键值对，其中键可以是对象。并且存储的数据是有序的。键不能重复。<br>map中使用set方法赋值。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; const u1 = &#123;name: &#x27;Cynthia&#x27;&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; const u2 = &#123;name: &#x27;Jackson&#x27;&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; const u3 = &#123;name: &#x27;Olive&#x27;&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; const u4 = &#123;name: &#x27;James&#x27;&#125;;</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&gt; const userRoles = new Map();</span><br><span class="line">undefined</span><br><span class="line">&gt; userRoles</span><br><span class="line">Map &#123;&#125;</span><br><span class="line">&gt; userRoles.set(u1, &#x27;User&#x27;);</span><br><span class="line">Map &#123; &#123; name: &#x27;Cynthia&#x27; &#125; =&gt; &#x27;User&#x27; &#125;</span><br><span class="line">&gt; userRoles.set(u2, &#x27;User&#x27;);</span><br><span class="line">Map &#123; &#123; name: &#x27;Cynthia&#x27; &#125; =&gt; &#x27;User&#x27;, &#123; name: &#x27;Jackson&#x27; &#125; =&gt; &#x27;User&#x27; &#125;</span><br><span class="line">&gt; userRoles.set(u3, &#x27;Admin&#x27;);</span><br><span class="line">Map &#123;</span><br><span class="line">  &#123; name: &#x27;Cynthia&#x27; &#125; =&gt; &#x27;User&#x27;,</span><br><span class="line">  &#123; name: &#x27;Jackson&#x27; &#125; =&gt; &#x27;User&#x27;,</span><br><span class="line">  &#123; name: &#x27;Olive&#x27; &#125; =&gt; &#x27;Admin&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>可以链式调用set()方法，节省打字时间。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; userRoles.set(u1, &#x27;User&#x27;).set(u2, &#x27;User&#x27;).set(u4, &#x27;Admin&#x27;)</span><br><span class="line">Map &#123;</span><br><span class="line">  &#123; name: &#x27;Cynthia&#x27; &#125; =&gt; &#x27;User&#x27;,</span><br><span class="line">  &#123; name: &#x27;Jackson&#x27; &#125; =&gt; &#x27;User&#x27;,</span><br><span class="line">  &#123; name: &#x27;Olive&#x27; &#125; =&gt; &#x27;Admin&#x27;,</span><br><span class="line">  &#123; name: &#x27;James&#x27; &#125; =&gt; &#x27;Admin&#x27; &#125;</span><br></pre></td></tr></table></figure>
<p>可以给map的构造函数传一个包含了数组的数组来创建map。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; const userRoles2 = new Map([[u1,&#x27;User&#x27;],[u2, &#x27;User&#x27;],[u3, &#x27;Admin&#x27;]])</span><br><span class="line">undefined</span><br><span class="line">&gt; userRoles2</span><br><span class="line">Map &#123;</span><br><span class="line">  &#123; name: &#x27;Cynthia&#x27; &#125; =&gt; &#x27;User&#x27;,</span><br><span class="line">  &#123; name: &#x27;Jackson&#x27; &#125; =&gt; &#x27;User&#x27;,</span><br><span class="line">  &#123; name: &#x27;Olive&#x27; &#125; =&gt; &#x27;Admin&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>通过get方法获取map中key对应的value。如果不存在就返回undefined。可以用has()方法来查看map中是否包含给定的key。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; userRoles.has(u1);</span><br><span class="line">true</span><br><span class="line">&gt; userRoles.get(u1);</span><br><span class="line">&#x27;User&#x27;</span><br><span class="line">&gt; userRoles2.get(u4);</span><br><span class="line">undefined</span><br><span class="line">&gt; userRoles2.has(u4);</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>如果key已经在map中，调用set()后key对应的value就会被替换。<br>size属性可以返回map中元素的个数。      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; userRoles.size</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>使用keys()方法获取map中所有的键，values()方法获取所有的值。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const keys = userRoles.keys();</span><br><span class="line">undefined</span><br><span class="line">&gt; keys</span><br><span class="line">MapIterator &#123;</span><br><span class="line">  &#123; name: &#x27;Cynthia&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Jackson&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;Olive&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;James&#x27; &#125; &#125;</span><br><span class="line">&gt; const values = userRoles.values();</span><br><span class="line">undefined</span><br><span class="line">&gt; values</span><br><span class="line">MapIterator &#123; &#x27;User&#x27;, &#x27;User&#x27;, &#x27;Admin&#x27;, &#x27;Admin&#x27; &#125; </span><br></pre></td></tr></table></figure>

<p>使用展开运算符可返回数组。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [...userRoles2.keys()]</span><br><span class="line">[ &#123; name: &#x27;Cynthia&#x27; &#125;, &#123; name: &#x27;Jackson&#x27; &#125;, &#123; name: &#x27;Olive&#x27; &#125; ]</span><br><span class="line">&gt; [...userRoles2.values()]</span><br><span class="line">[ &#x27;User&#x27;, &#x27;User&#x27;, &#x27;Admin&#x27; ] </span><br></pre></td></tr></table></figure>

<p>delete()方法删除map中的一个条目。返回true表示这个条目在Map中，否则返回false。<br>clear()方法删除map中的所有条目。</p>
<h3 id="Weak-maps"><a href="#Weak-maps" class="headerlink" title="Weak maps"></a>Weak maps</h3><p>WeakMap跟Map在本质上是相同的。除以下几点：      </p>
<ul>
<li>key必须是对象</li>
<li>WeakMap中的key可以被垃圾回收</li>
<li>WeakMap不能迭代或者清空</li>
</ul>
<p>通常，只要还有地方在引用某个对象，JavaScript就会将它保留在内存中。例如：如果有一个对象是Map中的key，那么只要这个Map存在，这个对象就会一直在内存中。但WeakMap却不是这样。正因如此，WeakMap不能被迭代（因为在迭代中，暴露处于垃圾回收过程中的对象，是非常危险的）。      </p>
<h3 id="sets"><a href="#sets" class="headerlink" title="sets"></a>sets</h3><p>set是一个不允许重复数据的集合。<br>add()方法添加一个条目。<br>size属性返回set大小。<br>delete()方法删除条目。返回true表示这个条目在set中，否则返回false。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; const roles = new Set();</span><br><span class="line">undefined</span><br><span class="line">&gt; roles.add(&#x27;User&#x27;);</span><br><span class="line">Set &#123; &#x27;User&#x27; &#125;</span><br><span class="line">&gt; roles.add(&#x27;Admin&#x27;);</span><br><span class="line">Set &#123; &#x27;User&#x27;, &#x27;Admin&#x27; &#125;</span><br><span class="line">&gt; roles.size;</span><br><span class="line">2</span><br><span class="line">&gt; roles.delete(&#x27;User&#x27;);</span><br><span class="line">true</span><br><span class="line">&gt; roles</span><br><span class="line">Set &#123; &#x27;Admin&#x27; &#125; </span><br></pre></td></tr></table></figure>

<h3 id="Weak-sets"><a href="#Weak-sets" class="headerlink" title="Weak sets"></a>Weak sets</h3><p>Weak sets只能包含对象，这些对象可能会被垃圾回收。跟WeakMap类似，WeakSet中的值不能被迭代。折让它变得很特殊，很难找到它的用例。事实上，weak sets的唯一用处是判断给定对象是不是一个set。    </p>
<h2 id="对象属性配置和代理"><a href="#对象属性配置和代理" class="headerlink" title="对象属性配置和代理"></a>对象属性配置和代理</h2><h3 id="存取器属性：getter和setter"><a href="#存取器属性：getter和setter" class="headerlink" title="存取器属性：getter和setter"></a>存取器属性：getter和setter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; const USER_EMAIL = Symbol();</span><br><span class="line">undefined</span><br><span class="line">&gt; class User &#123;</span><br><span class="line">    set email(value) &#123;</span><br><span class="line">        if (!/@/.test(value)) throw new Error(`invalid email: $&#123;value&#125; `);</span><br><span class="line">        this[USER_EMAIL] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    get email() &#123;</span><br><span class="line">        return this[USER_EMAIL];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const u = new User();</span><br><span class="line">undefined</span><br><span class="line">&gt; u.email = &#x27;f123456@126.com&#x27;;</span><br><span class="line">&quot;f123456@126.com&quot;</span><br><span class="line">&gt; u.email</span><br><span class="line">&quot;f123456@126.com&quot;</span><br></pre></td></tr></table></figure>
<p>setter和getter可以不同时使用，只是用getter表示只读属性。     </p>
<h3 id="对象属性的属性"><a href="#对象属性的属性" class="headerlink" title="对象属性的属性"></a>对象属性的属性</h3><h6 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; const obj = &#123;foo: &#x27;bar&#x27;&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;);</span><br><span class="line">&#123; value: &#x27;bar&#x27;,</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true &#125;</span><br></pre></td></tr></table></figure>
<p>此方法暴露了这个字段的三个属性：<br>可写的：控制该字段的值是否可变。<br>可枚举的：当枚举对象中的属性时，控制该字段是否被包含在其中（使用for … in、Object.keys或者展开运算符）。<br>可配置的：控制该字段是否可以从对象中删除，或者字段的属性是否可以被更改。      </p>
<h6 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h6><p>通过它可以控制字段的属性，可以创建一个新的字段，或者更改已有的字段（只要改字段是可配置的）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; const obj = &#123;foo: &#x27;bar&#x27;&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;);</span><br><span class="line">&#123; value: &#x27;bar&#x27;,</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true &#125;</span><br><span class="line">&gt; Object.defineProperty(obj, &#x27;foo&#x27;, &#123;writable: false&#125;);</span><br><span class="line">&#123; foo: &#x27;bar&#x27; &#125;</span><br><span class="line">&gt; obj.foo = 3;</span><br><span class="line">3</span><br><span class="line">&gt; Object.getOwnPropertyDescriptor(obj, &#x27;foo&#x27;);</span><br><span class="line">&#123; value: &#x27;bar&#x27;,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true &#125;</span><br><span class="line">&gt; obj.foo</span><br><span class="line">&#x27;bar&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="对象保护：冻结、封装、以及阻止扩展"><a href="#对象保护：冻结、封装、以及阻止扩展" class="headerlink" title="对象保护：冻结、封装、以及阻止扩展"></a>对象保护：冻结、封装、以及阻止扩展</h3><p>冻结可以阻止对象的任何修改，一旦对象被冻结，以下操作都是不允许的。   </p>
<ul>
<li>给属性设值</li>
<li>调用更改属性值得方法</li>
<li>调用setter（setter可以更改对象的属性值）</li>
<li>添加新属性</li>
<li>添加新方法</li>
<li>更改已有属性或方法的配置</li>
</ul>
<p>从本质上讲，冻结会让对象不可变，它对只包含数据的对象最为实用，因为在冻结包含方法的对象时，会导致一些修改对象状态的方法无法产生。<br>Object.freeze 函数冻结对象。<br>Object.isFrozen 函数判断该对象是否被冻结。      </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; const appInfo = &#123;</span><br><span class="line">... company: &#x27;White&#x27;,</span><br><span class="line">... version: &#x27;1.3.5&#x27;,</span><br><span class="line">... buildId: &#x27;0a9998s&#x27;,</span><br><span class="line">... copyright() &#123;</span><br><span class="line">..... return `@$&#123;new Date().getFullYear()&#125;, $&#123;this.company&#125;`;</span><br><span class="line">..... &#125;,</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Object.isFrozen(appInfo);</span><br><span class="line">false</span><br><span class="line">&gt; Object.freeze(appInfo);</span><br><span class="line">&#123; company: &#x27;White&#x27;,</span><br><span class="line">  version: &#x27;1.3.5&#x27;,</span><br><span class="line">  buildId: &#x27;0a9998s&#x27;,</span><br><span class="line">  copyright: [Function: copyright] &#125;</span><br><span class="line">&gt; Object.isFrozen(appInfo);</span><br><span class="line">true</span><br><span class="line">&gt; appInfo.newProp = &#x27;test&#x27;;</span><br><span class="line">&#x27;test&#x27;</span><br><span class="line">&gt; appInfo</span><br><span class="line">&#123; company: &#x27;White&#x27;,</span><br><span class="line">  version: &#x27;1.3.5&#x27;,</span><br><span class="line">  buildId: &#x27;0a9998s&#x27;,</span><br><span class="line">  copyright: [Function: copyright] &#125;</span><br><span class="line">&gt; appInfo.newProp</span><br><span class="line">undefined</span><br><span class="line">&gt; delete appInfo.company</span><br><span class="line">false</span><br><span class="line">&gt; appInfo</span><br><span class="line">&#123; company: &#x27;White&#x27;,</span><br><span class="line">  version: &#x27;1.3.5&#x27;,</span><br><span class="line">  buildId: &#x27;0a9998s&#x27;,</span><br><span class="line">  copyright: [Function: copyright] &#125;</span><br><span class="line">&gt; appInfo.company</span><br><span class="line">&#x27;White&#x27;</span><br><span class="line">&gt; appInfo.company = &#x27;test&#x27;</span><br><span class="line">&#x27;test&#x27;</span><br><span class="line">&gt; appInfo</span><br><span class="line">&#123; company: &#x27;White&#x27;,</span><br><span class="line">  version: &#x27;1.3.5&#x27;,</span><br><span class="line">  buildId: &#x27;0a9998s&#x27;,</span><br><span class="line">  copyright: [Function: copyright] &#125;</span><br><span class="line">&gt; appInfo.company</span><br><span class="line">&#x27;White&#x27;</span><br></pre></td></tr></table></figure>

<p>封装可以阻止在对象上添加属性、重新配置属性，以及移除已有属性。封装可以用在类的实例上，这时操作对象属性的方法仍然有效（只要它们没有试图重新配置某个属性）。<br>Object.seal 封装一个对象。<br>Object.isSealed 判断对象是否被封装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Logger &#123;</span><br><span class="line">... constructor(name) &#123;</span><br><span class="line">..... this.name = name;</span><br><span class="line">..... this.log = [];</span><br><span class="line">..... &#125;</span><br><span class="line">... add(entry) &#123;</span><br><span class="line">..... this.log.push(&#123;</span><br><span class="line">....... log: entry,</span><br><span class="line">....... timestamp: Date.now(),</span><br><span class="line">....... &#125;);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; const log = new Logger(&#x27;Captain&#x27;s log&#x27;);</span><br><span class="line">... </span><br><span class="line">&gt; const log = new Logger(&quot;Captain&#x27;s log&quot;);</span><br><span class="line">undefined</span><br><span class="line">&gt; Object.isSealed(log)</span><br><span class="line">false</span><br><span class="line">&gt; Object.seal(log)</span><br><span class="line">Logger &#123; name: &#x27;Captain\&#x27;s log&#x27;, log: [] &#125;</span><br><span class="line">&gt; Object.isSealed(log)</span><br><span class="line">true</span><br><span class="line">&gt; log.name = &quot;Captain&#x27;s Boring Log&quot;;</span><br><span class="line">&#x27;Captain\&#x27;s Boring Log&#x27;</span><br><span class="line">&gt; log</span><br><span class="line">Logger &#123; name: &#x27;Captain\&#x27;s Boring Log&#x27;, log: [] &#125;</span><br><span class="line">&gt; log.name</span><br><span class="line">&#x27;Captain\&#x27;s Boring Log&#x27;</span><br><span class="line">&gt; log.add(&#x27;another boring day at sea....&#x27;);</span><br><span class="line">undefined</span><br><span class="line">&gt; log</span><br><span class="line">Logger &#123;</span><br><span class="line">  name: &#x27;Captain\&#x27;s Boring Log&#x27;,</span><br><span class="line">  log: </span><br><span class="line">   [ &#123; log: &#x27;another boring day at sea....&#x27;,</span><br><span class="line">       timestamp: 1550479369695 &#125; ] &#125;</span><br><span class="line">&gt; log.newProp = &#x27;test&#x27;;</span><br><span class="line">&#x27;test&#x27;</span><br><span class="line">&gt; log</span><br><span class="line">Logger &#123;</span><br><span class="line">  name: &#x27;Captain\&#x27;s Boring Log&#x27;,</span><br><span class="line">  log: </span><br><span class="line">   [ &#123; log: &#x27;another boring day at sea....&#x27;,</span><br><span class="line">       timestamp: 1550479369695 &#125; ] &#125;</span><br><span class="line">&gt; log.name</span><br><span class="line">&#x27;Captain\&#x27;s Boring Log&#x27;</span><br><span class="line">&gt; log.name.test</span><br><span class="line">undefined</span><br><span class="line">&gt; log</span><br><span class="line">Logger &#123;</span><br><span class="line">  name: &#x27;Captain\&#x27;s Boring Log&#x27;,</span><br><span class="line">  log: </span><br><span class="line">   [ &#123; log: &#x27;another boring day at sea....&#x27;,</span><br><span class="line">       timestamp: 1550479369695 &#125; ] &#125;</span><br><span class="line">&gt; Object.defineProperty(log, &#x27;log&#x27;, &#123;enumerable: false&#125;);</span><br><span class="line">TypeError: Cannot redefine property: log</span><br><span class="line">    at Function.defineProperty (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure>

<p>阻止扩展是最脆弱的包含，它只能防止给类添加新属性。<br>Object.preventExtensions  阻止扩展<br>Object.isExtensiable  判断是否阻止扩展</p>
<p><img src="/2016/09/29/JavaScript2/objectProtect.png" alt="对象保护选项"></p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>ES6新特性，提供了额外的元编程功能（元编程是指程序自我修改的能力）。<br>对象代理本质上是指拦截和（可选地）修改该对象上的操作的能力，     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt; const coefficients = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 5,</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; coefficients</span><br><span class="line">&#123;a: 1, b: 2, c: 5&#125;</span><br><span class="line">&gt; function evaluate(x, c) &#123;</span><br><span class="line">    return c.a + c.b * x + c.c * Math.pow(x, 2);</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; evaluate(5, coefficients)</span><br><span class="line">136</span><br><span class="line">&gt; let coefficients1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; evaluate(5, coefficients1)</span><br><span class="line">NaN</span><br><span class="line">&gt; const betterCoefficients = new Proxy(coefficients, &#123;</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        return target[key] || 0;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">undefined</span><br><span class="line">&gt; const betterCoefficients1 = new Proxy(coefficients1, &#123;</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        return target[key] || 0;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">undefined</span><br><span class="line">&gt; evaluate(5, betterCoefficients)</span><br><span class="line">136</span><br><span class="line">&gt; evaluate(5, betterCoefficients1)</span><br><span class="line">76</span><br></pre></td></tr></table></figure>
<p>代理构造方法的第一个参数是要代理的目标，或者被代理的对象。第二个参数是处理器，它可以指定要拦截的动作。在这种情况下，只拦截了get方法（要把它和get属性访问器区分开：它对一般的属性和get访问器都有效）表示的属性访问。get函数接收三个参数（只用了两个）：它们分别是目标、属性的key（字符串或符号），以及接收者（代理自身，或某个继承于代理的东西）。<br>同样可以使用set处理器来拦截被设置的属性（或访问器）。比如，有一个对象，其中包含了一些危险的属性。而开发人员不希望外界直接设置这些属性，或者调用某些方法，除非有额外的设置。使用额外的设置是一个叫作allowDangerousOperations的属性，要先将它设置为true，才能访问这些危险的属性。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; const cook = &#123;</span><br><span class="line">    name: &#x27;Walt&#x27;,</span><br><span class="line">    redPhosphorus: 100,</span><br><span class="line">    water: 500</span><br><span class="line">&#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; const protectedCook = new Proxy(cook, &#123;</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        if (key === &#x27;redPhosphorus&#x27;) &#123;</span><br><span class="line">            if (target.allowDangerousOperations)</span><br><span class="line">                return target.redPhosphorus = value;</span><br><span class="line">            else</span><br><span class="line">                return console.log(&#x27;too dangerous!&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">undefined</span><br><span class="line">&gt; protectedCook.water = 550</span><br><span class="line">550</span><br><span class="line">&gt; protectedCook.redPhosphorus = 150</span><br><span class="line">VM1576:7 too dangerous!</span><br><span class="line">150</span><br><span class="line">&gt; protectedCook.redPhosphorus</span><br><span class="line">100</span><br><span class="line">&gt; protectedCook.allowDangerousOperations = true;</span><br><span class="line">true</span><br><span class="line">&gt; protectedCook.redPhosphorus = 150</span><br><span class="line">150</span><br><span class="line">&gt; protectedCook.redPhosphorus</span><br><span class="line">150</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/09/16/javascript1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/16/javascript1/" class="post-title-link" itemprop="url">JavasSript（ES6）1  --基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-09-16 09:45:10" itemprop="dateCreated datePublished" datetime="2016-09-16T09:45:10+08:00">2016-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-12 22:34:14" itemprop="dateModified" datetime="2019-02-12T22:34:14+08:00">2019-02-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="包管理工具-npm"><a href="#包管理工具-npm" class="headerlink" title="包管理工具 npm"></a>包管理工具 npm</h2><p>npm 支持两种级别的安装包：全局和本地。全局安装的包通常是一些用于开发过程中的命令工具，本地安装包则是用于具体项目上的包。<br><code>npm install</code> 命令用于安装包<br>npm安装安装模块将安装到项目根目录下的node_modules文件夹下。<br>npm通过package.json文件来管理安装的模块，通过<code>npm init</code>生成package.json文件。<br>依赖分为常规依赖和开发依赖。开发依赖是指那些只在项目构建时需要的依赖，运行时不需要。<br><code>npm install moduleName</code> #安装模块到项目目录下<br><code>npm install -g moduleName</code> #将模块安装到全局，npm config prefix可查看安装位置<br><code>npm install --save moduleName</code> #将模块安装到项目目录下，并在package文件的dependencies节点写入依赖<br><code>npm install --save-dev moduleName</code> #将模块安装到项目目录下，并在package文件中的devDependencies节点写入依赖，该模块只作为开发环境的一部分，不会作为产品代码发布</p>
<h2 id="构建工具-Gulp-和-Grunt"><a href="#构建工具-Gulp-和-Grunt" class="headerlink" title="构建工具 Gulp 和 Grunt"></a>构建工具 Gulp 和 Grunt</h2><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><code>sudo npm install -g gulp</code> 全局安装Gulp<br>每个项目都需要本地Gulp，切换到项目目录下，运行<code>npm install --save-dev gulp</code>，程序开发依赖它，运行不依赖它。<br>创建Gulpfile（gulpfile.js）     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const gulp = require(&#x27;gulp&#x27;);   </span><br><span class="line">// Gulp dependencies go here                    </span><br><span class="line">gulp.task(&#x27;default&#x27;, function() &#123;</span><br><span class="line">	//	Gulp tasks go here</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>$ gulp</code> 验证gulp能否正常运行     </p>
<h2 id="转换器-Babel"><a href="#转换器-Babel" class="headerlink" title="转换器 Babel"></a>转换器 Babel</h2><p>es5 到 es6 的转换<br><code>$ npm install --save-dev babel-preset-es2015</code><br>并在项目的根目录下创建.babelrc(默认会被隐藏)的文件，通过它识别所有使用ES6的地方，文件内容：<br><code>&#123; &quot;presets&quot; : [&quot;es2015&quot;]&#125;</code></p>
<h2 id="格式审查工具-ESLint"><a href="#格式审查工具-ESLint" class="headerlink" title="格式审查工具 ESLint"></a>格式审查工具 ESLint</h2><p>安装 <code>npm install g eslint</code>，在项目目录下运行<code>eslint --init</code>创建.eslintrc文件，运行eslint <code>eslint es6/test.js</code>。<br>可以将ESLint集成到编辑器中，也可以jia到Gulpfile中。</p>
<hr>
<hr>
<h1 id="javascript基础"><a href="#javascript基础" class="headerlink" title="javascript基础"></a>javascript基础</h1><h2 id="字面量、变量、常量和数据类型"><a href="#字面量、变量、常量和数据类型" class="headerlink" title="字面量、变量、常量和数据类型"></a>字面量、变量、常量和数据类型</h2><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>变量 <code>let currentVariable = 21; </code><br>常量 <code>const currentVariable = 21; </code><br>优先使用常量const    </p>
<h3 id="基本类型和对象"><a href="#基本类型和对象" class="headerlink" title="基本类型和对象"></a>基本类型和对象</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul>
<li>数字</li>
<li>字符串</li>
<li>布尔</li>
<li>null</li>
<li>undefined</li>
<li>符号</li>
</ul>
<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><ul>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Map 和 WeakMap</li>
<li>Set 和 WeakSet</li>
</ul>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>NaN不是数字，可用作占位符。<br>数字对应Number对象   </p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串在JavaScript中标识Unicode文本。<br>可在单引号字符串’ ‘中使用双引号””，也可在双引号字符串””中使用单引号’’。      </p>
<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>通过加号 + 可连接字符串。<br>字符串模板一种快速插值的方式。它用&#96;代替引号。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let currentVariable = 19.5;</span><br><span class="line">const message = `The current temperature is $&#123;currentVariable&#125; \u00b0c`;</span><br></pre></td></tr></table></figure>
<h5 id="数字用作字符串"><a href="#数字用作字符串" class="headerlink" title="数字用作字符串"></a>数字用作字符串</h5><p>数字加字符串是字符串</p>
<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>ES6新特性，代表唯一标识<br>Symbol()构造方法来创建符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const RED = Symbol();</span><br><span class="line">const ORANGE = Symbol(&#x27;the color of a sunset!&#x27;);</span><br><span class="line">RED === ORANGE // false:每个符号都是唯一的</span><br></pre></td></tr></table></figure>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><code>const obj = &#123;&#125;</code>  对象属性名称必须是字符串或符号，值可以是任何类型。<br>对象可以包含函数 <code>obj.func = function() &#123;return &#39;&#39;&#125;</code><br>可以通过delete操作来删除对象中的属性 <code>delete obj.attribute1;</code></p>
<h4 id="Number-String和Boolean对象"><a href="#Number-String和Boolean对象" class="headerlink" title="Number, String和Boolean对象"></a>Number, String和Boolean对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const s = &quot;hello&quot;;</span><br><span class="line">s.toUpperCase();</span><br></pre></td></tr></table></figure>
<p>s是基本的字符串类型，JavaScript创建了一个临时的String对象，该对象有一个toUpperCase函数，一旦函数被调用了，该临时对象就会被删除。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组长度不固定，可以随时添加和删除元素。<br>数组中元素的类型是多样的，每个元素都可以是任意类型。<br>数组下标从0开始。    </p>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h4 id="映射和集合"><a href="#映射和集合" class="headerlink" title="映射和集合"></a>映射和集合</h4><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><h5 id="转换成数字"><a href="#转换成数字" class="headerlink" title="转换成数字"></a>转换成数字</h5><ol>
<li>Number对象构造<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numStr = &quot;33.3&quot;;</span><br><span class="line">const num = Number(numStr);  //创建一个数值，不是一个Number对象的实例， 如果字符串内容不符合数字格式，就返回NaN</span><br></pre></td></tr></table></figure></li>
<li>parseInt和parseFloat<br>使用parseInt时，可以指定一个基数，它代表要将数字转换成什么样的格式（）<br>parseInt和parseFloat会忽略任何跟数字不相关的信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = parseInt(&quot;16 volts&quot;, 10);</span><br><span class="line">const b = parseInt(&quot;3a&quot;, 16);</span><br></pre></td></tr></table></figure>
<p>日期对象转换成数字，转换结果是从1970年1月1日0:00:00到当前的毫秒数，使用valueOf()方法     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const d = new Date();</span><br><span class="line">const ts = d.valueOf();</span><br></pre></td></tr></table></figure>
<h5 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h5><p>JavaScript中任何对象都有toString()方法，toString()返回该对象的字符串形式。<br>数组的toString()方法将每个元素转换成字符串，然后用逗号将这些字符串连接起来组成一个大的字符串。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const att = [1, true, &#x27;hello&#x27;];   </span><br><span class="line">att.toString();     // att = &quot;1,true,hello&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><h4 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h4><h4 id="do-…-while-循环"><a href="#do-…-while-循环" class="headerlink" title="do … while 循环"></a>do … while 循环</h4><p>do … while 语句循环体至少会被执行一次。     </p>
<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><h3 id="JavaScript-中的控制语句"><a href="#JavaScript-中的控制语句" class="headerlink" title="JavaScript 中的控制语句"></a>JavaScript 中的控制语句</h3><h4 id="控制流异常"><a href="#控制流异常" class="headerlink" title="控制流异常"></a>控制流异常</h4><p>break   提前结束循环<br>continue 跳到循环的下一步<br>throw   指出必须被异常处理器所捕获的异常</p>
<h5 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h5><p>switch 语句的条件是一个可以计算值的表达式。    </p>
<h5 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h5><p>for…in循环是为那些循环对象中有一个属性key而设计的。语法是：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (变量 in 对象) </span><br><span class="line">	语句</span><br></pre></td></tr></table></figure>
<h5 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h5><p>for…of运算符是ES6中的新语法，在集合中遍历元素的方法.  </p>
<h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><p>严格相等（&#x3D;&#x3D;&#x3D;），值类型和值都相同。<br>严格不相等（!&#x3D;&#x3D;），值类型和值不相同。<br>非严格相等（&#x3D;&#x3D;），它们隶属同一个对象，或者可以强制转换成相同的值。<br>非严格不相等（!&#x3D;）<br>NaN与任何值都不相等，包括它自己（即， NaN &#x3D;&#x3D;&#x3D; NaN 和 NaN &#x3D;&#x3D; NaN 都是false）， 判断某个数字是不是NaN，可以使用内置函数isNaN()</p>
<h5 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h5><p>JavaScript中，+运算符既可以用作数字的加法，也可以用作字符串连接。会根据运算符对象的类型来决定执行加法还是字符串连接，这两种的执行顺序都是从左至右。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 + 5 + &quot;8&quot;    //结果为 &quot;88&quot;</span><br><span class="line">&quot;3&quot; + 5 + 8    //结果为 &quot;358&quot;</span><br></pre></td></tr></table></figure>
<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>以下值代表false：        </p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false   </li>
<li>0</li>
<li>NaN</li>
<li>‘’(空字符串)</li>
</ul>
<p>以下值代表true：</p>
<ul>
<li>所有对象（包括valueof()方法返回false的对象）</li>
<li>所有数组（包括空数组）</li>
<li>仅含有空格的字符串</li>
<li>字符串”false”</li>
</ul>
<h4 id="与、或、非"><a href="#与、或、非" class="headerlink" title="与、或、非"></a>与、或、非</h4><p>x和y的异或（XOR）运算 <code>(x || y) &amp;&amp; x !== y</code></p>
<h5 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h5><p>&amp;&amp; 运算，第一个计算值为false时就不会计算第二个的值。<br>|| 运算，第一个计算值为true时就不会计算第二个的值。</p>
<h4 id="类型判断运算符"><a href="#类型判断运算符" class="headerlink" title="类型判断运算符"></a>类型判断运算符</h4><p>typeof</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     &gt;&gt;  &quot;undefined&quot;</span><br><span class="line">typeof null 			 &gt;&gt;  &quot;object&quot;   //历史遗留问题</span><br><span class="line">typeof &#123;&#125;				 &gt;&gt;  &quot;object&quot;</span><br><span class="line">typeof true          &gt;&gt;  &quot;boolean&quot;</span><br><span class="line">typeof 1             &gt;&gt;  &quot;number&quot;</span><br><span class="line">typeof &quot;&quot;				 &gt;&gt;  &quot;string&quot;</span><br><span class="line">typeof Symbol()		 &gt;&gt;  &quot;symbol&quot;</span><br><span class="line">typeof function()    &gt;&gt;  &quot;function&quot;</span><br></pre></td></tr></table></figure>
<p>因为typeof是一个运算符，不需要搭配括号。</p>
<h4 id="解析结构"><a href="#解析结构" class="headerlink" title="解析结构"></a>解析结构</h4><p>将一个对象或者数组“分解”成多个单独的值。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;b: 2, c: 3, d: 4&#125;;</span><br><span class="line">//对象解构赋值</span><br><span class="line">const &#123;a, b, c&#125; = obj;</span><br><span class="line">a;  //undefined, obj中不存在属性&quot;a&quot;</span><br><span class="line">b;  // 2</span><br><span class="line">c;  // 3</span><br><span class="line">d;  // 引用error: &quot;d&quot;未定义</span><br></pre></td></tr></table></figure>
<p>对象解构也可以在一个赋值语句中完成，但是这个语句必须被括号括起来。否则，JavaScript解释器会认为左边的部分是一个代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;b: 2, c: 3, d: 4&#125;;</span><br><span class="line">let a, b, c;</span><br><span class="line">//会报错</span><br><span class="line">&#123;a, b, c&#125; = obj;</span><br><span class="line">//正常运行</span><br><span class="line">(&#123;a, b, c&#125; = obj);</span><br></pre></td></tr></table></figure>
<p>数组解析时，可以给数组的元素任意指定变量名（按顺序）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const att = [1, 2, 3];</span><br><span class="line">let [x,y] = arr;</span><br><span class="line">x;    // 1</span><br><span class="line">y;    // 2</span><br><span class="line">z;    // 错误： z未定义</span><br></pre></td></tr></table></figure>
<p>展开运算符（…）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">let [x, y, ...rest] = arr;</span><br><span class="line">x;       //   1</span><br><span class="line">y;       //   2</span><br><span class="line">rest;    //   [3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>数组解构可以很方便地交换变量的值（以前可能需要一个中间变量来完成）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 5, b = 10;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">a;   //  10</span><br><span class="line">b;   //  5</span><br></pre></td></tr></table></figure>
<p>数组解构不仅适用于数组，还适用于任何可迭代的对象。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果没有明确指定return语句，返回值将会是undefined。函数可以返回任何类型的值。</p>
<h3 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h3><p>在JavaScript中，函数是一个对象，可以被传递和赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function func1() &#123;</span><br><span class="line">	console.log(&#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">func1();    // &#x27;hello&#x27;</span><br><span class="line">func1;      // 函数func1()</span><br></pre></td></tr></table></figure>
<p>可以将一个函数赋值给一个变量，就可以通过这个变量来调用函数。也可把函数赋值给一个对象的属性。   </p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>字符串、数值等参数是值类型。对象、数组等是引用类型，对象属性在函数内部发生变化，函数外也随着发生了变化。<br>在JavaScript中，函数名相同，参数不同（类型不同，个数不同），认为是同一个函数，如果在调用时没有传入参数，函数就会接收到一个undefined的参数。   </p>
<h3 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getSentence(&#123;subject, verb, object&#125;) &#123;</span><br><span class="line">	return `$&#123;subject&#125; $&#123;verb&#125; $&#123;object&#125;`</span><br><span class="line">&#125;</span><br><span class="line">const o = &#123;</span><br><span class="line">	subject: &#x27;I&#x27;,</span><br><span class="line">	verb: &#x27;love&#x27;,</span><br><span class="line">	object: &#x27;JavaScript&#x27;</span><br><span class="line">&#125;</span><br><span class="line">getSentence(o);     // &#x27;I love JavaScript&#x27;</span><br></pre></td></tr></table></figure>
<p>在解构赋值中，参数属性名必须是字符串标识符，而且如果传入的对象不存在与参数属性名匹配的属性，该属性将会接受一个undefined值。<br>解构参数可以是一个数组。    </p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>关于this变量的一个细节，当在嵌套函数中访问它时经常会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const o = &#123;</span><br><span class="line">	name: &#x27;Julie&#x27;,</span><br><span class="line">	greetBackwords: function() &#123;</span><br><span class="line">		let self = this;</span><br><span class="line">		function getReverseName() &#123;</span><br><span class="line">			let nameBackwards = &#x27;&#x27;;</span><br><span class="line">			for (let i = self.name.length - 1; i--) &#123;</span><br><span class="line">				nameBackwards += this.name[i];</span><br><span class="line">			&#125;</span><br><span class="line">			return nameBackwards;</span><br><span class="line">		&#125;</span><br><span class="line">		return `$&#123;getReverseName()&#125; si eman ym, olleH&#x27;;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">o.greetBackwards();</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数允许使用以下3种方式来简化语法：    </p>
<ul>
<li>可以省略function这个单词</li>
<li>如果函数只有一个参数，可以省略括号</li>
<li>如果函数体是一个单独的表达式，则可以省略花括号和返回语句</li>
</ul>
<p>箭头函数大多是匿名的。可以将它们赋值给变量。<br>箭头函数跟普通函数的区别：this是跟语句绑定起来的，就像其他变量一样。不能把箭头函数当做对象构造器，同时，指定的参数变量在箭头函数中也不生效。   </p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>故意将某个函数定义在一个指定的作用域中，并明确地指定出它对该作用域所具备的访问权限，通常称这种形式为闭包（可以认为封闭了函数的作用域）</p>
<h3 id="即时调用函数表达式-IIFE"><a href="#即时调用函数表达式-IIFE" class="headerlink" title="即时调用函数表达式(IIFE)"></a>即时调用函数表达式(IIFE)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">	//code</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>可以从IIFE中返回任何想要的结果，比较常见的返回值有数组、对象、以及函数。<br>IIFE的好处是，任何内部信息都有自己的作用域，并且因为它本身就是函数，它还可以向作用域外传递信息。    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const message = (function() &#123;</span><br><span class="line">	const secret = &quot;I&#x27;m a secret!&quot;;</span><br><span class="line">	return `The secret is $&#123;secret.length&#125; characters long.`</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(message);</span><br></pre></td></tr></table></figure>
<p>如下例子中打印自己被调用的次数，而且次数不会被篡改。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const f = (function() &#123;</span><br><span class="line">	let count = 0;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return `count $&#123;++count&#125;`</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">f();    // count 0</span><br><span class="line">f();    // count 1</span><br><span class="line">// count 被安全地隐藏在IIFE中，外界没法篡改它</span><br></pre></td></tr></table></figure>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES5的语法允许存在隐式全局变量。如果忘记使用var声明某个变量，JavaScript会不暇思索地认为开发人员引用一个全局变量，如果该全局变量不存在，它会替开发人员创建一个。<br>严格模式可以阻止隐式全局变量。在开始编写代码前，单独引入一行字符串“use strict”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/07/03/flask/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/03/flask/" class="post-title-link" itemprop="url">Flask</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-03 15:16:06" itemprop="dateCreated datePublished" datetime="2016-07-03T15:16:06+08:00">2016-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-26 00:48:22" itemprop="dateModified" datetime="2019-01-26T00:48:22+08:00">2019-01-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2016/01/06/python1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/01/06/python1/" class="post-title-link" itemprop="url">python</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-06 00:46:10" itemprop="dateCreated datePublished" datetime="2016-01-06T00:46:10+08:00">2016-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-26 00:47:22" itemprop="dateModified" datetime="2019-01-26T00:47:22+08:00">2019-01-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fhclk"
      src="/images/avatar1.png">
  <p class="site-author-name" itemprop="name">fhclk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fhclk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fhclk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fhclk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
