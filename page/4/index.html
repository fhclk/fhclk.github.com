<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fhclk.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="拾荒者">
<meta property="og:url" content="http://fhclk.github.io/page/4/index.html">
<meta property="og:site_name" content="拾荒者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fhclk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fhclk.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>拾荒者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拾荒者</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">昨夜西风凋碧树，独上高楼，望尽天涯路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/03/05/wx-applet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/05/wx-applet/" class="post-title-link" itemprop="url">微信.小程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-05 08:17:00" itemprop="dateCreated datePublished" datetime="2018-03-05T08:17:00+08:00">2018-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-02-02 10:49:54" itemprop="dateModified" datetime="2019-02-02T10:49:54+08:00">2019-02-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p>前往<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">小程序注册</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxopen/waregister?action=step1">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a> 注册小程序，一个邮箱账号对应一个小程序。<br>登录 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">微信公众平台</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com</a> ，在菜单 “设置”-“开发设置” 获取小程序的 AppID。</p>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=19020120">下载地址</a></p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/">官网开发文档</a></p>
<h4 id="设置服务器域名"><a href="#设置服务器域名" class="headerlink" title="设置服务器域名"></a>设置服务器域名</h4><p>小程序要与后端交互，需要登录“微信工作平台|小程序”，在“开发”-“开发设置”-“服务器域名”添加域名，并且服务器要支持HTTPS协议。<br>如果在开发过程中使用了web-view组件，需要在“开发设置”中的“业务域名”中添加域名，并且只有企业号对应的小程序才有此项功能，个人账户不能进行此项设置。<br><img src="/2018/03/05/wx-applet/wx-applet/domain.png" alt="域名设置">   </p>
<h3 id="成员管理"><a href="#成员管理" class="headerlink" title="成员管理"></a>成员管理</h3><p>在“管理”-“成员管理”里可以添加项目成员和体验成员，上传代码后在“版本管理”-“开发版本”中设置体验版本，已经添加的体验成员就可以扫描二维码体验小程序。    </p>
<h3 id="发布小程序"><a href="#发布小程序" class="headerlink" title="发布小程序"></a>发布小程序</h3><p>在小程序功能测试通过后，上传代码，在“开发版本”中提交审核，审核通过后在“审核版本”中发布到线上。<br><img src="/2018/03/05/wx-applet/wx-applet/publish.png" alt="发布小程序">   </p>
<p>发布成功后在微信里删除开发版本和预览版本，删除后台微信进程，重新打开微信，在小程序中搜索已发布的小程序，验证是否发布成功。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/" class="post-title-link" itemprop="url">读《聊聊架构》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-22 17:36:14" itemprop="dateCreated datePublished" datetime="2018-01-22T17:36:14+08:00">2018-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-29 14:30:54" itemprop="dateModified" datetime="2019-05-29T14:30:54+08:00">2019-05-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="认识架构"><a href="#认识架构" class="headerlink" title="认识架构"></a>认识架构</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="为什么会产生架构"><a href="#为什么会产生架构" class="headerlink" title="为什么会产生架构"></a>为什么会产生架构</h3><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="什么是抽象"><a href="#什么是抽象" class="headerlink" title="什么是抽象"></a>什么是抽象</h3><h3 id="识别问题"><a href="#识别问题" class="headerlink" title="识别问题"></a>识别问题</h3><p>遇到问题时，要识别出问题的主题，划分出问题的边界约束。<br>当遇到问题时，如果发现自己正在致力于把自己的工作完成，就要马上警惕起来，因为这样下去会演变成没有主人翁精神的工作态度。在面对概念的时候，也会不求甚解，最终导致无法真正的理解概念。作为软件工程师或架构师，我们大部分时候是要去解决别人的问题（用户的问题），“别人”是谁，是值得好好考虑的。</p>
<blockquote>
<p>发现问题永远比解决问题更加重要</p>
</blockquote>
<p>问题的主题是用户</p>
<h3 id="切分的原则"><a href="#切分的原则" class="headerlink" title="切分的原则"></a>切分的原则</h3><p>确定问题主题后，在解决问题的过程中，产生新的问题，需要做调整，而要采取新的行动解决问题，解决的方式就是架构拆分</p>
<h4 id="切分原则"><a href="#切分原则" class="headerlink" title="切分原则"></a>切分原则</h4><ol>
<li>被切分的生命周期，如果必须要生命周期的主题在连续时间内持续执行，而且不能够被打断并更换生命周期主体的话，就不能切分出去。这类生命周期是切分的最小粒度，受限于当前的技术水平无法进一步切分。（比如十月怀胎，不能10人怀胎1人1月）</li>
<li>每个生命周期的负责人，对所负责生命周期的权利和义务必须是对等的。</li>
<li>切分出来的生命周期，不应该超出一个自然人的负载。根据没人能力实际情况实际情况进行调整。切分出来的只能是非核心生命周期，这些生命周期必须是完整的，内聚的。</li>
<li>切分是内部活动，内部切分对整个系统的外部都是透明的</li>
</ol>
<h4 id="树和分层"><a href="#树和分层" class="headerlink" title="树和分层"></a>树和分层</h4><p>所有的架构拆分都应该形成树的结构，并且层次越少越好。其中节点的权责对等，如果出现不对等的情况要及时调整，保持效率。</p>
<h4 id="切分和建模"><a href="#切分和建模" class="headerlink" title="切分和建模"></a>切分和建模</h4><p>架构切分的过程就是建模的过程。随着业务和规模的增加，就要进行拆分。拆分就需要识别核心生命周期和非核心生命周期，把非核心生命周期切分出来。切分出来的非核心生命周期形成新的模型，核心生命周期模型把所有的模型通过树组织起来，形成新的模型</p>
<p>总结. </p>
<blockquote><p>1.架构切分的导火索是人的负载太重，也就是时间不够。<br>2.架构的切分实际就是对利益相关人的利益进行切分和合并，使得每个利益相关人的权责是对等的，每个利益相关人可以为自己的利益负责。<br>3.架构切分的最终结果都会体现在组织架构上，只有这样才能够让架构落地进行。<br>4.架构切分的结果一定是一棵树状，这也是为什么会产生分层。层数越多沟通越多，效率越低，分层要越少越好。尽可能变成一棵平衡树，才能让整个系统的效率最大化。</p>
</blockquote>

<h3 id="架构与流程"><a href="#架构与流程" class="headerlink" title="架构与流程"></a>架构与流程</h3><h3 id="什么是架构师"><a href="#什么是架构师" class="headerlink" title="什么是架构师"></a>什么是架构师</h3><p>架构师需要了解清楚业务，挖掘出核心生命周期，并确定核心生命周期的主体（架构师要发现问题主体，并确定核心问题）。在确定业务核心生命周期及核心生命周期主体之后，需要对核心生命周期进行分析，剥离非核心生命周期，根据当前人员状况，合理分配非核心生命周期的权责。<br>架构师要具备调动资源的能力。架构包括设计和执行层面。架构师需要有调动资源执行项目的权力，同时也有识别项目核心生命周期，思考核心生命周期主体，合理分配权力，保证效率。</p>
<h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h3 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h3><h3 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h3><p>软件的整个生命周期会发生切分，从而形成两个子生命周期：软件开发生命周期和软件运行生命周期。<br>软件运行生命周期才是核心生命周期，因为软件运行生命周期的主体和大的生命周期一致。<br>围绕软件的生命周期，可以切分出很多非核心生命周期：    </p>
<ol>
<li>软件开发生命周期，其中又可以切分出需求生命周期、代码开发生命周期、测试生命周期。</li>
<li>软件的运行生命周期。其中包含：<br>&emsp;&emsp;&emsp;&emsp;a.软件的访问生命周期。<br>&emsp;&emsp;&emsp;&emsp;b.软件的功能生命周期。<br>&emsp;&emsp;&emsp;&emsp;c.软件的监控生命周期。</li>
</ol>
<h4 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h4><blockquote>
<p>从软件的运行生命周期角度来说，一个可运行的独立部署单元才算是一个软件。</p>
</blockquote>
<h5 id="软件开发的增长"><a href="#软件开发的增长" class="headerlink" title="软件开发的增长"></a>软件开发的增长</h5><p>一个软件项目需要多人分工合作，就需要架构切分，软件开发的核心生命周期是编写代码，在这个核心生命周期下，软件开发生命周期可被切分成不同的非核心生命周期，每个非核心生命周期围绕核心生命周期组成树状架构，在时间和空间上并行开展工作，提升产量和速度。<br>不同的拆分方式，形成了不同的软件开发模式</p>
<h5 id="软件开发的迭代"><a href="#软件开发的迭代" class="headerlink" title="软件开发的迭代"></a>软件开发的迭代</h5><h4 id="软件开发的运行生命周期"><a href="#软件开发的运行生命周期" class="headerlink" title="软件开发的运行生命周期"></a>软件开发的运行生命周期</h4><p>软件功能的使用情况，会形成功能的访问生命周期，这个生命周期和业务的子生命周期相关。<br>软件启动后，运维要对系统进行监控，如zabbix。   </p>
<h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>软件架构就是通过对软件生命周期的拆分，在符合业务架构的前提下，以达到软件本身访问增长目的的方式。这个增长需要软件开发的增长，也需要软件运行的增长，由此达到所支撑业务的增长。<br>软件架构离不开软件开发团队的组织架构，这个组织架构是软件开发生命周期和软件运行生命周期的执行者。架构的核心生命周期就是架构的执行。    </p>
<h3 id="什么是软件架构师"><a href="#什么是软件架构师" class="headerlink" title="什么是软件架构师"></a>什么是软件架构师</h3><blockquote>
<p> 技术人员如果要成为架构师，就必须跳出技术的视角，换一个角度去看技术。要把时间花在研究生命周期规律和业务的增长上，花在选择合适的技术上，而不只是追求新潮的或自己喜欢的技术。     </p>
</blockquote>
<h3 id="业务、架构和技术三者的关系"><a href="#业务、架构和技术三者的关系" class="headerlink" title="业务、架构和技术三者的关系"></a>业务、架构和技术三者的关系</h3><p>先有业务问题，才会有技术来解决业务问题。而业务的长大要求，提高了对技术的要求，导致了对业务生命周期的拆分，以并行的方式提升效率，形成了架构，也形成了新的技术。所以在三者的关系里：<br>业务是核心，技术是解决业务问题的工具，而架构师让业务长大的组织方法。<br>架构需要用技术来实现拆分，而技术需要架构来合理组织，以提升效率。</p>
<p>选择技术时需要考虑的点：<br>1.当技术所要解决的问题和拆分出来要解决的问题完全匹配时，这是最完美的。<br>2.当技术所提供的能力远远超过需要解决的问题时，往往掌握技术和维护技术就会成为负担。<br>3.当技术所提供的能力和我们所要解决的问题部分匹配时，要判断是否要采用，最终还是要看成本。<br>所以，在架构拆分的基础之上，识别并平衡技术的能力，也是架构师所需要具备的能力之一。考虑的主要因素是长期的成本和收益。    </p>
<h3 id="软件研发"><a href="#软件研发" class="headerlink" title="软件研发"></a>软件研发</h3><p>软件所面对的共有三大业务领域及其所对应的架构。    </p>
<ol>
<li>业务领域，由业务组织架构来推动业务的架构，即业务生命周期的拆分。</li>
<li>软件开发业务领域，由软件开发的业务组织架构来推动软件的业务架构，如软件的研发流程、角色分工等。所形成的是软件开发模式，不同角色的分工模型。</li>
<li>软件运行业务领域，由软件的开发工程师来负责编写代码，形成软件的架构，并支撑软件的运行。对不同的软件开发工程师进行分工，形成不同的软件开发工程师组织架构，以支撑不同的软件，与软件的架构相匹配。</li>
</ol>
<p>在软件开发生命周期中，软件工程师和软件架构师是最重要的两个角色，软件工程师负责建设，软件架构师负责组织。<br>为了支持软件工程师的工作，软件架构师的主要职责包括以下几点：     </p>
<ol>
<li>理解业务组织架构，业务组织架构支撑并推进业务架构，背后的原因是对业务生命周期的拆分。     </li>
<li>根据业务生命周期的特点和软件开发生命周期的特点，形成软件开发本身的业务体系，以及对软件开发生命周期的拆分，也就是软件开发的业务架构。    </li>
<li>根据对业务生命周期以及软件开发生命周期的拆分，形成了和两者都相匹配的软件开发团队的组织架构。    </li>
<li>对软件进行架构拆分，匹配业务架构和软件开发的业务架构。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p1.png" alt="业务、软件开发业务和软件运行业务三者间的关系">.    <h3 id="软件的架构拆分"><a href="#软件的架构拆分" class="headerlink" title="软件的架构拆分"></a>软件的架构拆分</h3><h4 id="软件团队拆分"><a href="#软件团队拆分" class="headerlink" title="软件团队拆分"></a>软件团队拆分</h4>比较好的拆分方式：一个业务团队对应一个软件开发团队。<br>这个方式要求每个业务部门都有独立的软件开发团队来配合。每个软件开发团队只对应一个业务团队，这样所形成的软件边界都很清楚，沟通也很高效。业务团队和对应的软件开发团队能够形成合力，共同解决该团队的业务问题。<br>这种方式会让软件开发团队的组织也形成一棵组织架构树，并且这棵树和业务团队的组织架构是匹配的。      <h4 id="软件的拆分"><a href="#软件的拆分" class="headerlink" title="软件的拆分"></a>软件的拆分</h4>一个软件开发团队开发一个软件。这样每个软件的职责非常明确，沟通也会比较简单，这是最好的。这时形成的还是一棵树。软件和软件之间的关系，反映的就是组织和组织之间的关系，一一对应，还是一棵树。 </li>
</ol>
<p>在拆分过程中，要避免不同的用户访问通道相互影响。因此，软件在访问通道的问题上不能重用。重用访问通道的结果，既损伤用户的利益，也损伤软件的利益，还会损伤软件开发团队和企业的利益。    </p>
<h4 id="软件开发的基础技术"><a href="#软件开发的基础技术" class="headerlink" title="软件开发的基础技术"></a>软件开发的基础技术</h4><p><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p2.png" alt="企业组织架构和软件架构_图片"><br>架构拆分的原则来源于业务自身的组织架构，使得软件架构保持和业务组织架构的匹配关系；其次来源于软件开发团队自身的组织架构；最后来源于用户的流量对软件本身的冲击。如果软件开发团队的组织架构和业务的组织架构一致，这就是损耗最小的方式，软件的架构也会更简单。</p>
<h3 id="如何写好代码"><a href="#如何写好代码" class="headerlink" title="如何写好代码"></a>如何写好代码</h3><p>内聚：内聚就是要确保一个事物的生命周期是完整的，而不是分裂的。所谓完整，就是指一个生命周期的主体，从生到死之间的整个过程中，所发生的行为和状态是累积在一个主体上的。<br>从流程角度讲，访问逻辑实际上就是实现业务流程的基础。每次访问都通过对不同角色的生命周期，也就是不同的业务逻辑进行访问，访问其实就是遍历架构树，形成业务流程，完成用户生命周期活动的推进。     </p>
<h4 id="业务逻辑分散的危害"><a href="#业务逻辑分散的危害" class="headerlink" title="业务逻辑分散的危害"></a>业务逻辑分散的危害</h4><ol>
<li>如果服务代码中混入了业务逻辑，则服务做了两件或者两件以上的事情。服务本身的责任是逻辑，这是顺序执行。加入了业务逻辑就表明做了两件或者两件以上的事情。可以分为以下两种情况：<br>&emsp;&emsp;&emsp;&emsp;a.两个不同的访问生命周期合并在一个服务中实现。<br>&emsp;&emsp;&emsp;&emsp;b.如果是有计算的逻辑的话，比如受益计算、订单金额计算等，那么这部分应该是业务代码需要完成的，不能交给服务代码来实现。这部分代码是需要单元测试的，而服务代码要和用户打交道就会有上下文相关的代码，因此不适合做单元测试。</li>
<li>黏合代码里面包含业务逻辑的话，也会做两件或者两件以上的事情，会和业务代码一样，遇到同样的问题。</li>
<li>存储代码里面如果混入了业务逻辑，则会导致业务逻辑进入到存储设备中。<br>存储一旦变成了逻辑计算的主体，绑定数据的逻辑计算就成了一个巨大的限制，会导致存储设备无法通过增加机器的方式横向扩展长大，只能换性能更好的机器纵向扩展，而纵向扩展不仅程度有限而且成本也较高。     </li>
</ol>
<h4 id="业务逻辑内聚的好处"><a href="#业务逻辑内聚的好处" class="headerlink" title="业务逻辑内聚的好处"></a>业务逻辑内聚的好处</h4><h4 id="代码架构的实例"><a href="#代码架构的实例" class="headerlink" title="代码架构的实例"></a>代码架构的实例</h4><p>如图所示，Manager类实际就是黏合代码。<br>注意事项：      </p>
<ol>
<li>不能把业务模型当做数据对象来处理。业务模型关心的是其生命周期，数据是这些生命周期行为的状态。所以黏合代码需要把业务模型转换成存储设备的实体(entity)，实体和存储设备里面的存储粒度一一对应。比如在数据库中，每个实体对应一张表，并且跟着表的变化而变化，这样就保证存储设备的变更不会影响业务模型。同样业务模型不能拿来用作服务和用户之间的数据交换媒介，只能转换为DTO（Data Transfer Object）来使用。也就是说业务模型对用户是不可见的。DTO的目的是在用户的访问操作中传输数据，并和用户交互的视图保持一致。通过增加DTO可以保证用户的访问生命周期需求变化，并不会影响到业务模型，虽然用户的访问生命周期需要变化是最频繁的，但DTO解决了这个难题。     </li>
<li>服务代码里不要考虑代码的重用。针对不同的用户提供不同的服务，确保他们之间的访问生命周期是隔离的，避免相互影响。多个角色访问同一个接口，其中一个角色改了共有接口，势必会影响其他角色对该接口的正常使用。尽量给不同的角色不同的服务，既避免通道重用又降低沟通成本。服务多不是问题，服务的生命周期管理才是问题。    </li>
<li>业务模型是必须要重用的，因为这是所有用户访问的目标。业务模型总是围绕着核心生命周期展开的一棵树状结构。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p3.png" alt="案例">          <h4 id="代码误解"><a href="#代码误解" class="headerlink" title="代码误解"></a>代码误解</h4>服务代码、黏合代码和存储代码不能有逻辑。<h4 id="软件的拆分-1"><a href="#软件的拆分-1" class="headerlink" title="软件的拆分"></a>软件的拆分</h4>软件的拆分必须要和业务的拆分对应起来，此时就可看出业务生命周期分析的好处。软件的核心是模拟业务，而业务代码是按照业务的生命周期组织的，软件拆分的目的就是把软件的业务生命周期代码进行生命周期拆分。<br>不仅仅代码内部可以进行拆分，还可以直接把某些业务生命周期的代码拆分到另外一个软件中，并把相应的服务代码、管理者代码和存储代码一起拆分过去。这个拆分方式就形成了新的软件，而对原软件的影响仅仅是对被拆分出去的业务调用方式发生了变化而已，从本地调用变成了服务调用。<br>业务生命周期的分析既是软件拆分的大前提又是架构的基因。<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3>单元测试是一种白盒测试，集成测试是一种黑盒测试。<h4 id="单元测试测什么"><a href="#单元测试测什么" class="headerlink" title="单元测试测什么"></a>单元测试测什么</h4>服务代码、管理者代码和存储代码都是不需要写单元测试的。单元测试是用来测试软件工程师自己写的逻辑，如果代码里面没有逻辑就不需要写单元测试。<h4 id="如何改造代码"><a href="#如何改造代码" class="headerlink" title="如何改造代码"></a>如何改造代码</h4>只要出现了模拟，单元测试就开始失效了。<br>对于一个逻辑“单元”，也就是方法，所依赖两个方面：一个是输入的参数，另一个是内部对外部的方法调用。只要确保输入参数不包含外部环境的上下文，同时内部代码对外部的调用也不包含对环境上下文的访问，这个方法就是可以单元测试的。<h4 id="如何做单元测试"><a href="#如何做单元测试" class="headerlink" title="如何做单元测试"></a>如何做单元测试</h4></li>
<li>构建输入参数，并预测该输入所产生的输出。</li>
<li>调用要测试的目标方法，获取输出。</li>
<li>检测目标方法的输出是否和预测的输出一致。<h3 id="软件架构和面向对象"><a href="#软件架构和面向对象" class="headerlink" title="软件架构和面向对象"></a>软件架构和面向对象</h3></li>
</ol>
<h3 id="软件架构和设计模式"><a href="#软件架构和设计模式" class="headerlink" title="软件架构和设计模式"></a>软件架构和设计模式</h3><h4 id="设计模式和架构"><a href="#设计模式和架构" class="headerlink" title="设计模式和架构"></a>设计模式和架构</h4><p>创建型模式用生命周期来理解，就是把产生对象的生命周期单独拆分出来，即发生了架构分析。结构型模式则专注于对象的不同组合方式，而行为型则主要针对对象之间的沟通。<br>软件设计模式本身就是一个架构拆分的结果，只是这个拆分被标准化了，可以被重复使用而已。而设计模式在被使用的时候，则不需要再进行设计，直接使用即可。因此设计模式就变成了一个成熟的技巧或者技术了。软件设计模式这部分的代码其实是有自己的业务领域的，这个领域就是软件的访问生命周期。<br>只有从访问代码中剥离了所有服务业务的逻辑，才有可能讨论软件访问生命周期自身的业务模型。</p>
<h4 id="设计模式的误区"><a href="#设计模式的误区" class="headerlink" title="设计模式的误区"></a>设计模式的误区</h4><p>对于业务对象来说，业务对象表达的是业务的核心分工，是不同用户所访问的目标，这部分自然是要重用的。因为现实生活中，业务的分工就是这样的，执行业务的时候按照业务的访问流程组合不同的对象即可。但对于服务、黏合代码和存储而言，它们都有自己独特的业务问题，即它们处理访问通道的，目的并不是给大家共享，也不是访问的目标。而处理好通道问题，则是按照不同角度的用户来进行分析，提供不同的通道，让他们之间的访问互不影响，才能够服务好不同的要求。访问通道是不重用的。</p>
<h3 id="软件架构和软件框架"><a href="#软件架构和软件框架" class="headerlink" title="软件架构和软件框架"></a>软件架构和软件框架</h3><h4 id="访问类框架"><a href="#访问类框架" class="headerlink" title="访问类框架"></a>访问类框架</h4><p>MVC中的模型（Model）更多的是指对试图（View）的数据支持，一般用DTO（data transfer Object）来表达。而业务模型关注的是业务生命周期及其行为，业务模型的内部数据只是这些行为的结果。MVC中的模型和业务模型是连个不同的概念，不可混用。但是两者可以通过数据转换结合起来连接沟通使用，需要类似于适配器（Adapter）的模式（如ORM）来解决这个问题。</p>
<h4 id="业务类框架"><a href="#业务类框架" class="headerlink" title="业务类框架"></a>业务类框架</h4><p>为整个行业提供解决方案，而形成的一个行业的框架。如CRM（Customer Relationship Management），CRM把和用户打交道的基本规则封装起来，然后留给各企业按照自己企业的特点做一定变化的空间，最终所形成的就是一个行业的框架。</p>
<h4 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h4><p>框架基本上都是根据业务模型，或者设计模式等，把模型中稳定的部分进行封装，形成一个大的边界，但是具体内容仍留有余地。由于业务模型或者设计模式也是架构拆分的结果，因此框架同时也属于业务架构的一个具体实现。框架对业务模型中变化的部分，一般都会提供很容易的扩展方式，使得框架使用者可以根据自己业务的特殊性对框架进行扩展，而不需要全部从头开始编码。</p>
<h4 id="框架的特点"><a href="#框架的特点" class="headerlink" title="框架的特点"></a>框架的特点</h4><p>框架往往都是无法单独运行的。软件框架基本都是一个留有扩展余地，为其他代码所引用的代码或类库。<br>框架为方便本地定制，在本地进行改造，和自己的软件结合在一起。框架和服务的另一个区别：软件引用框架是本地引用的方式，而服务是用来远程调用的。<br>框架的背后总有一个模式存在，这个模式是来解决共同问题。    </p>
<h3 id="软件运维"><a href="#软件运维" class="headerlink" title="软件运维"></a>软件运维</h3><p>运维是软件真正的核心竞争力。</p>
<h4 id="软件运行生命周期"><a href="#软件运行生命周期" class="headerlink" title="软件运行生命周期"></a>软件运行生命周期</h4><p>软件的目的是为用户提供持续不断额访问，软件运行生命周期的核心是软件访问生命周期。<br>下图所示，软件生命周期分拆树，树的遍历顺序从左至右。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p4.png" alt="软件生命周期分拆树">     </p>
<h4 id="什么是软件运维"><a href="#什么是软件运维" class="headerlink" title="什么是软件运维"></a>什么是软件运维</h4><p>软件运行生命周期可以拆分成：软件运维生命周期和软件访问生命周期。其中软件访问生命周期是核心生命周期。运维生命周期是从软件开始部署开始，到软件结束服务为止。<br><img src="/2018/01/22/%E8%AF%BB%E3%80%8A%E8%81%8A%E8%81%8A%E6%9E%B6%E6%9E%84%E3%80%8B/p5.png" alt="软件生命周期分拆树">    </p>
<h4 id="运维的业务模型"><a href="#运维的业务模型" class="headerlink" title="运维的业务模型"></a>运维的业务模型</h4><p>运维的业务目标是保证用户的访问生命周期不受影响。     </p>
<h4 id="控制变化"><a href="#控制变化" class="headerlink" title="控制变化"></a>控制变化</h4><p>任何对软件的改变，都是风险，都需要运维的关注。<br>要做好变化的控制，首先要做的是：在软件周围设立隔离区，避免软件出现在不安全的地方。其中包括软件本身、硬件、网络和电力等。     </p>
<h6 id="如何隔离"><a href="#如何隔离" class="headerlink" title="如何隔离"></a>如何隔离</h6><p>拆分软件的运行环境，区分办公环境（开发）和生产环境（运行），生产环境是一套单独的设备环境。      </p>
<h6 id="控制变更"><a href="#控制变更" class="headerlink" title="控制变更"></a>控制变更</h6><ul>
<li>软件的变更    </li>
<li>硬件的变更</li>
<li>网络的变更</li>
<li>电力的变更</li>
</ul>
<h4 id="监控变更"><a href="#监控变更" class="headerlink" title="监控变更"></a>监控变更</h4><p>监控的目的实际上就是把系统内不同生命周期的当前运行状态，通过探测器传输出来，展示到可视或可感知的设备上，来供人查看。监控非常重要的指标是实时度。      </p>
<h4 id="预警变更"><a href="#预警变更" class="headerlink" title="预警变更"></a>预警变更</h4><p>预警内容分为两部分：    </p>
<ol>
<li>软件本身业务的预警，主要包括软件、硬件、网络和电力等设备。</li>
<li>软件所实现业务的预警。<blockquote>
<p>监控是生成预警的数据基础。对业务生命周期的理解则是生成预警的规则基础。<br>预警软件本身也是需要监控和预警的，也是预警的业务。</p>
</blockquote>
</li>
</ol>
<h4 id="主导变更"><a href="#主导变更" class="headerlink" title="主导变更"></a>主导变更</h4><p>在生成系统做变更，也需要有一个正向反馈环，这个正向反馈环核心环节就是监控和预警。   </p>
<h6 id="发布"><a href="#发布" class="headerlink" title="发布."></a>发布.</h6><p>一般第一次发布，就是该变更第一次在生产环境的应用，此时风险最大。因此要确保被影响的机器越少越好，把风险降到最低。首次发布时一般都选择可发布的最小单位，也就是一台机器。对于特别重要的软件，往往会在发布50%之后，经历一次业务高峰后再发布剩余的机器。因为即使该变更有问题，导致50%的机器在高峰期的压力下无法正常工作，还有剩下50%的机器能够支撑业务的运作。这意味着在建立集群的时候，必须要留有50%的冗余容量来做缓冲。</p>
<h3 id="软件访问生命周期"><a href="#软件访问生命周期" class="headerlink" title="软件访问生命周期"></a>软件访问生命周期</h3><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>集群就是组装有相同的软件，具备同样功能的一组计算机，组织在一起共同服务于客户的访问，它以横向扩展的方式提升软件访问能力。<br>应用集群后，所有用户不再只访问一台机器，变成了用户分散访问不同的机器，但还是访问同一个软件。因为集群内的机器功能都是一样的，相当于增加了访问通道，使得软件的访问容量得到了增长。<br>集群通过路由来指定用户对某一台计算机的访问。用户访问到达集群前端时做一个路由，把每个用户的请求按照预设的规则转发到集群中的某台机器，即可让用户的访问自动到达某台机器上的软件，转发预设的规则还需要考虑某台机器是否过忙，否则把用户的请求转发到过载的机器上反而影响用户的访问。<br>集群的路由主要考虑的因素是集群内机器的负载均衡问题，为了实现对集群内机器负载的感知，路由必须定时的检查集群内机器的健康和剩余访问容量。路由的引入使得用户并不知道自己访问的是一个集群，因为每次访问都只是访问一台机器，集群对用户是透明的。<br>集群出现后，用户的访问路径又做了一次架构拆分，在软件所部署的计算机之前增加了一个访问路由，这个路由负责把用户的请求按照转发规则转发给集群内的某台计算机。转发规则有很多种，比如按照访问的权重来路由，随机路由、散列路由等，各有各的优势和缺点。<br>集群虽好，但是要实现集群，对软件本身则有一个限制：要能够在不同的计算机之间保持用户的状态。比如用户本次访问的机器和上次不同，这个机器就不知道用户是谁，从而无法给用户服务，就要求用户再次登录。在这种情况下，用户感知到了集群的存在，集群就失去了意义。要做到集群对用户透明，软件本身还需要在用户的访问路径上做一个架构拆分，使得同一个集群的不同机器之间，能够共享用户的状态。只有做到这一点，才能够真正地让集群对用户透明。当然，还有一种路由转发规则是按照用户的来源固定给某台机器来服务，确保单个用户上次访问的目标计算机和当前要访问的目标计算机是同一台来避免这个问题。实现方式是按照访问来源地址对集群内机器数量做散列，这样某个来源地址所访问的机器就是固定的。   </p>
<h4 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h4><p>多数据中心可以看成是集群的集群，装有同一个软件的集群会同时部署在多个不同的数据中心，集群在不同的数据中心各复制了一份。<br>当一个数据中心出了问题，其他的数据中心可以接管，可以让软件保持持续运行，获得很长的运行生命周期，不会对用户的访问造成影响。<br>要做到用户在不同数据中心访问同一个软件，就必须在不同数据中心的前端放置一个路由，类似于前述的集群做法，为部署了同一个软件但位于不同数据中心的各个集群做路由。用户访问软件的路径又做了一次架构拆分，增加了数据中心的路由生命周期。<br>数据中心前置路由的路由策略和集群的路由策略有不同之处。集群的路由策略保障的是集群内机器访问的均衡，而数据中心前置路由的路由策略则是把数据中心所覆盖地区的用户访问归属到相应的数据中心。这就意味着在建数据中心时，要考虑的实际上是物理空间维度上用户的覆盖面，避免数据中心过小而用户过多，导致数据中心之间的负载不均衡。<br>同一个软件部署在多个数据中心的不同集群上，一般会重新定义一个名字，叫做池(Pool)，比如有两个数据中心shanghai-dc和beijing-dc，都分别有订单集群，它们的名字会是order-shanghai-dc和order-beijing-dc，但是它们都属于订单的集群，会有一个统一的名字，叫做订单池(Order Pool)，相当于一个集群池，方便和集群分开。多数据中心出现后，软件发布的目标不再是针对集群，而是针对池，集群是物理的，池可以认为是逻辑上的集群，多个数据中心里部署了同一个软件的计算机都属于同一个池。<br>多个数据中心的出现，对变更的发布也会造成影响。一个池会同时部署在多个数据中心，发布变更的时候不能把一个数据中心的集群全部关闭。比如上例中订单池在两个数据中心分别有一个集群，各100台机器。在软件发布到50%的时候，不能让某个数据中心的100台机器全部下线，这会让一个数据中心的订单集群变成完全不可用，这是不可接受的。发布50%的时候应该是让两个数据中心各发布50%。<br>当一个用户从一个数据中心迁移到另一个数据中心时，可以按照用户维度存储数据，也可以通过数据同步保证两个数据中心的数据一致。</p>
<h3 id="软件架构和大数据"><a href="#软件架构和大数据" class="headerlink" title="软件架构和大数据"></a>软件架构和大数据</h3><h3 id="软件架构和建筑架构"><a href="#软件架构和建筑架构" class="headerlink" title="软件架构和建筑架构"></a>软件架构和建筑架构</h3><h2 id="软件架构的应用"><a href="#软件架构的应用" class="headerlink" title="软件架构的应用"></a>软件架构的应用</h2><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><h3 id="交易系统"><a href="#交易系统" class="headerlink" title="交易系统"></a>交易系统</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/11/16/5-minutes-docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/16/5-minutes-docker/" class="post-title-link" itemprop="url">读《每天5分钟玩转Docker容器技术》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-16 00:21:25" itemprop="dateCreated datePublished" datetime="2017-11-16T00:21:25+08:00">2017-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-26 00:45:52" itemprop="dateModified" datetime="2019-01-26T00:45:52+08:00">2019-01-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="鸟瞰容器生态系统"><a href="#鸟瞰容器生态系统" class="headerlink" title="鸟瞰容器生态系统"></a>鸟瞰容器生态系统</h2><h3 id="容器生态系统"><a href="#容器生态系统" class="headerlink" title="容器生态系统"></a>容器生态系统</h3><h3 id="准备实验环境"><a href="#准备实验环境" class="headerlink" title="准备实验环境"></a>准备实验环境</h3><h3 id="运行第一个容器"><a href="#运行第一个容器" class="headerlink" title="运行第一个容器"></a>运行第一个容器</h3><h2 id="容器核心知识概述"><a href="#容器核心知识概述" class="headerlink" title="容器核心知识概述"></a>容器核心知识概述</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><h3 id="为什么需要容器"><a href="#为什么需要容器" class="headerlink" title="为什么需要容器"></a>为什么需要容器</h3><h3 id="容器是如何工作的"><a href="#容器是如何工作的" class="headerlink" title="容器是如何工作的"></a>容器是如何工作的</h3><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="镜像的内部结构"><a href="#镜像的内部结构" class="headerlink" title="镜像的内部结构"></a>镜像的内部结构</h3><h4 id="镜像的分层结构"><a href="#镜像的分层结构" class="headerlink" title="镜像的分层结构"></a>镜像的分层结构</h4><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><h3 id="RUN-vs-CMD-vs-ENTRYPOINT"><a href="#RUN-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="RUN vs CMD vs ENTRYPOINT"></a>RUN vs CMD vs ENTRYPOINT</h3><h4 id="Shell-和-Exec格式"><a href="#Shell-和-Exec格式" class="headerlink" title="Shell 和 Exec格式"></a>Shell 和 Exec格式</h4><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h3 id="分发镜像"><a href="#分发镜像" class="headerlink" title="分发镜像"></a>分发镜像</h3><h4 id="为镜像命名"><a href="#为镜像命名" class="headerlink" title="为镜像命名"></a>为镜像命名</h4><h4 id="使用公共-Registry"><a href="#使用公共-Registry" class="headerlink" title="使用公共 Registry"></a>使用公共 Registry</h4><h4 id="搭建本地-Registry"><a href="#搭建本地-Registry" class="headerlink" title="搭建本地 Registry"></a>搭建本地 Registry</h4><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><h4 id="让容器长期运行"><a href="#让容器长期运行" class="headerlink" title="让容器长期运行"></a>让容器长期运行</h4><h4 id="两种进入容器的方法"><a href="#两种进入容器的方法" class="headerlink" title="两种进入容器的方法"></a>两种进入容器的方法</h4><h4 id="运行容器的最佳实践"><a href="#运行容器的最佳实践" class="headerlink" title="运行容器的最佳实践"></a>运行容器的最佳实践</h4><h3 id="stop-start-restart-容器"><a href="#stop-start-restart-容器" class="headerlink" title="stop/start/restart 容器"></a>stop/start/restart 容器</h3><h3 id="pause-unpause-容器"><a href="#pause-unpause-容器" class="headerlink" title="pause/unpause 容器"></a>pause/unpause 容器</h3><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><h3 id="State-Machine"><a href="#State-Machine" class="headerlink" title="State Machine"></a>State Machine</h3><h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><h4 id="内存限额"><a href="#内存限额" class="headerlink" title="内存限额"></a>内存限额</h4><h4 id="CPU限额"><a href="#CPU限额" class="headerlink" title="CPU限额"></a>CPU限额</h4><h4 id="Block-IO带宽限额"><a href="#Block-IO带宽限额" class="headerlink" title="Block IO带宽限额"></a>Block IO带宽限额</h4><h3 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h3><h4 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h4><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><h3 id="none-网络"><a href="#none-网络" class="headerlink" title="none 网络"></a>none 网络</h3><h3 id="host-网络"><a href="#host-网络" class="headerlink" title="host 网络"></a>host 网络</h3><h3 id="bridge-网络"><a href="#bridge-网络" class="headerlink" title="bridge 网络"></a>bridge 网络</h3><h3 id="user-defined-网络"><a href="#user-defined-网络" class="headerlink" title="user-defined 网络"></a>user-defined 网络</h3><h3 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h3><h4 id="IP通信"><a href="#IP通信" class="headerlink" title="IP通信"></a>IP通信</h4><h4 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h4><h4 id="joined-容器"><a href="#joined-容器" class="headerlink" title="joined 容器"></a>joined 容器</h4><h3 id="将容器与外部世界连接"><a href="#将容器与外部世界连接" class="headerlink" title="将容器与外部世界连接"></a>将容器与外部世界连接</h3><h4 id="容器访问外部世界"><a href="#容器访问外部世界" class="headerlink" title="容器访问外部世界"></a>容器访问外部世界</h4><h4 id="外部世界访问容器"><a href="#外部世界访问容器" class="headerlink" title="外部世界访问容器"></a>外部世界访问容器</h4><h2 id="Docker存储"><a href="#Docker存储" class="headerlink" title="Docker存储"></a>Docker存储</h2><h3 id="storage-driver"><a href="#storage-driver" class="headerlink" title="storage driver"></a>storage driver</h3><h3 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h3><h4 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind mount"></a>bind mount</h4><h4 id="docker-managed-volume"><a href="#docker-managed-volume" class="headerlink" title="docker managed volume"></a>docker managed volume</h4><h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><h4 id="容器与host共享数据"><a href="#容器与host共享数据" class="headerlink" title="容器与host共享数据"></a>容器与host共享数据</h4><h4 id="容器之间共享数据"><a href="#容器之间共享数据" class="headerlink" title="容器之间共享数据"></a>容器之间共享数据</h4><h3 id="volume-container"><a href="#volume-container" class="headerlink" title="volume container"></a>volume container</h3><h3 id="data-packed-volume-container"><a href="#data-packed-volume-container" class="headerlink" title="data-packed volume container"></a>data-packed volume container</h3><h3 id="Data-Volume-生命周期管理"><a href="#Data-Volume-生命周期管理" class="headerlink" title="Data Volume 生命周期管理"></a>Data Volume 生命周期管理</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><h4 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h4><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><h2 id="多主机管理"><a href="#多主机管理" class="headerlink" title="多主机管理"></a>多主机管理</h2><h3 id="实验环境描述"><a href="#实验环境描述" class="headerlink" title="实验环境描述"></a>实验环境描述</h3><h3 id="安装-Docker-Machine"><a href="#安装-Docker-Machine" class="headerlink" title="安装 Docker Machine"></a>安装 Docker Machine</h3><h3 id="创建-Machine"><a href="#创建-Machine" class="headerlink" title="创建 Machine"></a>创建 Machine</h3><h3 id="管理-Machine"><a href="#管理-Machine" class="headerlink" title="管理 Machine"></a>管理 Machine</h3><h2 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h2><h3 id="libnetwork-amp-CNM"><a href="#libnetwork-amp-CNM" class="headerlink" title="libnetwork &amp; CNM"></a>libnetwork &amp; CNM</h3><h3 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h3><h4 id="实验环境描述-1"><a href="#实验环境描述-1" class="headerlink" title="实验环境描述"></a>实验环境描述</h4><h4 id="创建-overlay-网络"><a href="#创建-overlay-网络" class="headerlink" title="创建 overlay 网络"></a>创建 overlay 网络</h4><h4 id="在-overlay-中运行容器"><a href="#在-overlay-中运行容器" class="headerlink" title="在 overlay 中运行容器"></a>在 overlay 中运行容器</h4><h4 id="overlay-网络连接性"><a href="#overlay-网络连接性" class="headerlink" title="overlay 网络连接性"></a>overlay 网络连接性</h4><h4 id="overlay-网络隔离"><a href="#overlay-网络隔离" class="headerlink" title="overlay 网络隔离"></a>overlay 网络隔离</h4><h4 id="overlay-IPAM"><a href="#overlay-IPAM" class="headerlink" title="overlay IPAM"></a>overlay IPAM</h4><h3 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a>macvlan</h3><h4 id="准备实验环境-1"><a href="#准备实验环境-1" class="headerlink" title="准备实验环境"></a>准备实验环境</h4><h4 id="创建-macvlan-网络"><a href="#创建-macvlan-网络" class="headerlink" title="创建 macvlan 网络"></a>创建 macvlan 网络</h4><h4 id="macvlan-网络结构分析"><a href="#macvlan-网络结构分析" class="headerlink" title="macvlan 网络结构分析"></a>macvlan 网络结构分析</h4><h4 id="用-sub-interface-实现多-macvlan-网络"><a href="#用-sub-interface-实现多-macvlan-网络" class="headerlink" title="用 sub-interface 实现多 macvlan 网络"></a>用 sub-interface 实现多 macvlan 网络</h4><h4 id="macvlan-网络间的隔离和连通"><a href="#macvlan-网络间的隔离和连通" class="headerlink" title="macvlan 网络间的隔离和连通"></a>macvlan 网络间的隔离和连通</h4><h3 id="finnel"><a href="#finnel" class="headerlink" title="finnel"></a>finnel</h3><h3 id="weave"><a href="#weave" class="headerlink" title="weave"></a>weave</h3><h3 id="calico"><a href="#calico" class="headerlink" title="calico"></a>calico</h3><h3 id="比较各种网络方案"><a href="#比较各种网络方案" class="headerlink" title="比较各种网络方案"></a>比较各种网络方案</h3><h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><h3 id="Docker自带的监控子命令"><a href="#Docker自带的监控子命令" class="headerlink" title="Docker自带的监控子命令"></a>Docker自带的监控子命令</h3><h3 id="sysdig"><a href="#sysdig" class="headerlink" title="sysdig"></a>sysdig</h3><h3 id="Weave-Scope"><a href="#Weave-Scope" class="headerlink" title="Weave Scope"></a>Weave Scope</h3><h3 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h3><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><h3 id="比较不同的监控工具"><a href="#比较不同的监控工具" class="headerlink" title="比较不同的监控工具"></a>比较不同的监控工具</h3><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><h3 id="Docker-logs"><a href="#Docker-logs" class="headerlink" title="Docker logs"></a>Docker logs</h3><h3 id="Docker-logging-driver"><a href="#Docker-logging-driver" class="headerlink" title="Docker logging driver"></a>Docker logging driver</h3><h3 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h3><h3 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h3><h3 id="Craylog"><a href="#Craylog" class="headerlink" title="Craylog"></a>Craylog</h3><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><h3 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h3><h3 id="实践-Rex-Ray-driver"><a href="#实践-Rex-Ray-driver" class="headerlink" title="实践 Rex-Ray driver"></a>实践 Rex-Ray driver</h3><h4 id="安装-Rex-Ray"><a href="#安装-Rex-Ray" class="headerlink" title="安装 Rex-Ray"></a>安装 Rex-Ray</h4><h4 id="配置-VirtualBox"><a href="#配置-VirtualBox" class="headerlink" title="配置 VirtualBox"></a>配置 VirtualBox</h4><h4 id="创建-Rex-Ray-volume"><a href="#创建-Rex-Ray-volume" class="headerlink" title="创建 Rex-Ray volume"></a>创建 Rex-Ray volume</h4><h4 id="使用-Rex-Ray-volume"><a href="#使用-Rex-Ray-volume" class="headerlink" title="使用 Rex-Ray volume"></a>使用 Rex-Ray volume</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/29/CSS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/29/CSS3/" class="post-title-link" itemprop="url">CSS3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-29 20:37:19" itemprop="dateCreated datePublished" datetime="2017-10-29T20:37:19+08:00">2017-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-16 14:37:41" itemprop="dateModified" datetime="2021-03-16T14:37:41+08:00">2021-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><p><code>border-radius</code></p>
<p>每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的。</p>
<h4 id="盒阴影"><a href="#盒阴影" class="headerlink" title="盒阴影"></a>盒阴影</h4><p><code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>
<p>boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。  </p>
<ul>
<li>h-shadow    必需的。水平阴影的位置。允许负值   </li>
<li>v-shadow    必需的。垂直阴影的位置。允许负值</li>
<li>blur    可选。模糊距离</li>
<li>spread    可选。阴影的大小</li>
<li>color    可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表</li>
<li>inset    可选。从外层的阴影（开始时）改变阴影内侧阴影</li>
</ul>
<h4 id="边框图像"><a href="#边框图像" class="headerlink" title="边框图像"></a>边框图像</h4><p><code>border-image: source slice width outset repeat;</code></p>
<ul>
<li>border-image-source    用于指定要用于绘制边框的图像的位置</li>
<li>border-image-slice    图像边界向内偏移</li>
<li>border-image-width    图像边界的宽度</li>
<li>border-image-outset    用于指定在边框外部绘制 border-image-area 的量</li>
<li>border-image-repeat    这个例子演示了如何创建一个border-image 属性的按钮。</li>
</ul>
<p>###背景</p>
<h5 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h5><p>不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background-image: url(img_flwr.gif), url(paper.gif);</span><br><span class="line">	background-position: right bottom, left top;</span><br><span class="line">	background-repeat: no-repeat, repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以给不同的图片设置多个不同的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#example1 &#123;</span><br><span class="line">	background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><p>background-size可以指定图像的大小。CSS3以前，背景图像大小由图像的实际大小决定。<br>CSS3中可以指定背景图片，重新在不同的环境中指定背景图片的大小。指定的大小是相对父元素的宽度和高度的百分比大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-size:80px 60px;</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p>指定背景图片的位置区域。content-box、padding-box、border-box区域内可以放置背景图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	background:url(img_flwr.gif);</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">	background-size:100% 100%;</span><br><span class="line">	background-origin:content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="渐变-gradient"><a href="#渐变-gradient" class="headerlink" title="渐变 gradient"></a>渐变 gradient</h3><p>gradient可以在两个或多个指定颜色之间显示平稳的过渡。<br>CSS3中定义了两种类型的渐变</p>
<ul>
<li>线性渐变 Line Gradient  向下/向上/向左/向右/对角方向</li>
<li>径向渐变 Radial Gradient 由它们的中心定义</li>
</ul>
<h5 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h5><p>为了创建一个线性渐变，你必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以设置一个起点和一个方向（或一个角度）。</p>
<p><code>background: linear-gradient(direction, color-stop1, color-stop2, ...); </code></p>
<p>线性渐变 - 从上到下 （默认情况）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  	background: -webkit-linear-gradient(red, blue); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  	background: -o-linear-gradient(red, blue); &#x2F;* Opera 11.1 - 12.0 *&#x2F;</span><br><span class="line">  	background: -moz-linear-gradient(red, blue); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  	background: linear-gradient(red, blue); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线性渐变 - 从左到右</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left, red , blue); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -o-linear-gradient(right, red, blue); &#x2F;* Opera 11.1 - 12.0 *&#x2F;</span><br><span class="line">  background: -moz-linear-gradient(right, red, blue); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: linear-gradient(to right, red , blue); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性渐变 - 对角</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left top, red , blue); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -o-linear-gradient(bottom right, red, blue); &#x2F;* Opera 11.1 - 12.0 *&#x2F;</span><br><span class="line">  background: -moz-linear-gradient(bottom right, red, blue); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: linear-gradient(to bottom right, red , blue); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用角度</p>
<p><code>background: linear-gradient(angle, color-stop1, color-stop2);</code></p>
<p>角度是指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。</p>
<p><img src="/2017/10/29/CSS3/angleGradient.jpg" alt="角度"></p>
<p>但是，请注意很多浏览器(Chrome,Safari,fiefox等)的使用了旧的标准，即 0deg 将创建一个从下到上的渐变，90deg 将创建一个从左到右的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(180deg, red, blue); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -o-linear-gradient(180deg, red, blue); &#x2F;* Opera 11.1 - 12.0 *&#x2F;</span><br><span class="line">  background: -moz-linear-gradient(180deg, red, blue); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: linear-gradient(180deg, red, blue); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多个颜色结点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(red, green, blue); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -o-linear-gradient(red, green, blue); &#x2F;* Opera 11.1 - 12.0 *&#x2F;</span><br><span class="line">  background: -moz-linear-gradient(red, green, blue); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: linear-gradient(red, green, blue); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用透明度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); &#x2F;* Safari 5.1 - 6 *&#x2F;</span><br><span class="line">  background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); &#x2F;* Opera 11.1 - 12*&#x2F;</span><br><span class="line">  background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); &#x2F;* Firefox 3.6 - 15*&#x2F;</span><br><span class="line">  background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复的线性渐变<br>repeating-linear-gradient() 函数用于重复线性渐变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  &#x2F;* Opera 11.1 - 12.0 *&#x2F;</span><br><span class="line">  background: -o-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">  &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">  background: repeating-linear-gradient(red, yellow 10%, green 20%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h5><p>径向渐变由它的中心定义。</p>
<p>为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
<p><code>background: radial-gradient(center, shape size, start-color, ..., last-color); </code></p>
<p>径向渐变 - 颜色结点均匀分布（默认情况下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red, green, blue); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -o-radial-gradient(red, green, blue); &#x2F;* Opera 11.6 - 12.0 *&#x2F;</span><br><span class="line">  background: -moz-radial-gradient(red, green, blue); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: radial-gradient(red, green, blue); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>径向渐变 - 颜色结点不均匀分布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -o-radial-gradient(red 5%, green 15%, blue 60%); &#x2F;* Opera 11.6 - 12.0 *&#x2F;</span><br><span class="line">  background: -moz-radial-gradient(red 5%, green 15%, blue 60%); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: radial-gradient(red 5%, green 15%, blue 60%); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置形状</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#grad &#123;</span><br><span class="line">  background: -webkit-radial-gradient(circle, red, yellow, green); &#x2F;* Safari 5.1 - 6.0 *&#x2F;</span><br><span class="line">  background: -o-radial-gradient(circle, red, yellow, green); &#x2F;* Opera 11.6 - 12.0 *&#x2F;</span><br><span class="line">  background: -moz-radial-gradient(circle, red, yellow, green); &#x2F;* Firefox 3.6 - 15 *&#x2F;</span><br><span class="line">  background: radial-gradient(circle, red, yellow, green); &#x2F;* 标准的语法 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h6 id="CSS3-font-face-规则"><a href="#CSS3-font-face-规则" class="headerlink" title="CSS3 @font-face 规则"></a>CSS3 @font-face 规则</h6><p>在CSS3之前，web设计师必须使用已在用户计算机上安装好的字体，不能够使用离线字体，不过通过CSS3，web设计师可以使用他们喜欢的任意字体。</p>
<p>当您找到或购买到希望使用的字体时，可将该字体文件存放到web服务器上，它会在需要时被自动下载到用户的计算机上。</p>
<p>您”自己的”的字体是在 CSS3 @font-face 规则中定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">@font-face</span><br><span class="line">&#123;</span><br><span class="line">   font-family: myFirstFont;</span><br><span class="line">   src: url(sansation_light.woff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">   font-family:myFirstFont;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h3><h5 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h5><p>根据左（x轴）和顶部（y轴）位置给定的参数，从当前元素位置移动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: translate(50px, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h5><p>在给定的读书顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: rotate(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h5><p>该元素增加或减少的大小，取决于宽度（x轴）和高度（y轴）的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: scale(2,4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="skew"><a href="#skew" class="headerlink" title="skew()"></a>skew()</h5><p>包含两个参数，分别表示X轴和Y轴倾斜角度，如果第二个参数为空，则默认为0，参数为负表示向相反的方向倾斜。</p>
<ul>
<li>skewX() 表示只在X轴（水平方向）倾斜</li>
<li>skewY() 表示只在Y轴（垂直方向）倾斜</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: skew(10deg, 30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="matrix"><a href="#matrix" class="headerlink" title="matrix()"></a>matrix()</h5><p>matrix()方法和2D变换方法合并成一个。<br>matrix()方法有6个参数，包含旋转、缩放、移动（平移）和倾斜功能。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	transform: matrix(0.3, 0.5, -0.5, 0.3, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/10/15/react-native/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/15/react-native/" class="post-title-link" itemprop="url">React Native</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-15 16:31:32" itemprop="dateCreated datePublished" datetime="2017-10-15T16:31:32+08:00">2017-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-25 17:43:10" itemprop="dateModified" datetime="2019-01-25T17:43:10+08:00">2019-01-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/08/24/read-react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/24/read-react/" class="post-title-link" itemprop="url">React</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-24 23:52:48" itemprop="dateCreated datePublished" datetime="2017-08-24T23:52:48+08:00">2017-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-03-08 16:01:02" itemprop="dateModified" datetime="2019-03-08T16:01:02+08:00">2019-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="node和npm"><a href="#node和npm" class="headerlink" title="node和npm"></a>node和npm</h3><ol>
<li><p>node    </p>
<p> node包管理器</p>
</li>
<li><p>npm</p>
<p> <code>npm install -g &lt;package&gt;</code> 安装全局包<br> <code>npm install &lt;package&gt;</code> 安装本地包</p>
<p> node包安装完后会保存在node_modules/文件夹下，并且会添加到package.json中</p>
<p> <code>npm init -y</code> 创建npm项目和package.json文件</p>
<p> <code>npm install</code> 从依赖文件package.json中安装node包</p>
<p> <code>npm install --save-dev</code> –save-dev 标记该node包只是用作开发环境的一部分，并不会作为产品代码发布</p>
</li>
</ol>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><h3 id="创建react项目"><a href="#创建react项目" class="headerlink" title="创建react项目"></a>创建react项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><h4 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">import &#39;.&#x2F;index.css&#39;;</span><br><span class="line"></span><br><span class="line">ReactDOM.reander(</span><br><span class="line">	&lt;App &#x2F;&gt;,</span><br><span class="line">	document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">	module.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ShoppingList extends React.Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		&lt;div className&#x3D;&quot;shopping-list&quot;&gt;</span><br><span class="line">			&lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">			&lt;ul&gt;</span><br><span class="line">				&lt;li&gt;Instagram&lt;&#x2F;li&gt;</span><br><span class="line">				&lt;li&gt;WhatsApp&lt;&#x2F;li&gt;</span><br><span class="line">				&lt;li&gt;Oculus&lt;&#x2F;li&gt;</span><br><span class="line">			&lt;&#x2F;ul&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用法： &lt;ShoppingList name&#x3D;&quot;mark&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="函数定义组件"><a href="#函数定义组件" class="headerlink" title="函数定义组件"></a>函数定义组件</h4><p>为只有render方法的组件提供的一种简便的定义组件的方法。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Square(props) &#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;button className&#x3D;&quot;square&quot; onClick&#x3D;&#123;props.onClick&#125;&gt;</span><br><span class="line">			&#123;props.value&#125;</span><br><span class="line">		&lt;&#x2F;button&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化事件处理函数。这里把 <code>onClick=&#123; () =&gt; props.onClick() &#125;</code> 直接修改为 <code>onClick=&#123;props.onClick&#125;</code> ，注意不能写成 <code>onClick=&#123;props.onClick()&#125;</code>否则<code>porps.onClick</code>方法会在Square组件渲染时被直接触发而不是等到Board组件渲染完成时通过点击触发，又因为此时Board组件正在渲染中（即Board组件的render方法正在调用），又触发父组件onClick中调用setState()会再次调用render方法导致死循环。     </p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="/2017/08/24/read-react/lifecycle.png" alt="生命周期">     </p>
<h4 id="正确使用state"><a href="#正确使用state" class="headerlink" title="正确使用state"></a>正确使用state</h4><p>构造函数是唯一能够初始化state的地方。</p>
<ul>
<li><p>不要直接更新状态，应当使用setState()</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wrong，此代码不会重新渲染组件</span><br><span class="line">this.state.comment &#x3D; &#39;Hello&#39;;</span><br><span class="line">&#x2F;&#x2F; Correct</span><br><span class="line">this.setState(&#123;comment: &#39;Hello&#39;&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>状态更新可能是异步的<br>  React可以将多个setState()调用合并成一个调用来提高性能。<br>  因为this.props和this.state可能是异步更新的，你不应该依靠它们的值来计算下一个状态。      </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">	counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Correct</span><br><span class="line">this.setState((prevState, props) &#x3D;&gt; &#123;</span><br><span class="line">	counter: prevState.counter + props.increment</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; Correct</span><br><span class="line">this.setState(function(prevState, props) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		counter: prevState.counter + props.increment</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>状态更新合并</p>
<p>  当调用setState()时，React将提供的对象合并到当前状态。 </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">	super(props);</span><br><span class="line">	this.state &#x3D; &#123;</span><br><span class="line">		posts: [],</span><br><span class="line">		comments: []</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">	fetchPost().then(response &#x3D;&gt; &#123;</span><br><span class="line">		this.setState(&#123;</span><br><span class="line">			posts: response.posts</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	fetchPost().then(response &#x3D;&gt; &#123;</span><br><span class="line">		this.setState(&#123;</span><br><span class="line">			comments: response.comments</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里的合并是浅合并，也就是说this.setState({comments})完整保留了this.state.posts，但完全替换了this.state.comments。</p>
</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>React元素的事件处理和DOM元素的很相似。但是有一些语法上的不同：</p>
<ul>
<li>React事件绑定属性的命名采用驼峰式写法，而不是小写。   </li>
<li>如果采用JSX的语法需要传入一个函数作为事件处理函数，而不是一个字符串（DOM元素的写法）</li>
<li>在React中，不能使用返回false的方式阻止默认行为，必须明确使用preventDefault</li>
</ul>
<p>在React中，JSX回调函数中的this，类方法默认不会绑定this的。如果忘记绑定this.handleClick并把它传入onClick，当你调用这个函数的时候，this的值是undefined。<br>两种不用绑定this的方法，属性初始化器语法和箭头函数。      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props);</span><br><span class="line">		this.state &#x3D; &#123;</span><br><span class="line">			isToggleOn: true</span><br><span class="line">		&#125;;</span><br><span class="line">		this.handleClick1 &#x3D; this.handleClick1.bind(this);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick1() &#123;</span><br><span class="line">		this.setState((prevState) &#x3D;&gt; &#123;</span><br><span class="line">			isToggleOn: !prevState.isToggleOn</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick2 &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	handleClick3(e) &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;button onClick&#x3D;&#123;this.handleClick1&#125;&gt;</span><br><span class="line">					&#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;</span><br><span class="line">				&lt;&#x2F;button&gt;</span><br><span class="line">				&lt;button onClick&#x3D;&#123;this.handleClick2&#125;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;&#x2F;button&gt;</span><br><span class="line">				&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.handleClick3(e)&#125;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;&#x2F;button&gt;</span><br><span class="line">			&lt;&#x2F;div&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用箭头函数，每次Toggle渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。      </p>
<h4 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deleteRow(rowId, event) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="列表和keys"><a href="#列表和keys" class="headerlink" title="列表和keys"></a>列表和keys</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems &#x3D; todos.map((todo) &#x3D;&gt;</span><br><span class="line">  &lt;li key&#x3D;&#123;todo.id&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当元素没有确定的id时，你可以使用他的序列号索引index作为key。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems &#x3D; todos.map((todo, index) &#x3D;&gt;</span><br><span class="line">  &lt;li key&#x3D;&#123;index&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作键值，因为这样做会导致性能的负面影响，还可能引起组件状态问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/21/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/21/%E8%AF%BB%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B/" class="post-title-link" itemprop="url">读《大型网站技术架构：核心原理与案例分析》</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-21 14:10:13" itemprop="dateCreated datePublished" datetime="2017-06-21T14:10:13+08:00">2017-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-31 22:10:46" itemprop="dateModified" datetime="2019-01-31T22:10:46+08:00">2019-01-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="大型网站架构演化"><a href="#大型网站架构演化" class="headerlink" title="大型网站架构演化"></a>大型网站架构演化</h2><h3 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h3><h3 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h3><h4 id="初始阶段的网站架构"><a href="#初始阶段的网站架构" class="headerlink" title="初始阶段的网站架构"></a>初始阶段的网站架构</h4><h4 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h4><h4 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h4><h4 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h4><h4 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h4><h4 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h4><h4 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h4><h4 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h4><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><h4 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h4><h3 id="大型网站架构演化的价值观"><a href="#大型网站架构演化的价值观" class="headerlink" title="大型网站架构演化的价值观"></a>大型网站架构演化的价值观</h3><h4 id="大型网站架构技术的核心价值是随网站所需灵活应对"><a href="#大型网站架构技术的核心价值是随网站所需灵活应对" class="headerlink" title="大型网站架构技术的核心价值是随网站所需灵活应对"></a>大型网站架构技术的核心价值是随网站所需灵活应对</h4><h4 id="驱动大型网站技术发展的主要力量是网站的业务发展"><a href="#驱动大型网站技术发展的主要力量是网站的业务发展" class="headerlink" title="驱动大型网站技术发展的主要力量是网站的业务发展"></a>驱动大型网站技术发展的主要力量是网站的业务发展</h4><h3 id="网站架构设计误区"><a href="#网站架构设计误区" class="headerlink" title="网站架构设计误区"></a>网站架构设计误区</h3><h4 id="一味追随大公司的解决方案"><a href="#一味追随大公司的解决方案" class="headerlink" title="一味追随大公司的解决方案"></a>一味追随大公司的解决方案</h4><h4 id="为了技术而技术"><a href="#为了技术而技术" class="headerlink" title="为了技术而技术"></a>为了技术而技术</h4><h4 id="企图用技术解决所有问题"><a href="#企图用技术解决所有问题" class="headerlink" title="企图用技术解决所有问题"></a>企图用技术解决所有问题</h4><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h2><h3 id="网站架构模式"><a href="#网站架构模式" class="headerlink" title="网站架构模式"></a>网站架构模式</h3><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><h4 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h4><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><h3 id="架构模式在新浪微博的应用"><a href="#架构模式在新浪微博的应用" class="headerlink" title="架构模式在新浪微博的应用"></a>架构模式在新浪微博的应用</h3><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站核心架构要素"><a href="#大型网站核心架构要素" class="headerlink" title="大型网站核心架构要素"></a>大型网站核心架构要素</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="瞬间响应：网站的高性能架构"><a href="#瞬间响应：网站的高性能架构" class="headerlink" title="瞬间响应：网站的高性能架构"></a>瞬间响应：网站的高性能架构</h2><h3 id="网站性能测试"><a href="#网站性能测试" class="headerlink" title="网站性能测试"></a>网站性能测试</h3><h4 id="不同视角下的网站性能"><a href="#不同视角下的网站性能" class="headerlink" title="不同视角下的网站性能"></a>不同视角下的网站性能</h4><h4 id="性能测试指标"><a href="#性能测试指标" class="headerlink" title="性能测试指标"></a>性能测试指标</h4><h4 id="性能测试方法"><a href="#性能测试方法" class="headerlink" title="性能测试方法"></a>性能测试方法</h4><h4 id="性能测试报告"><a href="#性能测试报告" class="headerlink" title="性能测试报告"></a>性能测试报告</h4><h4 id="性能测试策略"><a href="#性能测试策略" class="headerlink" title="性能测试策略"></a>性能测试策略</h4><h3 id="Web前端性能优化"><a href="#Web前端性能优化" class="headerlink" title="Web前端性能优化"></a>Web前端性能优化</h3><h4 id="浏览器访问优化"><a href="#浏览器访问优化" class="headerlink" title="浏览器访问优化"></a>浏览器访问优化</h4><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><h3 id="应用服务器性能优化"><a href="#应用服务器性能优化" class="headerlink" title="应用服务器性能优化"></a>应用服务器性能优化</h3><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><h4 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h4><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><h3 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h3><h4 id="机械硬盘-vs-固态硬盘"><a href="#机械硬盘-vs-固态硬盘" class="headerlink" title="机械硬盘 vs 固态硬盘"></a>机械硬盘 vs 固态硬盘</h4><h4 id="B-树-vs-LSM树"><a href="#B-树-vs-LSM树" class="headerlink" title="B+树 vs LSM树"></a>B+树 vs LSM树</h4><h4 id="RAID-vs-HDFS"><a href="#RAID-vs-HDFS" class="headerlink" title="RAID vs HDFS"></a>RAID vs HDFS</h4><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><h2 id="万无一失：网站的高可用框架"><a href="#万无一失：网站的高可用框架" class="headerlink" title="万无一失：网站的高可用框架"></a>万无一失：网站的高可用框架</h2><h3 id="网站可用性的度量与考核"><a href="#网站可用性的度量与考核" class="headerlink" title="网站可用性的度量与考核"></a>网站可用性的度量与考核</h3><h4 id="网站可用性度量"><a href="#网站可用性度量" class="headerlink" title="网站可用性度量"></a>网站可用性度量</h4><h4 id="网站可用性考核"><a href="#网站可用性考核" class="headerlink" title="网站可用性考核"></a>网站可用性考核</h4><h3 id="高可用的网站架构"><a href="#高可用的网站架构" class="headerlink" title="高可用的网站架构"></a>高可用的网站架构</h3><h3 id="高可用的应用"><a href="#高可用的应用" class="headerlink" title="高可用的应用"></a>高可用的应用</h3><h4 id="通过负载均衡进行无状态服务的失效转移"><a href="#通过负载均衡进行无状态服务的失效转移" class="headerlink" title="通过负载均衡进行无状态服务的失效转移"></a>通过负载均衡进行无状态服务的失效转移</h4><h4 id="应用服务器集群的Session管理"><a href="#应用服务器集群的Session管理" class="headerlink" title="应用服务器集群的Session管理"></a>应用服务器集群的Session管理</h4><h3 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h3><h3 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h3><h4 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h4><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h4 id="失效转移"><a href="#失效转移" class="headerlink" title="失效转移"></a>失效转移</h4><h3 id="高可用网站的软件质量保证"><a href="#高可用网站的软件质量保证" class="headerlink" title="高可用网站的软件质量保证"></a>高可用网站的软件质量保证</h3><h4 id="网站发布"><a href="#网站发布" class="headerlink" title="网站发布"></a>网站发布</h4><h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><h4 id="预发布验证"><a href="#预发布验证" class="headerlink" title="预发布验证"></a>预发布验证</h4><h4 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h4><h4 id="自动化发布"><a href="#自动化发布" class="headerlink" title="自动化发布"></a>自动化发布</h4><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><h3 id="网站运行监控"><a href="#网站运行监控" class="headerlink" title="网站运行监控"></a>网站运行监控</h3><h4 id="监控数据采集"><a href="#监控数据采集" class="headerlink" title="监控数据采集"></a>监控数据采集</h4><h4 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h4><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><h2 id="永无止境：网站的伸缩性架构"><a href="#永无止境：网站的伸缩性架构" class="headerlink" title="永无止境：网站的伸缩性架构"></a>永无止境：网站的伸缩性架构</h2><h3 id="网站架构的伸缩性设计"><a href="#网站架构的伸缩性设计" class="headerlink" title="网站架构的伸缩性设计"></a>网站架构的伸缩性设计</h3><h4 id="不同功能进行物理分离实现伸缩"><a href="#不同功能进行物理分离实现伸缩" class="headerlink" title="不同功能进行物理分离实现伸缩"></a>不同功能进行物理分离实现伸缩</h4><h4 id="单一功能通过集群规模实现伸缩"><a href="#单一功能通过集群规模实现伸缩" class="headerlink" title="单一功能通过集群规模实现伸缩"></a>单一功能通过集群规模实现伸缩</h4><h3 id="应用服务器集群的伸缩性设计"><a href="#应用服务器集群的伸缩性设计" class="headerlink" title="应用服务器集群的伸缩性设计"></a>应用服务器集群的伸缩性设计</h3><h4 id="HTTP重定向负载均衡"><a href="#HTTP重定向负载均衡" class="headerlink" title="HTTP重定向负载均衡"></a>HTTP重定向负载均衡</h4><h4 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h4><h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><h4 id="IP负载均衡"><a href="#IP负载均衡" class="headerlink" title="IP负载均衡"></a>IP负载均衡</h4><h4 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h4><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><h3 id="分布式缓存集群的伸缩性设计"><a href="#分布式缓存集群的伸缩性设计" class="headerlink" title="分布式缓存集群的伸缩性设计"></a>分布式缓存集群的伸缩性设计</h3><h4 id="Memcached分布式缓存集群的访问模型"><a href="#Memcached分布式缓存集群的访问模型" class="headerlink" title="Memcached分布式缓存集群的访问模型"></a>Memcached分布式缓存集群的访问模型</h4><h4 id="Memcached分布式缓存集群的伸缩性挑战"><a href="#Memcached分布式缓存集群的伸缩性挑战" class="headerlink" title="Memcached分布式缓存集群的伸缩性挑战"></a>Memcached分布式缓存集群的伸缩性挑战</h4><h4 id="分布式缓存的一致性Hash算法"><a href="#分布式缓存的一致性Hash算法" class="headerlink" title="分布式缓存的一致性Hash算法"></a>分布式缓存的一致性Hash算法</h4><h3 id="数据存储服务器集群的伸缩性设计"><a href="#数据存储服务器集群的伸缩性设计" class="headerlink" title="数据存储服务器集群的伸缩性设计"></a>数据存储服务器集群的伸缩性设计</h3><h4 id="关系数据库集群的伸缩性设计"><a href="#关系数据库集群的伸缩性设计" class="headerlink" title="关系数据库集群的伸缩性设计"></a>关系数据库集群的伸缩性设计</h4><h4 id="NoSQL数据库的伸缩性设计"><a href="#NoSQL数据库的伸缩性设计" class="headerlink" title="NoSQL数据库的伸缩性设计"></a>NoSQL数据库的伸缩性设计</h4><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><h2 id="随需应变：网站的可扩展架构"><a href="#随需应变：网站的可扩展架构" class="headerlink" title="随需应变：网站的可扩展架构"></a>随需应变：网站的可扩展架构</h2><h3 id="构建可扩展的网站架构"><a href="#构建可扩展的网站架构" class="headerlink" title="构建可扩展的网站架构"></a>构建可扩展的网站架构</h3><h3 id="利用分布式消息队列降低系统耦合性"><a href="#利用分布式消息队列降低系统耦合性" class="headerlink" title="利用分布式消息队列降低系统耦合性"></a>利用分布式消息队列降低系统耦合性</h3><h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><h3 id="利用分布式服务打造可复用的业务平台"><a href="#利用分布式服务打造可复用的业务平台" class="headerlink" title="利用分布式服务打造可复用的业务平台"></a>利用分布式服务打造可复用的业务平台</h3><h4 id="Web-Service-与企业级分布式服务"><a href="#Web-Service-与企业级分布式服务" class="headerlink" title="Web Service 与企业级分布式服务"></a>Web Service 与企业级分布式服务</h4><h4 id="大型网站分布式服务的需求与特点"><a href="#大型网站分布式服务的需求与特点" class="headerlink" title="大型网站分布式服务的需求与特点"></a>大型网站分布式服务的需求与特点</h4><h4 id="分布式服务框架设计"><a href="#分布式服务框架设计" class="headerlink" title="分布式服务框架设计"></a>分布式服务框架设计</h4><h3 id="可扩展的数据结构"><a href="#可扩展的数据结构" class="headerlink" title="可扩展的数据结构"></a>可扩展的数据结构</h3><h3 id="利用开放平台建设网站生态圈"><a href="#利用开放平台建设网站生态圈" class="headerlink" title="利用开放平台建设网站生态圈"></a>利用开放平台建设网站生态圈</h3><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><h2 id="固若金汤：网站的安全架构"><a href="#固若金汤：网站的安全架构" class="headerlink" title="固若金汤：网站的安全架构"></a>固若金汤：网站的安全架构</h2><h3 id="道高一尺魔高一丈的网站应用攻击与防御"><a href="#道高一尺魔高一丈的网站应用攻击与防御" class="headerlink" title="道高一尺魔高一丈的网站应用攻击与防御"></a>道高一尺魔高一丈的网站应用攻击与防御</h3><h4 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h4><h4 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h4><h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><h4 id="其他攻击和漏洞"><a href="#其他攻击和漏洞" class="headerlink" title="其他攻击和漏洞"></a>其他攻击和漏洞</h4><h4 id="Web应用防火墙"><a href="#Web应用防火墙" class="headerlink" title="Web应用防火墙"></a>Web应用防火墙</h4><h4 id="网站安全漏铜扫描"><a href="#网站安全漏铜扫描" class="headerlink" title="网站安全漏铜扫描"></a>网站安全漏铜扫描</h4><h3 id="信息加密技术及密钥安全管理"><a href="#信息加密技术及密钥安全管理" class="headerlink" title="信息加密技术及密钥安全管理"></a>信息加密技术及密钥安全管理</h3><h4 id="单向三列加密"><a href="#单向三列加密" class="headerlink" title="单向三列加密"></a>单向三列加密</h4><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><h4 id="密钥安全管理"><a href="#密钥安全管理" class="headerlink" title="密钥安全管理"></a>密钥安全管理</h4><h3 id="信息过滤与反垃圾"><a href="#信息过滤与反垃圾" class="headerlink" title="信息过滤与反垃圾"></a>信息过滤与反垃圾</h3><h4 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h4><h4 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h4><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><h3 id="电子商务风险控制"><a href="#电子商务风险控制" class="headerlink" title="电子商务风险控制"></a>电子商务风险控制</h3><h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><h4 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h4><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="淘宝网的架构演化案例分析"><a href="#淘宝网的架构演化案例分析" class="headerlink" title="淘宝网的架构演化案例分析"></a>淘宝网的架构演化案例分析</h2><h3 id="淘宝网的业务发展历程"><a href="#淘宝网的业务发展历程" class="headerlink" title="淘宝网的业务发展历程"></a>淘宝网的业务发展历程</h3><h3 id="淘宝网技术架构演化"><a href="#淘宝网技术架构演化" class="headerlink" title="淘宝网技术架构演化"></a>淘宝网技术架构演化</h3><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><h2 id="维基百科的高性能架构设计分析"><a href="#维基百科的高性能架构设计分析" class="headerlink" title="维基百科的高性能架构设计分析"></a>维基百科的高性能架构设计分析</h2><h3 id="Wikipedia-网站整体架构"><a href="#Wikipedia-网站整体架构" class="headerlink" title="Wikipedia 网站整体架构"></a>Wikipedia 网站整体架构</h3><h3 id="Wikipedia-性能优化策略"><a href="#Wikipedia-性能优化策略" class="headerlink" title="Wikipedia 性能优化策略"></a>Wikipedia 性能优化策略</h3><h4 id="Wikipedia-前端性能优化"><a href="#Wikipedia-前端性能优化" class="headerlink" title="Wikipedia 前端性能优化"></a>Wikipedia 前端性能优化</h4><h4 id="Wikipedia-服务端性能优化"><a href="#Wikipedia-服务端性能优化" class="headerlink" title="Wikipedia 服务端性能优化"></a>Wikipedia 服务端性能优化</h4><h4 id="Wikipedia-后端性能优化"><a href="#Wikipedia-后端性能优化" class="headerlink" title="Wikipedia 后端性能优化"></a>Wikipedia 后端性能优化</h4><h2 id="海量分布式存储系统Doris的高可用架构设计分析"><a href="#海量分布式存储系统Doris的高可用架构设计分析" class="headerlink" title="海量分布式存储系统Doris的高可用架构设计分析"></a>海量分布式存储系统Doris的高可用架构设计分析</h2><h3 id="分布式存储系统的高可用架构"><a href="#分布式存储系统的高可用架构" class="headerlink" title="分布式存储系统的高可用架构"></a>分布式存储系统的高可用架构</h3><h3 id="不同故障情况下的高可用解决方案"><a href="#不同故障情况下的高可用解决方案" class="headerlink" title="不同故障情况下的高可用解决方案"></a>不同故障情况下的高可用解决方案</h3><h4 id="分布式存储系统的故障分类"><a href="#分布式存储系统的故障分类" class="headerlink" title="分布式存储系统的故障分类"></a>分布式存储系统的故障分类</h4><h4 id="正常情况下系统访问结构"><a href="#正常情况下系统访问结构" class="headerlink" title="正常情况下系统访问结构"></a>正常情况下系统访问结构</h4><h4 id="瞬时故障的高可用解决方案"><a href="#瞬时故障的高可用解决方案" class="headerlink" title="瞬时故障的高可用解决方案"></a>瞬时故障的高可用解决方案</h4><h4 id="临时故障的高可用解决方案"><a href="#临时故障的高可用解决方案" class="headerlink" title="临时故障的高可用解决方案"></a>临时故障的高可用解决方案</h4><h4 id="永久故障的高可用解决方案"><a href="#永久故障的高可用解决方案" class="headerlink" title="永久故障的高可用解决方案"></a>永久故障的高可用解决方案</h4><h2 id="网购秒杀系统架构设计案例分析"><a href="#网购秒杀系统架构设计案例分析" class="headerlink" title="网购秒杀系统架构设计案例分析"></a>网购秒杀系统架构设计案例分析</h2><h3 id="秒杀活动的技术挑战"><a href="#秒杀活动的技术挑战" class="headerlink" title="秒杀活动的技术挑战"></a>秒杀活动的技术挑战</h3><h3 id="秒杀系统的应对策略"><a href="#秒杀系统的应对策略" class="headerlink" title="秒杀系统的应对策略"></a>秒杀系统的应对策略</h3><h3 id="秒杀系统架构设计"><a href="#秒杀系统架构设计" class="headerlink" title="秒杀系统架构设计"></a>秒杀系统架构设计</h3><h3 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h3><h2 id="大型网站典型故障案例分析"><a href="#大型网站典型故障案例分析" class="headerlink" title="大型网站典型故障案例分析"></a>大型网站典型故障案例分析</h2><h3 id="写日志也会引发故障"><a href="#写日志也会引发故障" class="headerlink" title="写日志也会引发故障"></a>写日志也会引发故障</h3><h3 id="高并发访问数据库引发的故障"><a href="#高并发访问数据库引发的故障" class="headerlink" title="高并发访问数据库引发的故障"></a>高并发访问数据库引发的故障</h3><h3 id="高并发情况下锁引发的故障"><a href="#高并发情况下锁引发的故障" class="headerlink" title="高并发情况下锁引发的故障"></a>高并发情况下锁引发的故障</h3><h3 id="缓存引发的故障"><a href="#缓存引发的故障" class="headerlink" title="缓存引发的故障"></a>缓存引发的故障</h3><h3 id="应用启动不同步引发的故障"><a href="#应用启动不同步引发的故障" class="headerlink" title="应用启动不同步引发的故障"></a>应用启动不同步引发的故障</h3><h3 id="大文件读写独占磁盘引发的故障"><a href="#大文件读写独占磁盘引发的故障" class="headerlink" title="大文件读写独占磁盘引发的故障"></a>大文件读写独占磁盘引发的故障</h3><h3 id="滥用生产环境引发的故障"><a href="#滥用生产环境引发的故障" class="headerlink" title="滥用生产环境引发的故障"></a>滥用生产环境引发的故障</h3><h3 id="不规范的流程引发的故障"><a href="#不规范的流程引发的故障" class="headerlink" title="不规范的流程引发的故障"></a>不规范的流程引发的故障</h3><h3 id="不好的编程习惯引发的故障"><a href="#不好的编程习惯引发的故障" class="headerlink" title="不好的编程习惯引发的故障"></a>不好的编程习惯引发的故障</h3><h3 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h3><h1 id="架构师"><a href="#架构师" class="headerlink" title="架构师"></a>架构师</h1><h2 id="架构师领导艺术"><a href="#架构师领导艺术" class="headerlink" title="架构师领导艺术"></a>架构师领导艺术</h2><h3 id="关注人而不是产品"><a href="#关注人而不是产品" class="headerlink" title="关注人而不是产品"></a>关注人而不是产品</h3><h3 id="发掘人的优秀"><a href="#发掘人的优秀" class="headerlink" title="发掘人的优秀"></a>发掘人的优秀</h3><h3 id="共享美好蓝图"><a href="#共享美好蓝图" class="headerlink" title="共享美好蓝图"></a>共享美好蓝图</h3><h3 id="共同参与架构"><a href="#共同参与架构" class="headerlink" title="共同参与架构"></a>共同参与架构</h3><h3 id="学会妥协"><a href="#学会妥协" class="headerlink" title="学会妥协"></a>学会妥协</h3><h3 id="成就他人"><a href="#成就他人" class="headerlink" title="成就他人"></a>成就他人</h3><h2 id="网站架构师职场攻略"><a href="#网站架构师职场攻略" class="headerlink" title="网站架构师职场攻略"></a>网站架构师职场攻略</h2><h3 id="发现问题，寻找突破"><a href="#发现问题，寻找突破" class="headerlink" title="发现问题，寻找突破"></a>发现问题，寻找突破</h3><h3 id="提出问题，寻求支持"><a href="#提出问题，寻求支持" class="headerlink" title="提出问题，寻求支持"></a>提出问题，寻求支持</h3><h3 id="解决问题，达成绩效"><a href="#解决问题，达成绩效" class="headerlink" title="解决问题，达成绩效"></a>解决问题，达成绩效</h3><h2 id="漫话网站架构师"><a href="#漫话网站架构师" class="headerlink" title="漫话网站架构师"></a>漫话网站架构师</h2><h3 id="按作用划分架构师"><a href="#按作用划分架构师" class="headerlink" title="按作用划分架构师"></a>按作用划分架构师</h3><h3 id="按效果划分架构师"><a href="#按效果划分架构师" class="headerlink" title="按效果划分架构师"></a>按效果划分架构师</h3><h3 id="按职责角色划分架构师"><a href="#按职责角色划分架构师" class="headerlink" title="按职责角色划分架构师"></a>按职责角色划分架构师</h3><h3 id="安关注层次划分架构师"><a href="#安关注层次划分架构师" class="headerlink" title="安关注层次划分架构师"></a>安关注层次划分架构师</h3><h3 id="安关注层次划分架构师-1"><a href="#安关注层次划分架构师-1" class="headerlink" title="安关注层次划分架构师"></a>安关注层次划分架构师</h3><h3 id="安口碑划分架构师"><a href="#安口碑划分架构师" class="headerlink" title="安口碑划分架构师"></a>安口碑划分架构师</h3><h3 id="非主流方式划分架构师"><a href="#非主流方式划分架构师" class="headerlink" title="非主流方式划分架构师"></a>非主流方式划分架构师</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/05/JavaScript%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/05/JavaScript%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">JavaScript闭包和高阶函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-05 20:28:22" itemprop="dateCreated datePublished" datetime="2017-06-05T20:28:22+08:00">2017-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-18 17:48:18" itemprop="dateModified" datetime="2019-06-18T17:48:18+08:00">2019-06-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的作用域，就是指变量的有效范围。<br>当在函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量。这种做法会造成命名冲突。<br>在函数内声明的变量是局部变量，只有在函数内才能访问到该变量。因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境 创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到 内的。  </p>
<h3 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h3><p>普通函数，函数结束，局部变量的生命周期也将结束。但闭包不同，在闭包中，函数结束，局部变量的生命周期不一定结束。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var func &#x3D; function() &#123;</span><br><span class="line">	var a &#x3D; 1;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		a++;</span><br><span class="line">		console.log(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var f &#x3D; func();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>当执行 var f = func();时，f 返回了一个匿名函数的引用，它可以访问到 func() 被调用时产生的环境，而局部变量 a 一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起 来被延续了。</p>
<p>应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;2&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;3&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;4&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;5&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	var nodes &#x3D; document.getElementsByTagName(&#39;div&#39;);</span><br><span class="line">	for (var i &#x3D; 0, len &#x3D; nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">		nodes[i].onclick &#x3D; function() &#123;</span><br><span class="line">			console.log(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，无论触发哪个数的事件，输出都是5。因为 div 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，此时变量 i 的值已经是 5，所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 5。<br>解决方法是使用闭包，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链 中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i，如果有 5 个 div，这里的 i 就分别 是 0,1,2,3,4。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0, len &#x3D; nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">	(function(i) &#123;</span><br><span class="line">		nodes[i].onclick &#x3D; function() &#123;</span><br><span class="line">			console.log(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var Type &#x3D; &#123;&#125;;</span><br><span class="line">for (var i &#x3D; 0, type; type &#x3D; [&#39;String&#39;, &#39;Array&#39;, &#39;Number&#39;][i++];) &#123;</span><br><span class="line">	(function(type)&#123;</span><br><span class="line">		Type[&#39;is&#39;+type] &#x3D; function(obj) &#123;</span><br><span class="line">			return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object &#39; + type + &#39;]&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(type)</span><br><span class="line">&#125;</span><br><span class="line">console.log(Type.isArray([]));</span><br><span class="line">console.log(Type.isString(&#39;str&#39;));</span><br><span class="line">console.log(Type);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">&#123;isString: ƒ, isArray: ƒ, isNumber: ƒ&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭包的更多作用"><a href="#闭包的更多作用" class="headerlink" title="闭包的更多作用"></a>闭包的更多作用</h3><ol>
<li><p>封装变量<br>如果一个变量仅仅在函数中被使用，可以把它封闭在函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var mult &#x3D; (function() &#123;</span><br><span class="line">	var cache &#x3D; &#123;&#125;;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args &#x3D; Array.prototype.join.call(arguments, &#39;,&#39;);</span><br><span class="line">		if (args in cache) &#123;</span><br><span class="line">			return cache[args];</span><br><span class="line">		&#125;</span><br><span class="line">		var a &#x3D; 1;</span><br><span class="line">		for (var i &#x3D; 0, l &#x3D; arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">			a &#x3D; a * arguments[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return cache[args] &#x3D; a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(mult(1,2,3));</span><br><span class="line">console.log(mult(4,5,6));</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">6</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
<p> 如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些 小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他 9 地方使用，最好是把它们用闭包封闭起来。代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var mult &#x3D; (function() &#123;</span><br><span class="line">	var cache &#x3D; &#123;&#125;;</span><br><span class="line">	var calculate &#x3D; function() &#123;</span><br><span class="line">		var a &#x3D; 1;</span><br><span class="line">		for (var i &#x3D; 0, l &#x3D; arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">			a &#x3D; a * arguments[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args &#x3D; Array.prototype.join.call(arguments, &#39;,&#39;);</span><br><span class="line">		if (args in cache) &#123;</span><br><span class="line">			return cache[args];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return cache[args] &#x3D; calculate.apply(null, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(mult(1,2,3));</span><br><span class="line">console.log(mult(4,5,6));</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">6</span><br><span class="line">120</span><br></pre></td></tr></table></figure>
</li>
<li><p>延续局部变量的寿命<br>img 对象经常用于进行数据上报，如下所示:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var report &#x3D; function( src )&#123; var img &#x3D; new Image(); 		img.src &#x3D; src;</span><br><span class="line">&#125;;</span><br><span class="line">report( &#39;http:&#x2F;&#x2F;xxx.com&#x2F;getUserInfo&#39; );</span><br></pre></td></tr></table></figure></li>
</ol>
<p>但是通过查询后台的记录得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失30%左右的数据，也就是说，report 函数并不是每一次都成功发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后，img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。<br>现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var report &#x3D; (function()&#123; </span><br><span class="line">	var imgs &#x3D; [];</span><br><span class="line">	return function( src )&#123;</span><br><span class="line">		var img &#x3D; new Image(); </span><br><span class="line">		imgs.push( img ); </span><br><span class="line">		img.src &#x3D; src;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="闭包和面向对象设计"><a href="#闭包和面向对象设计" class="headerlink" title="闭包和面向对象设计"></a>闭包和面向对象设计</h3><p>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然，也可以使用闭包来实现一个完整的面向对象系统。<br>闭包实现：     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var extent &#x3D; function() &#123;</span><br><span class="line">	var value &#x3D; 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		call: function() &#123;</span><br><span class="line">			value++,</span><br><span class="line">			console.log(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var extent &#x3D; extent();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br><span class="line">extent.call();</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>面向对象的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var extent &#x3D; &#123; </span><br><span class="line">	value: 0,</span><br><span class="line">	call: function()&#123; </span><br><span class="line">		this.value++;</span><br><span class="line">		console.log( this.value ); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">extent.call(); </span><br><span class="line">extent.call(); </span><br><span class="line">extent.call();</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3 </span><br><span class="line">&#x2F;&#x2F;或者：</span><br><span class="line">var Extent &#x3D; function() &#123;</span><br><span class="line">	this.value &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Extent.prototype.call1 &#x3D; function() &#123;</span><br><span class="line">	this.value++;</span><br><span class="line">	console.log(this.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var extent &#x3D; new Extent();</span><br><span class="line">extent.call1();</span><br><span class="line">extent.call1();</span><br><span class="line">extent.call1();</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3 </span><br></pre></td></tr></table></figure>

<h3 id="用闭包实现命令模式"><a href="#用闭包实现命令模式" class="headerlink" title="用闭包实现命令模式"></a>用闭包实现命令模式</h3><h3 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h3><p>闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。</p>
<p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。</p>
<p>跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象 的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。</p>
<p>同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运 行时，就会删除这些值并回收它们占用的内存。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数是指满足以下条件之一的函数。</p>
<ul>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ul>
<h3 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h3><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><h5 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a>Array.prototype.sort</h5><p>Array.prototype.sort接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; [1,4,3].sort(function(a,b)&#123;</span><br><span class="line">... return a -b;</span><br><span class="line">... &#125;)</span><br><span class="line">[ 1, 3, 4 ]</span><br><span class="line">&gt; [1,4,3].sort(function(a,b)&#123;</span><br><span class="line">... return b - a;</span><br><span class="line">... &#125;)</span><br><span class="line">[ 4, 3, 1 ]</span><br></pre></td></tr></table></figure>

<h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><p>相比把函数作为参数传递，函数当作返回值输出的应用场景也许更多，也更能体现函数式编程的巧妙。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。</p>
<h5 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var isType &#x3D; function(type) &#123;</span><br><span class="line">	return function(obj) &#123;</span><br><span class="line">		return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object &#39; + type + &#39;]&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var isArray &#x3D; isType(&#39;Array&#39;);</span><br><span class="line">var isString &#x3D; isType(&#39;String&#39;);</span><br><span class="line">var isNumber &#x3D; isType(&#39;Number&#39;);</span><br><span class="line"></span><br><span class="line">console.log(isArray([1,2,3,4]));</span><br><span class="line">console.log(isString(&#39;abcd&#39;));</span><br><span class="line">console.log(isString(123));</span><br><span class="line">console.log(isNumber(123));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以用循环语句，批量注册这些isType函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var Type &#x3D; &#123;&#125;;</span><br><span class="line">for (var i &#x3D; 0, type; type &#x3D; [&#39;String&#39;, &#39;Array&#39;, &#39;Number&#39;][i++];) &#123;</span><br><span class="line">	(function(type)&#123;</span><br><span class="line">		Type[&#39;is&#39; + type] &#x3D; function(obj) &#123;</span><br><span class="line">			return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object &#39; + type + &#39;]&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(type)</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Type.isArray([]));</span><br><span class="line">console.log(Type.isString(&#39;123&#39;));</span><br><span class="line">console.log(Type.isNumber(123));</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">var getSingle &#x3D; function(fn) &#123;</span><br><span class="line">	var ret;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return ret || (ret &#x3D; fn.apply(this, arguments))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var getScript &#x3D; getSingle(function() &#123;</span><br><span class="line">	return document.createElement(&#39;script&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var script1 &#x3D; getScript();</span><br><span class="line">var script2 &#x3D; getScript();</span><br><span class="line"></span><br><span class="line">console.log(script1 &#x3D;&#x3D;&#x3D; script2)   &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数实现AOP"><a href="#高阶函数实现AOP" class="headerlink" title="高阶函数实现AOP"></a>高阶函数实现AOP</h3><p>AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些 跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before &#x3D; function(beforefn) &#123;</span><br><span class="line">	var __self &#x3D; this;  &#x2F;&#x2F;保存原函数的引用</span><br><span class="line">	return function() &#123;  &#x2F;&#x2F;返回包含了原函数和新函数的“代理”函数</span><br><span class="line">		beforefn.apply(this, arguments);  &#x2F;&#x2F;执行新函数，修正this</span><br><span class="line">		return __self.apply(this, arguments);  &#x2F;&#x2F;执行原函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Function.prototype.after &#x3D; function(afterfn) &#123;</span><br><span class="line">	var __self &#x3D; this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var ret &#x3D; __self.apply(this, arguments);</span><br><span class="line">		afterfn.apply(this, arguments);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func &#x3D; function() &#123;</span><br><span class="line">	console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func &#x3D; func.before(function()&#123;</span><br><span class="line">	console.log(1);</span><br><span class="line">&#125;).after(function()&#123;</span><br><span class="line">	console.log(3);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="高阶函数的其他应用"><a href="#高阶函数的其他应用" class="headerlink" title="高阶函数的其他应用"></a>高阶函数的其他应用</h3><h5 id="currying"><a href="#currying" class="headerlink" title="currying"></a>currying</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var currying &#x3D; function(fn) &#123;</span><br><span class="line">	var args &#x3D; [];</span><br><span class="line">	return function() &#123;</span><br><span class="line">		if (arguments.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">			return fn.apply(this, args);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			[].push.apply(args, arguments);</span><br><span class="line">			return arguments.callee</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var cost &#x3D; (function()&#123;</span><br><span class="line">	var money &#x3D; 0;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		for (var i &#x3D; 0, l &#x3D; arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">			money +&#x3D; arguments[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return money</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">var cost &#x3D; currying(cost);</span><br><span class="line">cost(100);</span><br><span class="line">cost(200);</span><br><span class="line">cost(300);</span><br><span class="line">console.log(cost()); &#x2F;&#x2F;600</span><br></pre></td></tr></table></figure>

<h5 id="uncurrying"><a href="#uncurrying" class="headerlink" title="uncurrying"></a>uncurrying</h5><p>在我们的预期中，Array.prototype 上的方法原本只能用来操作 array 对象。但用 call 和 apply 可以把任意对象当作 this 传入某个方法，这样一来，方法中用到 this 的地方就不再局限于原来规定的对象，而是加以泛化并得到更广的适用性。那么有没有办法把泛化 this 的过程提取出来呢? uncurrying 就是用来解决这个问题的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.uncurrying &#x3D; function() &#123;</span><br><span class="line">	var self &#x3D; this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var obj &#x3D; Array.prototype.shift.call(arguments);</span><br><span class="line">		return self.apply(obj, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在类数组对象 arguments 借用 Array.prototype 的方法之前，先把 Array.prototype.push.call这句代码转换为一个通用的 push 函数</span><br><span class="line">var push &#x3D; Array.prototype.push.uncurrying();</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">	console.log(arguments);</span><br><span class="line">	push(arguments, 4);</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;)(1,2,3)</span><br></pre></td></tr></table></figure>

<p>通过 uncurrying 的方式，Array.prototype.push.call 变成了一个通用的 push 函数。这样一来， push 函数的作用就跟 Array.prototype.push 一样了，同样不仅仅局限于只能操作 array 对象。而 对于使用者而言，调用 push 函数的方式也显得更加简洁和意图明了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0, fn, ary &#x3D; [&#39;push&#39;, &#39;shift&#39;, &#39;forEach&#39;]; fn &#x3D; ary[i++];) &#123;</span><br><span class="line">	Array[fn] &#x3D; Array.prototype[fn].uncurrying();</span><br><span class="line">&#125;;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	&#39;length&#39;: 3,</span><br><span class="line">	&#39;0&#39;: 1,</span><br><span class="line">	&#39;1&#39;: 2,</span><br><span class="line">	&#39;2&#39;: 3</span><br><span class="line">&#125;</span><br><span class="line">Array.push(obj, 4);</span><br><span class="line">console.log(obj.length);</span><br><span class="line">var first &#x3D; Array.shift(obj);</span><br><span class="line">console.log(first);</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">Array.forEach(obj, function(i, n)&#123;</span><br><span class="line">	console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">&#123;0: 2, 1: 3, 2: 4, length: 3&#125;</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var throttle &#x3D; function(fn, interval) &#123;</span><br><span class="line">	var __self &#x3D; fn;</span><br><span class="line">	var timer;</span><br><span class="line">	var firstTime &#x3D; true;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args &#x3D; arguments;</span><br><span class="line">		var __me &#x3D; this;</span><br><span class="line">		if (firstTime) &#123;</span><br><span class="line">			__self.apply(__me, args);</span><br><span class="line">			return firstTime &#x3D; false</span><br><span class="line">		&#125;</span><br><span class="line">		if (timer) &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		timer &#x3D; setTimeout(function() &#123;</span><br><span class="line">			clearTimeout(timer);</span><br><span class="line">			timer &#x3D; null;</span><br><span class="line">			__self.apply(__me, args);</span><br><span class="line">		&#125;, interval || 500)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">		</span><br><span class="line">window.onresize &#x3D; throttle(function() &#123;</span><br><span class="line">	console.log(1);</span><br><span class="line">&#125;, 500)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/06/03/JavaScript%E4%B8%AD%E7%9A%84this%E3%80%81call%E5%92%8Capply/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/03/JavaScript%E4%B8%AD%E7%9A%84this%E3%80%81call%E5%92%8Capply/" class="post-title-link" itemprop="url">JavaScript中的this、call和apply</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-03 16:13:48" itemprop="dateCreated datePublished" datetime="2017-06-03T16:13:48+08:00">2017-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-04 16:00:22" itemprop="dateModified" datetime="2019-06-04T16:00:22+08:00">2019-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。      </p>
<h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4中：</p>
<ul>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li>Function.prototype.call或Function.prototype.apply调用</li>
</ul>
<h5 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h5><p>当作为对象的方法被调用时，this指向该对象。      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var obj &#x3D; &#123;</span><br><span class="line">... a: 1,</span><br><span class="line">... getA: function() &#123;</span><br><span class="line">..... console.log(this &#x3D;&#x3D;&#x3D; obj);</span><br><span class="line">..... console.log(this.a);</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.getA()</span><br><span class="line">true</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h5><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的this总是指向全局对象。在浏览器的JavaScript中，这个全局对象是window对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">window.name &#x3D; &quot;globalName&quot;;</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getName());</span><br><span class="line"></span><br><span class="line">var myObj &#x3D; &#123;</span><br><span class="line">	name: &#39;sven&#39;,</span><br><span class="line">	getName: function() &#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getName1 &#x3D; myObj.getName;</span><br><span class="line">console.log(getName1());</span><br><span class="line">console.log(myObj.getName());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	输出</span><br><span class="line">&#x2F;&#x2F;	globalName</span><br><span class="line">&#x2F;&#x2F;	globalName</span><br><span class="line">&#x2F;&#x2F; 	sven</span><br></pre></td></tr></table></figure>

<p>有种情况，比如在div节点的事件函数内部，有个局部的callback方法，callback被视为普通函数调用，callback内部的this指向了window，但我们往往是想让它指向该div节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;this is a div&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	window.id &#x3D; &#39;window&#39;;</span><br><span class="line">	document.getElementById(&#39;div1&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">		alert(this.id);   &#x2F;&#x2F;div1</span><br><span class="line">		var callback &#x3D; function() &#123;</span><br><span class="line">			alert(this.id);   &#x2F;&#x2F;window</span><br><span class="line">		&#125;</span><br><span class="line">		callback();</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>一种简单的解决方案，可以用一个变量保存div节点的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;div1&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">	alert(this.id);   &#x2F;&#x2F;div1</span><br><span class="line">	var that &#x3D; this;</span><br><span class="line">	var callback &#x3D; function() &#123;</span><br><span class="line">		alert(that.id);   &#x2F;&#x2F;window</span><br><span class="line">	&#125;</span><br><span class="line">	callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">	&quot;use strict&quot;</span><br><span class="line">	alert(this);    &#x2F;&#x2F;undefined</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h5 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h5><p>JavaScript中没有类，但是可以从构造器中创建对象，同时也提供了new运算符，使得构造器看起来更像一个类。<br>除了宿主提供的一些内置函数，大部分JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass &#x3D; function() &#123;</span><br><span class="line">... this.name &#x3D; &#39;sven&#39;;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj &#x3D; new MyClass();</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#39;sven&#39;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass &#x3D; function() &#123;</span><br><span class="line">... this.name &#x3D; &#39;sven&#39;;</span><br><span class="line">... return &#123;</span><br><span class="line">..... name: &#39;anne&#39;,</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj &#x3D; new MyClass();</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#39;anne&#39;</span><br></pre></td></tr></table></figure>

<p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var MyClass &#x3D; function() &#123;</span><br><span class="line">... this.name &#x3D; &#39;sven&#39;;</span><br><span class="line">... return &#39;anne&#39;</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj &#x3D; new MyClass()</span><br><span class="line">undefined</span><br><span class="line">&gt; obj.name</span><br><span class="line">&#39;sven&#39;</span><br></pre></td></tr></table></figure>

<h5 id="Function-prototype-call或Function-prototype-apply调用"><a href="#Function-prototype-call或Function-prototype-apply调用" class="headerlink" title="Function.prototype.call或Function.prototype.apply调用"></a>Function.prototype.call或Function.prototype.apply调用</h5><p>跟普通的函数调用相比，用Function.prototype.call或Function.prototype.apply可以动态地改变传入函数的this。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; var obj1 &#x3D; &#123;</span><br><span class="line">... name: &#39;sven&#39;,</span><br><span class="line">... getName: function() &#123;</span><br><span class="line">..... return this.name;</span><br><span class="line">..... &#125;</span><br><span class="line">... &#125;;</span><br><span class="line">undefined</span><br><span class="line">&gt; var obj2 &#x3D; &#123;</span><br><span class="line">... name: &#39;anne&#39;,</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; obj1.getName()</span><br><span class="line">&#39;sven&#39;</span><br><span class="line">&gt; obj1.getName.call(obj2)</span><br><span class="line">&#39;anne&#39;</span><br></pre></td></tr></table></figure>

<h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><h5 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h5><p>它们的作用一模一样，区别仅在于传入参数形式的不同。<br>apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以是类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; var func &#x3D; function(a,b,c) &#123;</span><br><span class="line">... console.log([a,b,c])</span><br><span class="line">... &#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; func.apply(null, [1,2,3])</span><br><span class="line">[ 1, 2, 3 ]</span><br><span class="line">undefined</span><br><span class="line">&#x2F;&#x2F;参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列 表中的 a、b、c</span><br><span class="line">&gt; func.apply(null, 1,2,3)</span><br><span class="line">TypeError: CreateListFromArrayLike called on non-object</span><br></pre></td></tr></table></figure>

<p>call是包装在apply上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call来传送参数。<br>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func &#x3D; function(a,b,c) &#123;</span><br><span class="line">	console.log(a,b,c);</span><br><span class="line">	alert(this &#x3D;&#x3D;&#x3D; window);   &#x2F;&#x2F;true</span><br><span class="line">&#125;</span><br><span class="line">func.apply(null, [1,2,3]);</span><br></pre></td></tr></table></figure>

<p>但如果是在严格模式下，函数体内的 this 还是为 null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var func &#x3D; function(a,b,c) &#123;</span><br><span class="line">	&quot;use strict&quot;</span><br><span class="line">	console.log(a,b,c)</span><br><span class="line">	console.log(this &#x3D;&#x3D;&#x3D; window);</span><br><span class="line">	console.log(this &#x3D;&#x3D;&#x3D; null);</span><br><span class="line">&#125;</span><br><span class="line">func.apply(null, [1,2,3])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">1 2 3</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Math.max.apply(null,[1,23,5,2,3,6])</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<h4 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h4><h5 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h5><p>场景一：      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">	name: &#39;sven&#39;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">	name: &#39;anne&#39;,</span><br><span class="line">&#125;</span><br><span class="line">window.name &#x3D; &#39;window&#39;;</span><br><span class="line">var getName &#x3D; function() &#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line">getName.call(obj1);</span><br><span class="line">getName.call(obj2);</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">window</span><br><span class="line">sven</span><br><span class="line">anne</span><br></pre></td></tr></table></figure>

<p>场景二：在div事件中的内部函数中，修正this        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;div1&#39;).onclick &#x3D; function() &#123;</span><br><span class="line">	console.log(this.id);</span><br><span class="line">	var func &#x3D; function() &#123;</span><br><span class="line">		console.log(&#39;id:&#39; + this.id);</span><br><span class="line">	&#125;</span><br><span class="line">	func();</span><br><span class="line">	func.call(this);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">div1</span><br><span class="line">id:undefined</span><br><span class="line">id:div1</span><br></pre></td></tr></table></figure>

<h5 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h5><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向，即使没有原生的Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function(context) &#123;</span><br><span class="line">	var self &#x3D; this;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return self.apply(context, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	name: &#39;sven&#39;,</span><br><span class="line">&#125;</span><br><span class="line">var func &#x3D; function() &#123;</span><br><span class="line">	alert(this.name);    &#x2F;&#x2F;输出sven</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>带有参数的Function.prototype.bind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function() &#123;</span><br><span class="line">	var self &#x3D; this;   &#x2F;&#x2F;保存原函数</span><br><span class="line">	var context &#x3D; [].shift.call(arguments);  &#x2F;&#x2F;需要绑定的this上下文</span><br><span class="line">	var args &#x3D; [].slice.call(arguments);  &#x2F;&#x2F;剩余的参数转成数组</span><br><span class="line">	return function() &#123;  &#x2F;&#x2F;返回一个新函数</span><br><span class="line">		return self.apply(context, [].concat.call(args, [].slice.call(arguments)));</span><br><span class="line">		&#x2F;&#x2F;执行新的函数的时候，会把之前传入的context当做新函数体内的this</span><br><span class="line">		&#x2F;&#x2F;并且组合两次分别传入的参数，作为新函数的参数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	name: &#39;sven&#39;,</span><br><span class="line">&#125;</span><br><span class="line">var func &#x3D; function(a,b,c,d) &#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">	console.log([a,b,c,d]);</span><br><span class="line">&#125;.bind(obj, 1,2);</span><br><span class="line">func(3, 4);</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h5 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var A &#x3D; function(name) &#123;</span><br><span class="line">	this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">var B &#x3D; function() &#123;</span><br><span class="line">	A.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.getName &#x3D; function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; new B(&#39;sven&#39;);</span><br><span class="line">console.log(b.getName());</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">sven</span><br></pre></td></tr></table></figure>

<p>另一种常用的场景。<br>函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组， 所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常 会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用 Array.prototype.push:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">	Array.prototype.push.call(arguments, 3);</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;)(1,2)</span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></table></figure>

<p>我们可以把“任意”对象传入 Array.prototype.push。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Array.prototype.push.call(a, &#39;first&#39;)</span><br><span class="line">1</span><br><span class="line">&gt; a.length</span><br><span class="line">1</span><br><span class="line">&gt; a[0]</span><br><span class="line">&#39;first&#39;</span><br><span class="line">&gt; typeof a</span><br><span class="line">&#39;object&#39;</span><br></pre></td></tr></table></figure>

<p>这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版 本的 IE 浏览器中执行，必须显式地给对象 a 设置length 属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123; </span><br><span class="line">	length: 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面我们之所以把“任意”两字加了双引号，是因为可以借用 Array.prototype.push 方法的对象还要满足以下两个条件</p>
<ol>
<li>对象本身要可以存取属性;</li>
<li>对象的 length 属性可读写。</li>
</ol>
<p>注：函数对象的length属性是只读属性，并不满足要求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; var func &#x3D; function()&#123;&#125;</span><br><span class="line">undefined</span><br><span class="line">&gt; Array.prototype.push.call(func, &#39;first&#39;)</span><br><span class="line">TypeError: Cannot assign to read only property &#39;length&#39; of function &#39;function()&#123;&#125;&#39;</span><br><span class="line">    at Function.push (&lt;anonymous&gt;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2017/01/13/IONIC3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/13/IONIC3/" class="post-title-link" itemprop="url">Ionic3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-13 14:57:58" itemprop="dateCreated datePublished" datetime="2017-01-13T14:57:58+08:00">2017-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-26 14:53:44" itemprop="dateModified" datetime="2019-01-26T14:53:44+08:00">2019-01-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="官网文档"><a href="#官网文档" class="headerlink" title="官网文档"></a>官网文档</h3><p><a target="_blank" rel="noopener" href="https://ionicframework.com/docs/">Ionic Framework</a><br><a target="_blank" rel="noopener" href="https://ionicframework.com/docs/v3/">Ionic3</a></p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/7222ddf1ce84">IonicBlog</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1baf40713c1c">ionic3 教程</a>    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fhclk"
      src="/images/avatar1.png">
  <p class="site-author-name" itemprop="name">fhclk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fhclk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fhclk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fhclk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
