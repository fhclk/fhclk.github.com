<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fhclk.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="拾荒者">
<meta property="og:url" content="http://fhclk.github.io/page/9/index.html">
<meta property="og:site_name" content="拾荒者">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="fhclk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fhclk.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>拾荒者</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">拾荒者</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">昨夜西风凋碧树，独上高楼，望尽天涯路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">分布式缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-14 15:44:28" itemprop="dateCreated datePublished" datetime="2021-05-14T15:44:28+08:00">2021-05-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgotOV13Eh2AUjPjAAEIXLhmsGo317.png"></p>
<p>使用缓存需要注意几个关键指标：缓存键集合大小、缓存空间的大小以及缓存的使用寿命。这三个指标决定了缓存的有效性、缓存的使用效率、缓存实现的效果。缓存的类型主要有代理缓存、反向代理缓存、 CDN 缓存和对象缓存几种。</p>
<p>不是所有的数据都适合使用缓存，使用缓存的时候需要注意以下几点。</p>
<ul>
<li>数据频繁修改，这类数据使用缓存效果比较差。</li>
<li>数据没有热点，这类数据缓存的命中率比较差。</li>
<li>数据不一致，因为缓存的数据和数据库的数据是不同步的，可能存在数据不一致的情况，如果业务场景对数据一致性要求非常高，这个时候使用缓存也要注意。</li>
<li>缓存雪崩，当缓存崩溃的时候，可能会导致整个系统的崩溃，这也是使用缓存中要注意的一个事项。</li>
</ul>
<h1 id="缓存提高性能的优势"><a href="#缓存提高性能的优势" class="headerlink" title="缓存提高性能的优势"></a>缓存提高性能的优势</h1><p>缓存是架构性能优化的最重要的手段，使用缓存来提升系统性能主要有三方面优势。</p>
<ol>
<li>第一个方面是缓存的数据来自于内存，访问速度更快。我们知道数据从内存中读取要比磁盘上读取速度会更快，所以使用缓存从内存中读取数据会使系统获得更快的响应性能，系统的访问速度会更快，处理速度也会更快。</li>
<li>第二个方面是缓存中存储的数据形态通常是最终的结果形态，减少资源消耗。比如说，我们缓存一个网页、一个对象，这些数据通常是我们计算过的结果。从缓存中读取数据跟从磁盘中或者数据库中直接读取数据不同，从数据库中读取的数据要进行加工处理，生成我们最终的结果，而从缓存中读取的数据通常都是直接的最终结果。因此，使用缓存中的数据可以减少 CPU 的资源消耗，不需要进行中间的计算，可以进一步提高响应的特性。</li>
<li>第三个方面是使用缓存可以降低数据库磁盘或者网络的负载压力。不需要从外部的 IO 设备中去读取数据，这些数据直接从本地缓存或内存中读取，减少 IO 设备的访问压力。我们知道 IO 设备是最容易出现瓶颈的地方，减少这些设备的访问压力、负载压力，可以更好地提升整个系统的处理能力。</li>
</ol>
<h1 id="缓存数据存储（Hash-表）"><a href="#缓存数据存储（Hash-表）" class="headerlink" title="缓存数据存储（Hash 表）"></a>缓存数据存储（Hash 表）</h1><p>缓存是存储在内存中的，那么如何从内存中快速获取一个数据呢？</p>
<p>缓存使用的数据结构主要是哈希（Hash）表。我们看一下哈希表实现的机制。哈希表最终的存储形式通常是一个顺序表，也就是一个数组结构。数组结构的特点是在内存中连续存储分配。那么，当我们要在哈希表中存储一个数据的时候，哈希表通常是以 key、value 这样的数据结构进行存储的。当我们把一个 key、value 数据结构存储在一个哈希表中的时候，主要的存储过程大致如下图所示。       </p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgoB5l13VbiAHhPSAABoymphrNs072.png"></p>
<p>首先，我们拿到 key、value 数据结构，在上图的例子中，key 是字符串 abc，value 是字符串 hello，我们先计算 key 的哈希值，比如字符串 abc 的 hashcode 算出来是 101 这样一个整型值。往下，计算哈希值 101 对应的 hash 表索引就要对 8 取模。此处 8 指什么？哈希表真正的物理存储是一个数组，我们建的哈希表长度是 8，如上图所示。101 对 8 取模余 5，这个 5 就是数组下标的索引值，我们就可以把 abc hello 这样一个 key、value 值存储在下标为 5 的数组记录中。这一步是最关键的，通常我们所谓的哈希算法也就是指这一步，即如何把一个哈希值转换成在数组中对应的位置。这个例子我们使用的是余数哈希，实践中最常用的也是余数哈希。</p>
<p>将来，当我们要进行数据读取的时候，只要给定 key abc，还是用这样一个算法过程，先求取它的 hash code 101，然后再对 8 取模。因为数组的长度不变，对 8 取模以后依然是余 5，那么我们到数字下标中去找 5 的这个位置，就可以找到前面存储进去的 abc 对应的 value 值。</p>
<p>通过哈希表可以使整个数据存储或检索效率时间复杂都是 O(1)。所以即使存储非常大的几百万上千万的数据量，通过哈希表也可以非常快地进行数据的查找和读写。通过这种手段缓存可以获得较快的读写访问特性，比数据库中的读写速度要快得多。</p>
<h1 id="缓存的关键指标——命中率"><a href="#缓存的关键指标——命中率" class="headerlink" title="缓存的关键指标——命中率"></a>缓存的关键指标——命中率</h1><p>影响缓存特性的一个关键指标是缓存的命中率。缓存的主要特点是一次写入多次读出，通过这种手段减少对数据库的使用，尽快从缓存中读取数据，提高性能。所以缓存是否有效，主要就是看它一次写进去的缓存能不能够多次去读出来响应业务的请求，这个判断指标就叫作缓存的命中率。</p>
<p>缓存命中率怎么算呢？查询得到正确缓存结果除以总的查询次数，得到的比值就是缓存命中率，比如说十次查询九次都能够得到缓存的正确结果，命中率就是 90%。</p>
<p>影响缓存命中率的主要因素有三个，分别是：</p>
<ul>
<li>缓存键集合大小</li>
<li>内存空间大小</li>
<li>缓存的寿命</li>
</ul>
<h2 id="缓存键集合大小"><a href="#缓存键集合大小" class="headerlink" title="缓存键集合大小"></a>缓存键集合大小</h2><p>缓存中的每个对象都是通过缓存键进行识别的。刚才 abc hello 这个例子里 abc 就是一个缓存的键，键是缓存中唯一的识别符，定位一个对象的唯一方式就是对缓存键进行精确的匹配。</p>
<p>比如说我们想缓存每个商品的在线商品信息，就需要使用商品 ID 作为缓存键。换句话说，缓存键空间是你的应用能够生成的所有键的数量。从统计数字上看，应用生成的唯一键越多，重用的机会越小。比如说根据 IP 地址缓存天气数据，可能需要 40 多亿个键。但是如果基于国家缓存天气数据，那么只需要几百个缓存键就够了，全世界也不过就几百个国家。</p>
<p>所以要尽可能减少缓存键的数量，键的数量越少，缓存的效率越高。设计缓存的时候要关注缓存键是如何进行设计的，它的整个的集合范围，限定在一个既能够高效使用，又可以减少它的数量，这个时候缓存的性能是最好的。</p>
<h2 id="缓存内存空间大小"><a href="#缓存内存空间大小" class="headerlink" title="缓存内存空间大小"></a>缓存内存空间大小</h2><p>缓存可以使用的内存空间决定了缓存对象平均大小和缓存对象的数量。因为缓存通常是存储在内存中的，缓存对象可用的内存空间相对来说比较昂贵，而且受到严格限制。</p>
<p>如果想缓存更多的对象，就需要先删除老的对象，再添加新的对象。而这些老的对象被删除掉，就会影响到缓存的命中率。所以物理上缓存的空间越大，缓存的对象越多，缓存的命中率也就越高。</p>
<h2 id="缓存对象生存时间（缓存寿命）"><a href="#缓存对象生存时间（缓存寿命）" class="headerlink" title="缓存对象生存时间（缓存寿命）"></a>缓存对象生存时间（缓存寿命）</h2><p>缓存对象的生存时间称为 TTL。对象缓存的时间越长，被重用的可能性就越高。使缓存失效的方法有两种：一种是超时失效；一种是清除失效，也就是实时清除。如下图所示。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgotOV13Eh6AeZaQAABY4_ZmeQk831.png"></p>
<p>所谓的超时失效是在构建缓存，即写缓存的时候，每个缓存对象都设置一个超时时间，在超时之前访问缓存就会返回缓存的数据，而一旦超时，缓存就失效了，这时候再访问缓存，就会返回空。</p>
<p>而实时清除是说，当有缓存对象更新的时候，直接通知缓存将已经被更新了的数据进行清除。清除了以后，应用程序下一次访问这个缓存对象键的时候，就不得不到数据库中去查找读取，这个时候就会得到最新的数据，因为更新总是更新在数据库里的。</p>
<p>还有一种，虽然时间上还没有失效但是新的对象要写入缓存，而内存空间不够了，这个时候就需要将一些老的缓存对象清理掉，为新的缓存对象腾出空间。</p>
<p>内存空间清除主要使用的算法是 LRU 算法，LRU 算法就是最近最久未用算法，也就是说清除那些最近最久没有被访问过的对象。这个算法使用链表结构实现的，所有的缓存对象都放在同一个链表上。当一个对象被访问的时候，就把这个对象移到整个链表的头部。当需要通过 LRU 算法清除那些最近最久未用对象的时候，只需要从队列的尾部进行查找，越是在队列尾部的，越是最近最久没有被访问过的，也就是优先清除的，腾出的内存空间让新对象加入进来。</p>
<h1 id="缓存的主要类型"><a href="#缓存的主要类型" class="headerlink" title="缓存的主要类型"></a>缓存的主要类型</h1><h2 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h2><p>代理缓存是在应用程序—端的代理，缓存在客户端—端的，代理客户端访问互联网。它的主要作用是互联网访问代理。但是同时因为他代理了所有的客户端 HTTP 请求，所以它可以进行页面缓存，如果有一些其他的客户端已经访问过这个网页，那么当新的客户端连接的时候，就可以通过代理缓存中的数据直接返回，避免对数据中心的访问。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgotOV13VcWAYl8OAAC1Z4DMJ1E846.png"></p>
<p>代理缓存是存在客户端一端的缓存，我们无法进行管理。所以代理缓存虽然存在，但是通常不作为我们系统架构中的一部分，我们能够管理的是反向代理缓存。</p>
<h2 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h2><p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgoB5l13VcuAQoUeAACKaiIOlJc476.png"></p>
<p>代理缓存是代理用户上网的，而反向代理则是代理数据中心输出的，是反向代理的。所以反向代理缓存是存在于系统数据中心里的，它是数据中心的统一入口，代理整个数据中心其他服务器的应用处理。</p>
<p>用户通过互联网连接到数据中心的时候，连接的通常是一个反向代理服务器，反向代理服务器根据用户的请求，在本地的反向代理缓存中查找是否有用户请求的数据，如果有就直接返回这个数据，如果没有再把这个请求向下继续转发，请求后面的应用服务器去处理生成数据。</p>
<p>反向代理缓存可以多层反向代理缓存的形式出现。因为我们的应用服务器也是经过分层的，在处理的前端通常是一个前端服务器，后面有 Web 服务器，之后有应用服务器，再后还有其他的各类服务器。在这样一个分层的服务器结构里，我们可以对每一层的服务器都进行反向代理缓存。</p>
<p>如下图所示，前端 Web 服务器和 Web 服务器分为两层，用户请求接入的时候，先接入前端 Web 服务器，其上可以加一层反向代理服务器来代理前端 Web 服务器的 HTTP 请求。如果用户请求的数据已经包含在这个反向代理服务器中，就可以直接返回；如果没有，就再把 HTTP 请求提交给前端 Web 服务器，前端 Web 服务器会把请求发给后面的 Web 服务器。在 Web 服务器和前端 Web 服务器之间还可以再加一层反向代理服务器。如果前端 Web 服务器的请求在这一层的反向代理服务器中存在，那么这一层反向代理服务器可以直接将数据返还；如果不存在，再将请求下发给 Web 服务器。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgotOV13VnaAfPm9AAC46bZcN0w341.png"></p>
<p>通过这样的方式，极大地减少了前端 Web 服务器或者是 Web 服务器的访问压力，同时提高了系统的响应性能。</p>
<h2 id="内容分发网络-CDN-缓存"><a href="#内容分发网络-CDN-缓存" class="headerlink" title="内容分发网络 CDN 缓存"></a>内容分发网络 CDN 缓存</h2><p>所谓的 CDN 是指在用户请求的前端（尽量前的前端）为用户提供数据服务。CDN 并不存在于我们的数据中心，也不存在于用户的访问系统一端，它介于两者之间，作为网络服务商的缓存服务。用户进行互联网访问的时候，需要通过互联网网络服务商提供的网络链接才能够连接到数据中心，那么网络服务商就可以在自己提供的网络服务的机房里进行一次缓存操作，提供一次缓存服务。如下图所示。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgoB5l13Eh6AXvePAAGOZ4Q8scY773.png"></p>
<p>客户端第一次访问 example.com 的时候，访问数据中心，数据中心返回 HTML 页面以后，客户端解析 HTML，HTML 里面还各种 js 文件、css 文件、图片等，这些静态资源访问的就是 CDN 服务器。CDN 服务器检查自己是否有需要的静态资源，如果有，就立即返回给客户端；如果没有，就自己访问数据中心，获得需要的静态资源后，缓存在 CDN 服务器上后，再返回客户端。</p>
<p>所以 CDN 缓存也叫作网络访问的“第一跳”，用户请求先到达的是互联网网络服务商的机房。在机房里面部署 CDN 服务器，提供缓存服务。如果 CDN 中存在用户请求的 Web 响应内容，那么就可以直接通过 CDN 进行返回；如果 CDN 中不存在，那么 CDN 会把这个请求通过后面的网络连接，把它发到系统的数据中心去。数据中心返回的结果依然是先通过 CDN 服务器，CDN 服务器就可以把数据缓存在自己的本地，供后面的用户请求操作响应。</p>
<blockquote>
<p>DN有两种，一种是自己的服务器部署在运营商的机房，CDN服务管理自己做，这台服务器想怎么操作怎么操作，一种是CDN云服务，购买CDN容量后，由CDN服务商提供CDN服务，自己是完全不能控制。<br>反向代理是部署在数据中心服务器前面的一个代理，不能部署在不同区域，除非你在那个区域建了数据中心。</p>
</blockquote>
<h1 id="通读缓存"><a href="#通读缓存" class="headerlink" title="通读缓存"></a>通读缓存</h1><p>上面讲到的代理缓存、反向代理缓存、CDN 缓存，都是通读缓存。它代理了用户的请求，也就是说用户在访问数据的时候，总是要通过通读缓存。</p>
<p>当通读缓存中有需要访问的数据的时候，直接就把这个数据返回；如果没有，再由通读缓存向真正的数据提供者发出请求。其中重要的一点是客户端连接的是通读缓存，而不是生成响应的原始服务器，客户端并不知道真正的原始服务器在哪里，不会直接连接原始服务器，而是由通读缓存进行代理。</p>
<h1 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h1><p>和通读缓存相对应的叫作旁路缓存。前面提到的 key、value 这样的对象缓存就属于旁路缓存。旁路缓存和通读缓存不同。旁路缓存是客户端先访问旁路缓存中是否有自己想要的数据，如果旁路缓存中没有需要的数据，那么由客户端自己去访问真正的数据服务提供者，获取数据。客户端获得数据以后，会自己把这个数据写入到旁路缓存中，这样下一次或者其他客户端去读取旁路缓存的时候就可以获得想要的数据了。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgotOV13ExOAP6m3AAB1BADrv1M771.png"></p>
<p>各种介质数据访问的延迟，以便对数据的存储、缓存的特性以及数据的访问延迟有一个感性的认识。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgoB5l13ExOAQ4DyAADxZOykZ5k976.png"></p>
<p>如上图所示，访问本地内存大概需要 100ns 的时间；使用 SSD 磁盘进行搜索，大概需要 10万ns 时间；数据包在同一个数据中心来回一次的时间，也就是在同一个路由环境里进行一次访问，大概需要 50万ns 时间，也就是 0.5ms；使用非 SSD 磁盘进行一次搜索，大概需要 1000万ns，也就是 10ms 的时间；按顺序从网络中读取 1MB 的数据也是需要 10ms 的时间；按顺序从传统的机械磁盘，即非 SSD 磁盘，读取 1MB 数据，大概需要 30ms 的时间；跨越大西洋进行一次网络数据传输，一个来回大概需要 150ms 的时间。其中，1s 等于 1000ms，等于 10亿ns。</p>
<h1 id="合理使用缓存对象"><a href="#合理使用缓存对象" class="headerlink" title="合理使用缓存对象"></a>合理使用缓存对象</h1><p>缓存虽然效率非常高，使用缓存也非常简单，但是缓存并不是无所不能的，使用缓存的时候需要注意合理使用缓存对象。</p>
<h2 id="注意频繁修改的数据"><a href="#注意频繁修改的数据" class="headerlink" title="注意频繁修改的数据"></a>注意频繁修改的数据</h2><p>缓存数据是为一次写入多次读取准备的，但是如果写入的数据很快就被修改掉了，数据还没来得及读取就已经失效或者更新了，系统的负担就会很重，使用缓存也就没有太多的意义。一般说来，数据的读写比例至少在 2:1 以上，缓存才有意义。</p>
<h2 id="注意没有热点的访问数据"><a href="#注意没有热点的访问数据" class="headerlink" title="注意没有热点的访问数据"></a>注意没有热点的访问数据</h2><p>上面提到缓存是一次写入多次读取的数据，但是如果写入的数据并不会被多次读取，也就是所谓的没有热点，这时候使用缓存也是没有意义的。</p>
<p>我们常见的、日常使用的数据通常都是有热点的。比如说在淘宝中，那些热门的商品可能会被几百万几千万次的访问，那些冷门的商品可能一次访问都没有，热门商品数据就是有热点的，就需要缓存。在微博中也是，那些微博大V们的微博会被几百万几千万的粉丝访问，他们的微博数据也是有热点的，而那些没有几个粉丝的博主的微博，几乎不会被访问，这些数据是没有热点的。所以缓存存储的就是淘宝上那些热门的商品，微博上那些大V的微博，它们都是有热点的缓存，这些数据都能实现一次写入多次甚至非常多次的读取，这种缓存就有效果。但还是有一些业务场景数据是没有热点的，那么这一类业务场景数据就不需要使用缓存。</p>
<h2 id="注意数据不一致和脏读"><a href="#注意数据不一致和脏读" class="headerlink" title="注意数据不一致和脏读"></a>注意数据不一致和脏读</h2><p>缓存中的数据有可能和主存储数据库中的数据不一致。这个问题主要是通过失效时间来解决的，也就是说这个业务能够容忍的失效时间之内，保持缓存中的数据和数据库中的数据不一致，比如说淘宝的商品数据，如果卖家在对商品的数据进行了编辑，这个时候可能买家是看不到这些被更新过的数据的，可能需要几分钟的时间，比如是 3 分钟，那么 3 分钟之内，卖家编辑的数据买家是看不到的，但这种延迟通常是可以接受的。</p>
<p>如果某些业务场景对更新非常敏感，必须要实时看到，这个时候就不能够使用失效时间进行缓存过期处理了，可能需要进行失效通知。当数据进行更新的时候，立即清除缓存中的数据，下次访问这个数据的时候，缓存必须要重新从主数据库中去加载，才能够得到最新的数据。</p>
<h2 id="注意缓存雪崩"><a href="#注意缓存雪崩" class="headerlink" title="注意缓存雪崩"></a>注意缓存雪崩</h2><p>因为热点数据主要是从缓存中去读取的，而热点数据是数据访问压力最大的一类数据。这些数据都从缓存中读取，极大地降低了数据库的访问压力。</p>
<p>而数据库整个系统也是在有缓存的情况下进行设计的，数据库的处理能力是强依赖缓存的。如果缓存忽然崩溃了，那么所有的访问压力就都会传递到数据库上去。数据库不能够承受这样的访问压力，可能也会崩溃。数据库崩溃了以后，应用程序访问不到数据库，请求不断超时，负载压力不断升高，应用程序服务器也会崩溃，最后导致整个网站所有服务器崩溃。这就是缓存雪崩。这种情况下系统甚至无法启动，因为系统启动后，新的访问压力又过来，依然是那么大，还是会崩溃。</p>
<p>这时候重启缓存也是没有用的，因为重启的话缓存中是没有数据的。我们刚才也讲到，对象缓存是通过加载数据库中的数据并写入到缓存中才有数据的。重新启动的缓存没有数据，它就不能够承担提供数据读操作的能力。所以，对缓存有重点依赖的系统，需要特别关注缓存的可用性。缓存用的部分数据丢失可以到数据库中加载，但是如果全部的缓存数据都丢失了，可能导致整个系统都会崩溃，特别需要注意。</p>
<h1 id="分布式对象缓存"><a href="#分布式对象缓存" class="headerlink" title="分布式对象缓存"></a>分布式对象缓存</h1><p>下面看一下分布式对象缓存，如下图所示。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgotOV13ExSAWhCFAACFNPzM4Q8959.png"></p>
<p>分布式对象缓存是系统架构中比较重要的一部分内容。所谓的分布式对象缓存是指对象缓存以一个分布式集群的方式对外提供服务，多个应用系统使用同一个分布式对象缓存提供的缓存服务。这里的缓存服务器是由多台服务器组成的，这些服务器共同构成了一个集群对外提供服务。所以使用分布式对象缓存的一个重要问题就是，数据进行读写操作的时候，如何找到正确的缓存服务器进行读写操作。如果第一次写入数据的时候写入的是 A 服务器，但是数据进行缓存读操作的时候访问的是 B 服务器，就不能够正确地查找到数据，缓存也就没有了效果。</p>
<p>那么，如何才能找到正确的缓存服务器呢？以 Memcached 服务器集群为例，我们来看一下分布式对象的缓存模型，如下图。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgoB5l13V3yAaDSfAACw9us7nBY044.png"></p>
<p>当需要进行分布式缓存访问的时候，依然是以 Key、value 这样的数据结构进行访问。如上图所示的例子中就是 BEIJING 作为 Key，一个 DATA 数据作为它的 value。当需要进行分布式对象访问的时候，应用程序需要使用分布式对象缓存的客户端 SDK。比如说 Memcached 提供的一个客户端 API 程序进行访问，客户端 API 程序会使用自己的路由算法进行路由选择，选择其中的某一台服务器，找到这台服务器的 IP 地址和端口以后，通过通讯模块和相对应的服务器进行通信。</p>
<p>因为进行路由选择的时候，就是使用缓存对象的 key 进行计算。下一次使用相同的 key 使用相同路由算法进行计算的时候，算出来的服务器依然还是前面计算出来的这个服务器。所以通过这种方法可以访问到正确的服务器进行数据读写。服务器越多，提供的缓存空间就越大，实现的缓存效果也就越好。通过集群的方式，提供了更多的缓存空间。</p>
<p>那么，路由算法又是如何进行服务器路由选择的？主要算法依然是上面讲到的哈希表的路由算法，也就是取模算法。</p>
<p>比如说，我们这里缓存服务器集群中有 3 台服务器，key 的哈希值对 3 取模得到的余数一定在 0、1、2 三个数据之间，那么每一个数字都对应着一台服务器，根据这个数字查找对应的服务器 IP 地址就可以了。使用余数取模这种方式进行路由计算非常简单，但这种算法也有一个问题，就是当服务器进行扩容的时候，比如说我们当前的服务器集群有 3 台服务器，如果我们 3 台服务器不够用了，需要添加 1 台服务器，这个时候对 3 取模就会变成对 4 去取模，导致的后果就是以前对 3 取模的时候写入的数据，对 4 取模的时候可能就查找不到了。</p>
<p>上面也讲过缓存雪崩的情况，实际上如果使用取模算法进行服务器添加，因为除数的变化会导致和缓存雪崩一样的后果，也就是说前面写入缓存服务器集群中的缓存数据，添加了 1 台服务器后很多数据都找不到了，类似于雪崩，最后会导致整个服务器集群都崩溃。</p>
<p>我们添加服务器的主要目的是提高它的处理能力，但是不正确的操作可能会导致整个集群都失效。解决这个问题的主要手段是使用一致性哈希算法。</p>
<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><p>一致性哈希和余数哈希不同，一致性哈希首先是构建一个一致性哈希环的结构。一致性哈希环的大小是 0～2 的 32 次方减 1，实际上就是我们计算机中无符号整型值的取值范围，这个取值范围的 0 和最后一个值 2 的 32 次方减 1 首尾相连，就构成了一个一致性哈希环，如下图所示。</p>
<p><img src="/2021/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/CgotOV13ExWAGFH2AACSu5nTgAw967.png"></p>
<p>对每个服务器的节点取模，求它的哈希值并把这个哈希值放到环上，所有的服务器都取哈希值放到环上，每一次进行服务器查找路由计算的时候，把 key 也取它的哈希值，取到哈希值以后把 key 放到环上，顺时针查找距离它最近的服务器的节点是哪一个，它的路由节点就是哪一个。通过这种方式也可以实现，key 不变的情况下找到的总是相同的服务器。这种一致性哈希算法除了可以实现像余数哈希一样的路由效果以外，对服务器的集群扩容效果也非常好。</p>
<p>在一致性哈希环上进行服务器扩容的时候，新增加一个节点不需要改动前面取模算法里的除数，导致最后的取值结果全部混乱，它只需要在哈希环里根据新的服务器节点的名称计算它的哈希值，把哈希值放到这个环上就可以了。放到环上后，它不会影响到原先节点的哈希值，也不会影响到原先服务器在哈希环上的分布，它只会影响到离它最近的服务器，比如上图中 NODE3 是新加入的服务器，那么它只会影响到 NODE1，原先访问 NODE1 的 key 会访问到 NODE3 上，也就是说对缓存的影响是比较小的，它只会影响到缓存里面的一小段。如果缓存中一小部分数据受到了影响，不能够正确的命中，那么可以去数据库中读取，而数据库的压力只要在它的负载能力之内，也不会崩溃，系统就可以正常运行。所以通过一致性哈希算法可以实现缓存服务器的顺利伸缩扩容。</p>
<p>但是一致性哈希算法有着致命的缺陷。我们知道哈希值其实是一个随机值，把一个随机值放到一个环上以后，可能是不均衡的，也就是说某两个服务器可能距离很近，而和其它的服务器距离很远，这个时候就会导致有些服务器的负载压力特别大，有些服务器的负载压力非常小。同时在进行扩容的时候，比如说加入一个节点 3，它影响的只是节点 1，而我们实际上希望加入一个服务器节点的时候，它能够分摊其它所有服务器的访问压力和数据冲突。</p>
<p>所以对这个算法需要进行一些改进，改进办法就是使用虚拟节点。也就是说我们这一个服务器节点放入到一致性哈希环上的时候，并不是把真实的服务器的哈希值放到环上，而是将一个服务器虚拟成若干个虚拟节点，把这些虚拟节点的 hash 值放到环上去。在实践中通常是把一个服务器节点虚拟成 200 个虚拟节点，然后把 200 个虚拟节点放到环上。key 依然是顺时针的查找距离它最近的虚拟节点，找到虚拟节点以后，根据映射关系找到真正的物理节点。</p>
<p>第一，可以解决我们刚才提到的负载不均衡的问题，因为有更多的虚拟节点在环上，所以它们之间的距离总体来说大致是相近的。第二，在加入一个新节点的时候，是加入多个虚拟节点的，比如 200 个虚拟节点，那么加入进来以后环上的每个节点都可能会受到影响，从而分摊原先每个服务器的一部分负载。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>缓存的主要优点是实现方法比较简单，同时提升的效果又非常明显。所以缓存是架构性能优化的一个重要手段。</p>
<p>影响缓存的主要指标是缓存命中率。影响命中率的几个关键因素是缓存键集合的大小、缓存空间的大小和缓存对象的存在时间，也就是缓存的寿命。缓存的主要类型有代理缓存、反向代理缓存、CDN 缓存，这三类缓存叫作通读缓存。</p>
<p>客户端使用通读缓存的时候，不需要知道后面真实的数据存储服务器在哪里，只需要访问通读缓存，由通读缓存去访问真正的数据提供服务器。另一类缓存就是旁路缓存。这类缓存就是我们在系统架构中常用的对象缓存。使用旁路缓存的时候，应用程序一方面需要知道缓存，需要连接缓存服务器，通过缓存服务器去查找数据，如果缓存服务器中没有查到数据，那么就自己去连接数据库，从数据库中去查找数据，并且在返回数据以后，还要把这个数据当作缓存写入到缓存服务器中去，以便于下一次读取的时候从缓存中读取。</p>
<p>缓存虽然对系统性能提升非常明显，但是也还是需要对缓存进行合理的使用，在合适的场景下进行使用。第一点是关注频繁修改的数据，如果一个数据经常被修改，那么使用缓存可能就价值不大；第二点是缓存要有热点，因为缓存的空间总是有限的，只能存储一小部分的数据，如果被访问的数据概率都是一样的，没有热点，数据极有可能写入缓存以后很快又被清除掉了，没有被读取过，体现不出来缓存的价值；还有两点分别是注意缓存雪崩和关注缓存的数据一致性。</p>
<p>分布式对象缓存是我们分布式架构中用的比较多的一种缓存。使用分布式缓存要注意的是：缓存的路由算法是如何实现的？比较重要的、用的比较广泛的是一致性哈希算法。</p>
<p>总之，缓存是无处不在的。在整个计算机系统中，在各个地方，只要你能够想得到的，都可以使用缓存来提升性能，甚至应用程序、一段代码中都可以使用缓存。所以我们要多关注缓存的使用，同时也要关注使用缓存的那些注意点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/" class="post-title-link" itemprop="url">架构的演进</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 14:28:34" itemprop="dateCreated datePublished" datetime="2021-05-13T14:28:34+08:00">2021-05-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="大型互联网系统的特点"><a href="#大型互联网系统的特点" class="headerlink" title="大型互联网系统的特点"></a>大型互联网系统的特点</h1><ul>
<li>高并发和大流量</li>
<li>高可用</li>
<li>海量的数据存储</li>
<li>用户分布广泛，网络情况复杂</li>
<li>安全环境恶劣</li>
<li>需求变化快，发布频繁</li>
</ul>
<h1 id="系统处理能力提升的两种途径"><a href="#系统处理能力提升的两种途径" class="headerlink" title="系统处理能力提升的两种途径"></a>系统处理能力提升的两种途径</h1><p><strong>垂直伸缩</strong></p>
<p>提升单台服务器的处理能力，比如说用更快频率、更多核的 CPU，用更大的内存，用更快的网卡，用更多的磁盘组成一台服务器，使单台服务器的处理能力得到提升，通过这种手段提升系统的处理能力。</p>
<p>垂直伸缩是有物理极限的。</p>
<p><strong>水平伸缩</strong></p>
<p>不提升单机的处理能力，并不使用更昂贵的、更快的、更厉害的硬件，而是使用更多的服务器，将这些服务器构成一个分布式集群。这个集群统一对外提供服务，来提高系统整体的处理能力。</p>
<h1 id="大型互联网架构演化进程"><a href="#大型互联网架构演化进程" class="headerlink" title="大型互联网架构演化进程"></a>大型互联网架构演化进程</h1><p>通过水平伸缩方式逐步提升系统处理能力。</p>
<p><img src="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/CgotOV3CmD6AKRcaAACenjL209A164.png"></p>
<p>最早的时候是单机系统，这时候可以满足少量用户的使用；随着数据量提升，需要进行应用服务器与数据库分离，这时候可以满足万级用户的使用；再然后需要通过分布式缓存和服务器集群提升系统性能，可以满足十万级的用户；之后需要进行反向代理，CDN 加速，还需要数据库读写分离，以满足百万用户级的访问；随着数据量爆发式增长，使用分布式文件系统和分布式数据库系统，以满足千万级用户的访问；最后使用搜索引擎、NoSQL、消息队列、分布式服务等更复杂的技术方案，以满足亿级用户的访问。</p>
<h2 id="单机系统"><a href="#单机系统" class="headerlink" title="单机系统"></a>单机系统</h2><p>系统用户量比较少，这个阶段系统主要是用来验证技术以及业务模式是否可行，系统也不需要太复杂，只需要具备有限的几个主要功能。应用程序开发完以后，部署在应用服务器上，一个应用访问自己服务器上的数据库，访问自己服务器的文件系统，如下图所示，这就构成了一个单机系统，这个系统就可以满足少量用户使用了。</p>
<p><img src="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/CgoB5l3CmD6AOEZVAABaeSGKaEA198.png"></p>
<p>数据库与应用分离</p>
<p><img src="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/CgotOV3CmD6AH38UAABbcygMlJ4802.png"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>进行第一次分离的时候，应用程序、数据库、文件系统分别部署在不同的服务器上，从 1 台服务器变成了 3 台服务器，那么相应的处理能力就提升了 3 倍。这种分离几乎是不需要技术成本的，只需要把数据库文件系统进行远程部署和远程访问就可以了，这个时候的处理能力提升了 3 倍。  </p>
<p>然而随着用户进一步的增加，更多的用户过来访，3 台服务器也不能够承受这样的压力了，那么就需要使用缓存改善性能。</p>
<p><img src="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/CgoB5l3CmD-AHQpjAARLZMw6qLA045.png"></p>
<h2 id="反向代理和-CDN-加速"><a href="#反向代理和-CDN-加速" class="headerlink" title="反向代理和 CDN 加速"></a>反向代理和 CDN 加速</h2><p>在对数据库做读写分离以后，要想更进一步增加系统的处理能力，需要使用反向代理和 CDN 加速。</p>
<p><img src="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/CgotOV3CmD-AHLZiAATtWWZkrPg912.png"></p>
<p>所谓的 CDN 是指距离用户最近的一个服务器，当访问一个互联网应用的时候，我们的访问请求并不是直接到达互联网站的数据中心的，而是通过运营服务商进行数据转发的。那么在进行数据转发的时候，最好已经有我们想要访问的数据，这样就不需要访问互联网数据中心了。这个服务就叫作 CDN 服务。</p>
<p>CDN 服务就是部署在网络运营商机房里的离用户最近的一个服务器，用户请求先到这里查询有没有用户需要的数据，如果有，就从 CDN 直接返回，如果没有，再通过 CDN 进一步访问网站的数据中心，得到数据后再缓存到 CDN 供其他用户访问或下一次访问，所以 CDN 的本质还是一个缓存。</p>
<p>用户请求到达网站的数据中心后，也不是直接请求应用服务器，依然是查找一次缓存，这个缓存叫作反向代理服务器。</p>
<p>反向代理服务器是指通过反向代理的方式代理整个网站的请求服务，先在反向代理服务器中查找是否有用户请求的数据，如果有，就从反向代理服务器直接返回；如果没有，再去请求应用服务器。通过这样的 CDN 和反向代理两级缓存，可以返回绝大部分用户请求的网络数据，极大地减少应用服务器的负载压力，提升服务器数据中心的处理能力，响应更多的用户并发处理请求。</p>
<h2 id="分布式文件系统和分布式数据库系统"><a href="#分布式文件系统和分布式数据库系统" class="headerlink" title="分布式文件系统和分布式数据库系统"></a>分布式文件系统和分布式数据库系统</h2><p>虽然 CDN 和反向代理已经缓存了大量的用户数据，返回了大量的用户请求，但是随着用户量的增加，还是有很多的用户请求会到达数据中心。这个时候文件系统和数据库系统依然会成为瓶颈点。</p>
<p>那么如何解决这个瓶颈点？解决方案主要是分布式的文件系统和分布式的数据库系统。</p>
<p><img src="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/CgoB5l3CmD-ANwLJAATrecWoQMY588.png"></p>
<p>所谓的分布式文件系统就是通过一组服务器集群统一对外提供文件服务。像淘宝的商品图片服务以及 Facebook 这样的相册服务，每天都有大量的用户上传大量的图片，那么如何管理这些海量的文件图片？这就要使用一个分布式的文件服务器系统。</p>
<p>随着数据量逐渐增加，前面讲的主从数据库也不能够承受这么大的访问压力和存储容量要求，那么就需要对数据库做进一步水平伸缩，使用分布式的数据库。即通过数据分片的方式，将一张表的数据分布在多个物理服务器上，以减少单一数据库的服务器访问压力。通过这样的手段可以进一步提升系统的处理能力。</p>
<h2 id="消息队列与分布式服务"><a href="#消息队列与分布式服务" class="headerlink" title="消息队列与分布式服务"></a>消息队列与分布式服务</h2><p>随着用户量进一步增加，要想实现更强大的计算处理能力，可以使用的技术手段有分布式消息队列服务、搜索引擎和 NoSQL，以及通过分布式服务，将可复用的业务分离开来，部署在不同的服务器集群上。</p>
<p>用户量增加，除了意味着用户对系统的访问压力增加，还伴随着业务复杂度增加。使用分布式消息队列和分布式的服务，主要解决的就是业务增加时系统的复杂度问题。</p>
<p><img src="/2021/05/13/%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B/CgotOV3CmECANzBPAAb6gRmDIYU050.png"></p>
<p>随着业务的增加，很多的业务都有一些重复的服务功能需要复用，这时候使用分布式的服务去解决服务的复用问题。而不同的服务、不同的应用之间，它们的耦合关系会使得系统更加复杂，这时候使用分布式消息队列服务，将不同的应用服务器进行解耦，通过消息进行连接，而不是服务调用的方式或者应用调用的方式进行连接，使它们之间的关系变得低耦合，使服务变得更加简单，使系统的处理能力和扩容能力变得更加的强大。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>使用分布式的缓存，提高系统的访问特性，减少数据存储的压力；</li>
<li>使用负载均衡，提供更多的应用服务器提高系统计算处理能力；</li>
<li>使用分布式存储，提供更多的服务器，分摊数据的读写压力；</li>
<li>使用微服务与异步架构，使系统变得更加低耦合，使应用业务变得更加可复用，提升业务处理能力，从而支撑起一个大型网站系统架构。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/04/15/Android-Jetpack%E4%B9%8BLiveData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/15/Android-Jetpack%E4%B9%8BLiveData/" class="post-title-link" itemprop="url">Android Jetpack之LiveData</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-15 09:31:20" itemprop="dateCreated datePublished" datetime="2021-04-15T09:31:20+08:00">2021-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="LiveData介绍"><a href="#LiveData介绍" class="headerlink" title="LiveData介绍"></a>LiveData介绍</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>LiveData是一个重要组件，也是一个同名抽象类。</p>
<blockquote>
<p>LiveData是一种可观察的数据存储器类。与常规的可观察类不同，LiveData具有生命周期感知能力，意指它遵循其他应用组件（如Activity&#x2F;Fragment）的生命周期。这种感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者。</p>
</blockquote>
<p>解读：     </p>
<ol>
<li>LiveData是一个数据持有者，给源数据包装一层。</li>
<li>源数据使用LiveData包装后，可以被observer观察，数据有更新时observer可感知。</li>
<li>但observer的感知，只发生在（Activity&#x2F;Fragment）活跃生命周期状态（STARTED、RESUMED）。</li>
</ol>
<p>也就是说，<strong>LiveData使得数据的更新能以观察者模式被observer感知，且此感知只发生在LifecycleOwner的活跃生命周期状态</strong>。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>使用LiveData具有以下优势：</p>
<ul>
<li><strong>确保界面符合数据状态</strong>，当生命周期状态变化时，LiveData通知Observer，可以在observer中更新界面。观察者可以在生命周期状态更改时刷新界面，而不是在每次数据变化时刷新界面。</li>
<li><strong>不会发生内存泄漏</strong>，observer会在LifecycleOwner状态变为DESTROYED后自动remove。</li>
<li><strong>不会因Activity停止而导致崩溃</strong>，如果LifecycleOwner生命周期处于非活跃状态，则它不会接收任何LiveData事件。</li>
<li><strong>不需要手动解除观察</strong>，开发者不需要在onPause或onDestroy方法中解除对LiveData的观察，因为LiveData能感知生命周期状态变化，所以会自动管理所有这些操作。</li>
<li><strong>数据始终保持最新状态</strong>，数据更新时，若LifecycleOwner为非活跃状态，那么会在变为活跃时接收最新数据。例如，曾经在后台的Activity会在返回前台后，observer立即接收最新的数据。</li>
</ul>
<h4 id="LiveData的使用"><a href="#LiveData的使用" class="headerlink" title="LiveData的使用"></a>LiveData的使用</h4><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>基本用法：</p>
<ol>
<li>创建LiveData实例，指定源数据类型。</li>
<li>创建Observer实例，实现onChanged()方法，用于接收源数据变化并刷新UI。</li>
<li>LiveData实例使用observe()方法添加观察者，并传入LifecycleOwner。</li>
<li>LiveData实例使用setVale()&#x2F;postVale()更新源数据（子线程要postValue()）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiveDataTestActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> MutableLiveData&lt;String&gt; mLiveData;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_lifecycle_test);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//liveData基本使用</span></span><br><span class="line">       mLiveData = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;();</span><br><span class="line">       mLiveData.observe(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(String s)</span> &#123;</span><br><span class="line">               Log.i(TAG, <span class="string">&quot;onChanged: &quot;</span>+s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       Log.i(TAG, <span class="string">&quot;onCreate: &quot;</span>);</span><br><span class="line">       mLiveData.setValue(<span class="string">&quot;onCreate&quot;</span>);<span class="comment">//activity是非活跃状态，不会回调onChanged。变为活跃时，value被onStart中的value覆盖</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onStart();</span><br><span class="line">       Log.i(TAG, <span class="string">&quot;onStart: &quot;</span>);</span><br><span class="line">       mLiveData.setValue(<span class="string">&quot;onStart&quot;</span>);<span class="comment">//活跃状态，会回调onChanged。并且value会覆盖onCreate、onStop中设置的value</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onResume();</span><br><span class="line">       Log.i(TAG, <span class="string">&quot;onResume: &quot;</span>);</span><br><span class="line">       mLiveData.setValue(<span class="string">&quot;onResume&quot;</span>);<span class="comment">//活跃状态，回调onChanged</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onPause();</span><br><span class="line">       Log.i(TAG, <span class="string">&quot;onPause: &quot;</span>);</span><br><span class="line">       mLiveData.setValue(<span class="string">&quot;onPause&quot;</span>);<span class="comment">//活跃状态，回调onChanged</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onStop();</span><br><span class="line">       Log.i(TAG, <span class="string">&quot;onStop: &quot;</span>);</span><br><span class="line">       mLiveData.setValue(<span class="string">&quot;onStop&quot;</span>);<span class="comment">//非活跃状态，不会回调onChanged。后面变为活跃时，value被onStart中的value覆盖</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>.onDestroy();</span><br><span class="line">       Log.i(TAG, <span class="string">&quot;onDestroy: &quot;</span>);</span><br><span class="line">       mLiveData.setValue(<span class="string">&quot;onDestroy&quot;</span>);<span class="comment">//非活跃状态，且此时Observer已被移除，不会回调onChanged</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意到 LiveData实例mLiveData的创建是使用MutableLiveData，它是LiveData的实现类，且指定了源数据的类型为String。然后创建了接口Observer的实例，实现其onChanged()方法，用于接收源数据的变化。observer和Activity一起作为参数调用mLiveData的observe()方法，表示observer开始观察mLiveData。然后Activity的所有生命周期方法中都调用了mLiveData的setValue()方法。</p>
<p>另外，除了使用observe()方法添加观察者，也可以使用<strong>observeForever</strong>(Observer) 方法来注册未关联 LifecycleOwner的观察者。在这种情况下，观察者会被视为始终处于活跃状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/04/14/Android-Jetpack%E4%B9%8BLifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/14/Android-Jetpack%E4%B9%8BLifecycle/" class="post-title-link" itemprop="url">Android Jetpack之Lifecycle</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 13:48:19" itemprop="dateCreated datePublished" datetime="2021-04-14T13:48:19+08:00">2021-04-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Android-Jepack介绍"><a href="#Android-Jepack介绍" class="headerlink" title="Android Jepack介绍"></a>Android Jepack介绍</h4><blockquote>
<p>Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳做法，减少样板代码并编写可在各种Android版本和设备中一致运行的代码，让开发者精力集中编写重要的代码。</p>
</blockquote>
<p>使用Jetpack的好处：</p>
<ul>
<li><strong>遵循最佳做法</strong>，Android Jetpack 组件采用最新的设计方法构建，具有向后兼容性，可以减少崩溃和内存泄露。</li>
<li><strong>消除样本代码</strong>，Android Jetpack 可以管理各种繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于打造出色的应用。</li>
<li><strong>减少不一致</strong>，这些库可在各种 Android 版本和设备中以一致的方式运作，助您降低复杂性。</li>
</ul>
<h4 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h4><p>Lifecycle是用来帮助开发者管理Activity和Fragment的生命周期。    </p>
<p>Lifecycle是一个库，它包含Lifecycle类，Lifecycle类用于存储有关组件（如Acitivity或Fragment）的生命周期状态的信息，并允许其他对象观察此状态。   </p>
<p>Lifycycle使用两种主要枚举跟踪其关联组件的生命周期状态：     </p>
<ul>
<li><p>事件     </p>
<p>从框架和Lifecycle类分派的生命周期事件。这些事件映射到Activity和Fragment中的回调事件。        </p>
</li>
<li><p>状态      </p>
<p>由Lifecyle对象跟踪的组件的当前状态</p>
</li>
</ul>
<p><img src="/2021/04/14/Android-Jetpack%E4%B9%8BLifecycle/lifecycle-states.svg" alt="构成 Android Activity 生命周期的状态和事件"></p>
<h5 id="Lifecycle的使用"><a href="#Lifecycle的使用" class="headerlink" title="Lifecycle的使用"></a>Lifecycle的使用</h5><h6 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h6><p>非androidx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot;</span><br></pre></td></tr></table></figure>



<p>androidx</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="type">def</span> <span class="variable">lifecycle_version</span> <span class="operator">=</span> <span class="string">&quot;2.3.0&quot;</span></span><br><span class="line">    <span class="type">def</span> <span class="variable">arch_version</span> <span class="operator">=</span> <span class="string">&quot;2.1.0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation processor</span></span><br><span class="line">    annotationProcessor <span class="string">&quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - helpers for implementing LifecycleOwner in a Service</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ProcessLifecycleOwner provides a lifecycle for the whole application process</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-reactivestreams:$lifecycle_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">&quot;androidx.arch.core:core-testing:$arch_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看着有很多，实际上如果只使用Lifecycle，只需要引入lifecycle-runtime即可。但通常都是和 ViewModel、 LiveData 配套使用的，所以lifecycle-viewmodel、lifecycle-livedata 一般也会引入。</p>
<h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><ol>
<li>生命周期拥有者使用getLifecycle()获取Lifecycle实例，然后用addObserve()添加观察者。    </li>
<li>观察者实现LifecycleObserve，方法上用OnLifecycleEvent注解关注对应生命周期，生命周期触发时就会执行对应方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectListener</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnectListener</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifecycleTestActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_lifecycle_test);</span><br><span class="line">        <span class="comment">//Lifecycle 生命周期</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">MyObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Activity（或Fragment）是生命周期的拥有者，通过getLifecycle()方法获取到生命周期Lifecycle对象，Lifecycle对象使用addObserver方法 给自己添加观察者，即MyObserver对象。当Lifecycle的生命周期发生变化时，MyObserver就可以感知到。</p>
<h6 id="MVP架构中的使用"><a href="#MVP架构中的使用" class="headerlink" title="MVP架构中的使用"></a>MVP架构中的使用</h6><p>如果在MVP架构中，可以把presenter作为观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifecycleTestActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">IView</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;Lifecycle_Test&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_lifecycle_test);</span><br><span class="line">        <span class="comment">//Lifecycle 生命周期</span></span><br><span class="line"><span class="comment">//        getLifecycle().addObserver(new MyObserver());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//MVP中使用Lifecycle</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">MyPresenter</span>(<span class="built_in">this</span>));</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onResume: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onPause: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showView</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hideView</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Presenter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPresenter</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;Lifecycle_Test&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IView mView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPresenter</span><span class="params">(IView view)</span> &#123;mView = view;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(value = Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getDataOnStart</span><span class="params">(LifecycleOwner owner)</span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;getDataOnStart: &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">                <span class="comment">//checkUserStatus是耗时操作，回调后检查当前生命周期状态</span></span><br><span class="line">                <span class="keyword">if</span> (owner.getLifecycle().getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">                	start();</span><br><span class="line">                    mView.showView();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent(value = Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hideDataOnStop</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;hideDataOnStop: &quot;</span>);</span><br><span class="line">        stop();</span><br><span class="line">        mView.hideView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IView</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IView</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showView</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hideView</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里是让Presenter实现LifecycleObserver接口，同样在方法上注解要触发的生命周期，最后在Activity中作为观察者添加到Lifecycle中。</p>
<p>这样做好处是啥呢？ 当Activity生命周期发生变化时，MyPresenter就可以感知并执行方法，不需要在MainActivity的多个生命周期方法中调用MyPresenter的方法了。</p>
<ul>
<li><strong>所有方法调用操作都由组件本身管理</strong>：Presenter类自动感知生命周期，如果需要在其他的Activity&#x2F;Fragment也使用这个Presenter，只需添加其为观察者即可。</li>
<li><strong>让各个组件存储自己的逻辑，减轻Activity&#x2F;Fragment中代码，更易于管理</strong>；</li>
</ul>
<p>另外，注意到 getDataOnStart()中耗时校验回调后，对当前生命周期状态进行了检查：至少处于STARTED状态才会继续执行start()方法，也就是保证了Activity停止后不会走start()方法；</p>
<h6 id="自定义LifecycleOwner"><a href="#自定义LifecycleOwner" class="headerlink" title="自定义LifecycleOwner"></a>自定义LifecycleOwner</h6><p>在Activity中调用getLifecycle()能获取到Lifecycle实例，getLifecycle()是在接口LifecycleOwner中定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生命周期拥有者</span></span><br><span class="line"><span class="comment"> * 生命周期事件可被 自定义的组件 用来 处理生命周期事件的变化，同时不会在Activity/Fragmen中写任何代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleOwner</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    Lifecycle <span class="title function_">getLifecycle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Support Library 26.1.0及以上、AndroidX的 Fragment 和 Activity 已实现 LifecycleOwner 接口，所以我们在Activity中可以直接使用getLifecycle()。</p>
<p>如果有一个自定义类并希望使其成为LifecycleOwner，可以使用LifecycleRegistry类，它是Lifecycle的实现类，但需要将事件转发到该类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> <span class="keyword">implements</span> <span class="title class_">LifecycleOwner</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> LifecycleRegistry lifecycleRegistry;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">           lifecycleRegistry = <span class="keyword">new</span> <span class="title class_">LifecycleRegistry</span>(<span class="built_in">this</span>);</span><br><span class="line">           lifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.onStart();</span><br><span class="line">           lifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@NonNull</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Lifecycle <span class="title function_">getLifecycle</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> lifecycleRegistry;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>MyActivity实现LifecycleOwner，getLifecycle()返回lifecycleRegistry实例。lifecycleRegistry实例则是在onCreate创建，并且在各个生命周期内调用markState()方法完成生命周期事件的传递。这就完成了LifecycleOwner的自定义，也即MyActivity变成了LifecycleOwner，然后就可以和 实现了LifecycleObserver的组件配合使用了。</p>
<p>补充一点，<strong>观察者的方法可以接受一个参数LifecycleOwner</strong>，就可以用来获取当前状态、或者继续添加观察者。 若注解的是ON_ANY还可以接收Event，用于区分是哪个事件。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title class_">TestObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onCreated</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line"><span class="comment">//            owner.getLifecycle().addObserver(anotherObserver);</span></span><br><span class="line"><span class="comment">//            owner.getLifecycle().getCurrentState();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_ANY)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onAny</span><span class="params">(LifecycleOwner owner, Lifecycle.Event event)</span> &#123;</span><br><span class="line"><span class="comment">//            event.name()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="Application生命周期-ProcessLifecycleOwner"><a href="#Application生命周期-ProcessLifecycleOwner" class="headerlink" title="Application生命周期 ProcessLifecycleOwner"></a>Application生命周期 ProcessLifecycleOwner</h6><p>之前对App进入前后台的判断是通过registerActivityLifecycleCallbacks(callback)方法，然后在callback中利用一个全局变量做计数，在onActivityStarted()中计数加1，在onActivityStopped方法中计数减1，从而判断前后台切换。</p>
<p>而使用ProcessLifecycleOwner可以直接获取应用前后台切换状态。（记得先引入lifecycle-process依赖）</p>
<p>使用方式和Activity中类似，只不过要使用ProcessLifecycleOwner.get()获取ProcessLifecycleOwner，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册App生命周期观察者</span></span><br><span class="line">        ProcessLifecycleOwner.get().getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">ApplicationLifecycleObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Application生命周期观察，提供整个应用进程的生命周期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Lifecycle.Event.ON_CREATE只会分发一次，Lifecycle.Event.ON_DESTROY不会被分发。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一个Activity进入时，ProcessLifecycleOwner将分派Lifecycle.Event.ON_START, Lifecycle.Event.ON_RESUME。</span></span><br><span class="line"><span class="comment">     * 而Lifecycle.Event.ON_PAUSE, Lifecycle.Event.ON_STOP，将在最后一个Activit退出后后延迟分发。如果由于配置更改而销毁并重新创建活动，则此延迟足以保证ProcessLifecycleOwner不会发送任何事件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 作用：监听应用程序进入前台或后台</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ApplicationLifecycleObserver</span> <span class="keyword">implements</span> <span class="title class_">LifecycleObserver</span> &#123;</span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onAppForeground</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;ApplicationObserver: app moved to foreground&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onAppBackground</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;ApplicationObserver: app moved to background&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/04/13/Redis%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/13/Redis%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Redis命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-13 23:33:51" itemprop="dateCreated datePublished" datetime="2021-04-13T23:33:51+08:00">2021-04-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis数据结构介绍"><a href="#Redis数据结构介绍" class="headerlink" title="Redis数据结构介绍"></a>Redis数据结构介绍</h1><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p>
<p><img src="/2021/04/13/Redis%E5%91%BD%E4%BB%A4/image-20230412233737852.png" alt="image-20230412233737852"></p>
<p>查询命令官网地址：<a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands</a></p>
<h1 id="Key的层级结构"><a href="#Key的层级结构" class="headerlink" title="Key的层级结构"></a>Key的层级结构</h1><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p>
<p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>





<h1 id="Redis-通用命令"><a href="#Redis-通用命令" class="headerlink" title="Redis 通用命令"></a>Redis 通用命令</h1><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<p>通过help [command] 可以查看一个命令的具体用法，例如：</p>
<p><img src="/2021/04/13/Redis%E5%91%BD%E4%BB%A4/1652887865189.png"></p>
<ul>
<li>KEYS</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询以a开头的key</span></span><br><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</p>
</blockquote>
<ul>
<li>DEL</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> del</span><br><span class="line"></span><br><span class="line">  DEL key [key ...]</span><br><span class="line">  summary: Delete a key</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del name <span class="comment">#删除单个</span></span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment">#成功删除1个</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 <span class="comment">#批量添加数据</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">(<span class="built_in">integer</span>) 3   <span class="comment">#此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment">#再查询全部的key</span></span><br><span class="line">1) <span class="string">&quot;age&quot;</span>	<span class="comment">#只剩下一个了</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>EXISTS</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> EXISTS</span><br><span class="line"></span><br><span class="line">  EXISTS key [key ...]</span><br><span class="line">  summary: Determine <span class="keyword">if</span> a key exists</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<ul>
<li>EXPIRE</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire age 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2  <span class="comment">#当这个key过期了，那么此时查询出来就是-2 </span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 10 <span class="comment">#如果没有设置过期时间</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1  <span class="comment"># ttl的返回值就是-1</span></span><br></pre></td></tr></table></figure>



<h1 id="String命令"><a href="#String命令" class="headerlink" title="String命令"></a>String命令</h1><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增.自减操作</li>
<li>float：浮点类型，可以做自增.自减操作</li>
</ul>
<p><strong>String的常见命令：</strong></p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
</ul>
<p><strong>操作</strong></p>
<ul>
<li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Rose  <span class="comment">//原来不存在</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name </span><br><span class="line"><span class="string">&quot;Rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack <span class="comment">//原来存在，就是修改</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MSET和MGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MGET name age k1 k2 k3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Jack&quot;</span> <span class="comment">//之前存在的name</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;10&quot;</span>   <span class="comment">//之前存在的age</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>INCR和INCRBY和DECY</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr age <span class="comment">//增加1</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age <span class="comment">//获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span> <span class="comment">//一次增加2</span></span><br><span class="line">(integer) <span class="number">13</span> <span class="comment">//返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">1</span> <span class="comment">//也可以增加负数，相当于减</span></span><br><span class="line">(integer) <span class="number">14</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incrby age -<span class="number">2</span> <span class="comment">//一次减少2个</span></span><br><span class="line">(integer) <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR age <span class="comment">//相当于 incr 负数，减少正常用法</span></span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line">    </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>SETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; help setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set name Jack  <span class="comment">//设置名称</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name lisi <span class="comment">//如果key不存在，则添加成功</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name <span class="comment">//由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; setnx name2 lisi <span class="comment">//name2 不存在，所以操作成功</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SETEX</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex name 10 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>



<h1 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h1><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p>
<p><img src="/2021/04/13/Redis%E5%91%BD%E4%BB%A4/1652941995945.png"></p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p>
<p><img src="/2021/04/13/Redis%E5%91%BD%E4%BB%A4/1652942027719.png"></p>
<p><strong>Hash类型的常见命令</strong></p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li><p>HKEYS：获取一个hash类型的key中的所有的field</p>
</li>
<li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p>
</li>
<li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p>
</li>
</ul>
<p><strong>操作</strong></p>
<ul>
<li>HSET和HGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> name Lucy<span class="comment">//大key是 heima:user:3 小key是name，小value是Lucy</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">21</span><span class="comment">// 如果操作不存在的数据，则是新增</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET heima:user:<span class="number">3</span> age <span class="number">17</span> <span class="comment">//如果操作存在的数据，则是修改</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGET heima:user:<span class="number">3</span> age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HMSET和HMGET</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name HanMeiMei</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET heima:user:<span class="number">4</span> name LiLei age <span class="number">20</span> sex man</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMGET heima:user:<span class="number">4</span> name age sex</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HGETALL</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HKEYS和HVALS</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HKEYS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HINCRBY</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age <span class="number">2</span></span><br><span class="line">(integer) <span class="number">22</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HVALS heima:user:<span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;man&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HINCRBY  heima:user:<span class="number">4</span> age -<span class="number">2</span></span><br><span class="line">(integer) <span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HSETNX</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user4 sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSETNX heima:user:<span class="number">3</span> sex <span class="title function_">woman</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL heima:user:<span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;17&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;sex&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h1><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p><strong>List的常见命令：</strong></p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>
</ul>
<p><img src="/2021/04/13/Redis%E5%91%BD%E4%BB%A4/1652943604992.png" alt="1652943604992"></p>
<p><strong>操作</strong></p>
<ul>
<li>LPUSH和RPUSH</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LPOP和RPOP</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP users</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPOP users</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LRANGE</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE users <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;4&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h1><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集.并集.差集等功能</li>
</ul>
<p><strong>Set类型的常见命令</strong></p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
<li>SDIFF key1 key2 … ：求key1与key2的差集</li>
<li>SUNION key1 key2 ..：求key1和key2的并集</li>
</ul>
<h1 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h1><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p><strong>SortedSet的常见命令：</strong></p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li>
</ul>
<blockquote>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p>
<p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/04/12/Linux%E4%B8%AD%E5%AE%89%E8%A3%85Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/Linux%E4%B8%AD%E5%AE%89%E8%A3%85Redis/" class="post-title-link" itemprop="url">Linux中安装Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-12 23:23:50" itemprop="dateCreated datePublished" datetime="2021-04-12T23:23:50+08:00">2021-04-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h1><p>Redis是基于C语言编写的，首先需要安装Redis所需要的gcc依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure>



<h1 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br><span class="line">cd redis-6.2.6</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>默认的安装路径是在 <code>/usr/local/bin</code>目录下。</p>
<p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p>
<ul>
<li>redis-cli：是redis提供的命令行客户端</li>
<li>redis-server：是redis的服务端启动脚本</li>
<li>redis-sentinel：是redis的哨兵启动脚本</li>
</ul>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p>
<h1 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h1><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件redis.conf，在解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>）。</p>
<p>修改redis.conf文件中的一些配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure>

<p>Redis的其它常见配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>

<p>启动Redis：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>



<p>停止服务：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure>



<h1 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h1><p>可以通过配置来实现开机自启。</p>
<p>首先，新建一个系统服务文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>



<p>然后重载系统服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>



<p>可以用下面这组命令来操作Redis：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>



<p>执行下面的命令，可以让redis开机自启：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/02/09/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/%E5%87%A0%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">几种软件开发方法对比</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-09 22:16:23" itemprop="dateCreated datePublished" datetime="2021-02-09T22:16:23+08:00">2021-02-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>软件开发方法是一种使用早已定义好的技术集及符号表示习惯来组织软件生产的过程。</p>
<p>本文对净室方法、结构化方法、面向对象方法、原型法、逆向工程等方法进行梳理，并对各种开发方法特点、优点进行对比。</p>
<h1 id="净室方法"><a href="#净室方法" class="headerlink" title="净室方法"></a>净室方法</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>净室软件工程（Cleanroom Software Engineering, CSE)是软件开发的一种形式化方法，可以开发较高质量的软件。它使用盒结构规约进行分析和建模，并且将正确性验证作为发现和排除错误的主要机制，使用统计测试来获取认证软件可靠性所需要的信息。CSE强调在规约和设计上的严格性，还强调统计质量控制技术，包括基于客户对软件的预期使用测试。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>CSE太理论化，需要更多的数学知识。其正确性验证的步骤比较困难且比较耗时。CSE要求采用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%BC%80%E5%8F%91/5133612">增量式开发</a>、采用盒子结构、采用统计测试方法，普通工程师必须经过加强训练才能掌握。</p>
<p>CSE开发小组不进行传统的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95">模块测试</a>，这是不现实的。工程师可能对编程语言和开发环境还不熟悉，而且编译器或操作系统的bug也可能导致未预期的错误。</p>
<p>CSE毕竟脱胎于传统软件工程，不可避免地带有传统软件工程的一些弊端。</p>
<h1 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>结构化方法的主要特点是：开发目标清晰化、开发工作阶段化、开发文档规范化和设计方法结构化。结构化方法特别适合于数据处理领域的问题，但是不适应于规模较大、比较复杂的系统开发。</p>
<p>由结构化分析、结构化设计、结构化程序设计组成，是一种面向数据流的开发方法。</p>
<p>结构化分析是根据分解与抽象的原则，按照系统中数据处理的流程，用数据流图来建立系统的功能类型，从而完成需求分析工作。结构化方法分析模型的核心是数据字典，围绕这个核心，有三个层次的模型，分别是数据模型、功能模型和行为模型（也称为状态模型）。在实际工作中，一般使用E-R图表示数据模型，用DFD表示功能模型，用状态转换图表示行为模型。这三个模型有着密切的关系，它们的建立不具有严格的时序性，而是一个迭代的过程。</p>
<p>结构化设计是根据模块独立性准则、软件结构优化准则将数据流图转换为软件的结构体系，用软件结构图来建立系统的物理模型，实现系统的概要设计。</p>
<p>结构化程序设计使用3种基本控制结构构造程序，任何程序都可以由顺序、选择和重复3种基本控制结构构造。</p>
<p>自顶向下方法是一种决策策略。软件开发涉及作什么决策、如何决策和决策顺序等决策问题。</p>
<p>自顶向下方法在任何时刻所作的决定都是当时对整个设计影响最大的那些决定。如果把所有决定分组或者分级，那么决策顺序是首先作最高级的决定，然后依次地作较低级的决定。同级的决定则按照随机的顺序或者按别的方法。一个决策的级别是看它距离要达到的最终目的（因此是软件的实际实现）的远近程度。从问题本身来看，或是由外(用户所见的）向内（系统的实现）看，以距离实现近的决定为低级决定，远的为高级决定。</p>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>对系统分析和设计人员的要求较高。 </p>
<p>开发周期长，系统复杂，一般属于一种高成本、大投资的工程。</p>
<p>对于大系统而言，自上而下的规划对于下层系统的实施往往缺乏约束力，</p>
<p>从经济角度来看，很难说自顶向下的做法在经济上市合算的。</p>
<h1 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>面向对象方法是系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期，提高系统开发的正确性和效率。</p>
<p>面向对象方法包含面向对象分析OOA、面向对象设计OOD、面向对象程序设计OOP。</p>
<p>面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成。用例建模用来描述待开发系统的功能需求，主要元素是用例和参与者。参与者是指系统以外的，需要使用系统或与系统交互的事物，包括：人或组织、设备、外部系统等，比较隐晦的参与者包括：时间、温度；用例是对系统行为的动态描述，用例获取是需求分析阶段的主要任务之一，用例之间的关系包括：包含、扩展、泛化。</p>
<p>面向对象的设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。在面向对象设计中，类可以分为三种类型：实体类、边界类和控制类。类之间的关系包括6种：关联、聚合、组合、依赖、泛化、实现。</p>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>类和继承等特点使得程序会多很多指针操作来定位函数入口和自身要维护虚拟方法表等额外的工作，程序的处理效率相对要低（但程序开发效率高）。</p>
<h1 id="原型法"><a href="#原型法" class="headerlink" title="原型法"></a>原型法</h1><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><p>原型是软件系统的初始版本，用来演示概念并尝试设计选择，通常用来发现更多的问题和可能的解决方案。快速迭代式的原型开发能够有效控制成本，根据原型与最终产品之间的关系，原型开发分为三类：抛弃式原型开发利用原型验证和澄清系统的需求描述，重新构造系统：演化式原型开发逐步改进和细化原型，将原型进化直至产生出目标系统；增量式原型开发在建立软件总体设计的基础上，采用增量开发方法，使原型成为最终系统。</p>
<p>以原型开发思想为基础，提出了螺旋模型、敏捷方法等。 </p>
<h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><p>原型法不适用于开发大型的信息系统；系统难于维护；如果用户合作不好，盲目纠错，会拖延开发进程。</p>
<h1 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h1><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><p>逆向工程与重构工程是目前预防性维护采用的主要技术。所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。逆向工程导出的信息可以分为：实现级、结构级、功能级、领域级，信息的抽象级别越高，它与代码的距离就越远，通过逆向工程恢复的难度亦越大，而自动工具支持的可能性相对变小，要求人参与判断和推理的工作增多。</p>
<h1 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h1><h2 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h2><p>Scrum是橄榄球比赛中“争球”的意思，你可以脑补争球时的敏捷、激情和你争我夺。现在Scrum是广泛应用于IT界的一套项目管理工具</p>
<p>Scrum的核心，是把整个项目分成若干个冲刺，每次2-4周，冲完一次再来一次。</p>
<p>Scrum的本质，是把一次漫长的长跑，分割成一段段全力以赴的冲刺，通过一套标准流程方法，提高效率。</p>
<p>Scrum是由三个角色（产品负责人，Scrum Master，团队成员）、四个仪式（冲刺计划会，每日站会，冲刺评审会，冲刺回顾会）和三个物件（产品积压，冲刺积压，燃尽图）组成的一套项目管理方法。</p>
<p>产品负责人，召开冲刺计划会，定下三件事：冲刺目标。定下目标后，把它们从“产品积压”，移入“冲刺积压”。</p>
<p>冲刺方法。选定冲刺方法。</p>
<p>分配任务。团队成员若干人，在6个步骤中，各自主动领取任务。</p>
<p>燃尽，是烧完了的意思。随着时间推移，剩余工作量越来越少。把计划进度，画成一根从左上到右下的直线。然后，把实际进度用红线标在旁边，看着工作量像蜡烛一样，不断燃尽。</p>
<p>冲刺评审会，由主编负责主持，一起审阅最终交付的文章。冲刺回顾会，讨论开始做什么，停止做什么，继续做什么。</p>
<h2 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h2><p>XP (Extreme Programming，极限编程)在所有的敏捷型方法中，XP是最引人瞩目的。它源于Smalltalk圈子，特别是Kent Beck和Ward Cunningham在20世纪80年代末的密切合作。XP在一些对费用控制严格的公司中的使用，已经被证明是非常有效的。</p>
<h2 id="水晶方法"><a href="#水晶方法" class="headerlink" title="水晶方法"></a>水晶方法</h2><p>Cockburn的水晶系列方法，水晶系列方法是由AlistairCockburn提出的。它与XP方法一样，都有以人为中心的理念，但在实践上有所不同。Alistair考虑到人们一般很难严格遵循一个纪律约束很强的过程，因此，与XP的高度纪律性不同，Alistair探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。</p>
<h2 id="开源界的开发方法"><a href="#开源界的开发方法" class="headerlink" title="开源界的开发方法"></a>开源界的开发方法</h2><p>开放式源码，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障(debug)的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。</p>
<h2 id="FDD"><a href="#FDD" class="headerlink" title="FDD"></a>FDD</h2><p>Coad的功用驱动开发方法(FDD-Feature Driven Development)，FDD是由Jeff DeLuca和大师Peter Coad提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在FDD中，一个迭代周期一般是两周。在FDD中，编程开发人员分成两类：首席程序员和“类”程序员(classowner)。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而“类”程序员则主要做源码编写。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2021/01/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%B3%E9%94%AE%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%B3%E9%94%AE%E7%82%B9/" class="post-title-link" itemprop="url">微服务关键点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-11 19:21:31" itemprop="dateCreated datePublished" datetime="2021-01-11T19:21:31+08:00">2021-01-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="微服务的核心"><a href="#微服务的核心" class="headerlink" title="微服务的核心"></a>微服务的核心</h1><ol>
<li>将一个单体系统，拆成多个小的业务模块，同时各个小的业务模块需要通过Http rest接口去做交付和集成。</li>
<li>在拆分后每个微服务都需要做到高度地独立自治，从底层基础设施资源，到数据库、中间件、应用层、前端，拆分后的服务能完全地独立组成一套系统。</li>
</ol>
<h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><h2 id="实际开发中是不是一定要用相关地微服务开发框架？"><a href="#实际开发中是不是一定要用相关地微服务开发框架？" class="headerlink" title="实际开发中是不是一定要用相关地微服务开发框架？"></a>实际开发中是不是一定要用相关地微服务开发框架？</h2><p>只要满足单体系统做了拆分后，满足各个拆分以后的组件之间通过轻量的http rest接口做集成，就是微服务。</p>
<h2 id="微服务怎样做拆分？"><a href="#微服务怎样做拆分？" class="headerlink" title="微服务怎样做拆分？"></a>微服务怎样做拆分？</h2><ol>
<li><p>采用结构化的分析方法，基于实际的业务架构数据架构，基于CRUD的矩阵分析，做聚合做拆分；</p>
</li>
<li><p>通过当前的领域建模，通过事件风暴，通过基于对象的聚类，去识别这个限界上下文，然后再去做聚合做拆分。</p>
</li>
</ol>
<p>微服务拆分核心重点，微服务拆分后，各个微服务之间能够做到尽量的松耦合。</p>
<p>微服务拆分还跟系统的复杂度、团队组织架构模式相关。<br>举例：<br>假如一个团队三四个人，要将系统拆成八九个个微服务，这种情况不现实。一个人管理多个微服务，在前期很难找到一个标准的管控规范来控制每个开发人员，使各个微服务之间不发生错误的调用，比如，微服务a不直接去访问微服务b的数据库。</p>
<p>如果一个系统，本身业务复杂度没有那么复杂时，没必要拆分得那么细。</p>
<h2 id="微服务治理"><a href="#微服务治理" class="headerlink" title="微服务治理"></a>微服务治理</h2><p>微服务本身的设计开发和后续的微服务治理能够分开。</p>
<p>在Spring cloud中，包含服务注册发现中心、微服务网关、限流熔断、链路监控，但是其中存在一个问题是，Spring Cloud中，很多设计开发的能力和后续的治理能力耦合在一起，在开发时一些治理的配置项存在于配置文件中，这种情况不太合理。<br>随着云原生，DevOps的一个发展，微服务的治理逐渐会变成类似于基于service mesh服务网格的这种模式，服务网格的微服务自理模式下面，通过在devops持续集成部署的时候，自动的去下发这个边车代理，这样做到微服务开发时没有任何一个侵入性。</p>
<h2 id="微服务和SOA架构的比较"><a href="#微服务和SOA架构的比较" class="headerlink" title="微服务和SOA架构的比较"></a>微服务和SOA架构的比较</h2><p>SOA架构是一个中心化的架构模式，微服务是完全的去中心化，实际上这个理解不是特别的准确，在微服务架构种，有时候会用到微服务网关，或者是API网关，API网关是一个中心化的模式，所有的流量都需要经过API网关，它根SOA架构下ESB总线的道理是一样的，只不过API网关更加轻量。<br>微服务架构是一个去中心化的架构，在实际开发种，微服务架构有两类流量，一类是整个微服务要对外暴露的南北流量，一个是微服务内部交互的东西流量，对于东西流量的交互，尽量是去中心化的。不管是基于service mesh，还是基于服务注册发现中心，都可以看到，东西流量的交互一定可以实现去中心化。但是对于整个微服务需要对外暴露接口的时候，还是要通过API网关，它根SOA种的ESB总线是一样的原理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2020/12/24/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/24/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">云原生应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-24 11:40:45" itemprop="dateCreated datePublished" datetime="2020-12-24T11:40:45+08:00">2020-12-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="云原生应用的概念"><a href="#云原生应用的概念" class="headerlink" title="云原生应用的概念"></a>云原生应用的概念</h1><p>云原生应用的概念由云和原生两个部分组成，云在这里指的是云平台，也就是平台即服务（Platform as a Service，PaaS）；原生应用指的是专门针对云平台而设计和实现的，充分利用了云平台的特性。应用的微服务可以专注于实现业务逻辑，而把微服务架构的复杂度交给云平台来解决。</p>
<p>原生这个词在软件开发中有它独特的含义。原生通常意味着高效和难以移植。原生意味着针对特定的平台而设计，可以充分利用平台的特性，因此运行起来非常高效；同样意味着与特定平台的深度绑定，很难移植到其他平台。云原生应用同样具有这两个特征，对于云原生应用来说，难移植并不是一个问题，毕竟迁移到云平台之后，不会再想迁移回去。</p>
<h1 id="云原生应用的特征"><a href="#云原生应用的特征" class="headerlink" title="云原生应用的特征"></a>云原生应用的特征</h1><h2 id="单一代码库"><a href="#单一代码库" class="headerlink" title="单一代码库"></a>单一代码库</h2><p>云原生应用必须有单一的代码库，并在版本管理系统中进行追踪。单一代码库可以是一个代码仓库，也可以是共享同一根目录的多个代码仓库，其重要性在于每一个代码提交（Commit）都会对应一个不可变的构建版本。在每次代码提交之后，持续集成流程会被触发，最终产生一系列的应用容器镜像，这就在代码提交和构建版本之间建立了一对一的对应关系，这种一对一的关系保证了每个构建版本都是可追踪的，可以比较不同版本之间的代码变化。</p>
<p>对于微服务架构的应用来说，每个应用由多个服务组成，这些服务应该由单一的代码库进行管理，这保证了构建版本的稳定性。如果一个改动涉及到多个服务，则这个改动应该在一次代码提交中完成对所有相关服务的修改；如果服务的代码分散在多个代码库中，则一个改动会被分成多个代码提交，每个代码提交都会触发一次持续集成流程，产生对应服务的构建版本，这些服务的构建版本只包含了部分改动，是不完整的。在应用部署时，有的服务可能包含了部分改动，而有的服务则没有，这使得部署的应用实际上是不能工作的。因此，微服务架构的应用应该使用单一代码库。</p>
<h2 id="API-优先"><a href="#API-优先" class="headerlink" title="API 优先"></a>API 优先</h2><p>云原生应用应该采用 API 优先的设计策略。微服务架构的应用使用公开 API 来作为服务的对外接口，API 屏蔽了服务的内部实现细节。API 优先的设计策略指的是在设计阶段，应该首先设计 API 并确定 API 的细节。API 的设计过程需要多个团队的参与，包括 API 的实现者和可能的使用者，这些团队在充分讨论中最终完成 API 的定义。API 可以使用 OpenAPI 规范描述，从该规范中可以生成 API 文档和进行测试的模拟服务器。</p>
<p>API 优先的策略保证了 API 的稳定性，同时可以减少不必要的后期修改。因为 API 是服务之间的接口，修改 API 就意味着相关的内部实现、测试用例和 API 的使用者都需要进行修改，如果在应用开发中出现了必须修改 API 的情况，那造成的影响是很大的。API 优先确保了尽可能减少在开发中对 API 进行修改。</p>
<p>API 优先的另外一个好处是可以提高开发效率。API 确定之后，可以利用工具生成文档和模拟服务器，API 的使用者可以根据文档来编写使用 API 的代码。利用 Swagger 这样的工具，甚至可以直接生成访问 API 的代码。测试人员可以编写 API 相关的测试用例，并用模拟服务器运行测试。不同的团队可以并行工作，从而提高效率。</p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>云原生应用应该管理自己的依赖，Java 开发人员对依赖管理应该并不陌生，常用的 Java 构建工具 Maven 和 Gradle 都提供了依赖管理的支持。在开发过程中，只需要利用构建工具的支持即可；在管理依赖时，则需要区分应用自带的依赖和运行环境提供的依赖。云原生应用通常会包含全部所需的依赖，尤其是以容器形式运行的应用，典型的例子是微服务的 REST API。云原生应用会自带嵌入式的 Tomcat 这样的服务器来提供 HTTP 服务。</p>
<h2 id="设计、构建、发布和运行"><a href="#设计、构建、发布和运行" class="headerlink" title="设计、构建、发布和运行"></a>设计、构建、发布和运行</h2><p>云原生应用应该有完整的设计、构建、发布和运行流程，如下图所示。</p>
<p><img src="/2020/12/24/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/Ciqah156_QSAfQBzAABOU7Y65d4141.png"></p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>设计在云原生应用的开发中必不可少。传统应用通常采用瀑布式的开发流程，瀑布式的开发流程中会分配足够的时间进行设计。云原生应用一般采用敏捷软件开发流程，但是这并不意味着设计变得不再重要，只不过设计过程变成了一个迭代的过程，而且每次设计的范围较小，通常只需要对某些新特性进行设计。</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>构建阶段从单一代码库中创建出带版本号的二进制工件，构建过程通常由持续集成服务器来完成，每个构建都必须有唯一不变的版本号，构建出来的二进制工件也是不可变的。这就保证了同一个构建版本在经过测试之后，被部署的版本与测试过的版本保持一致。</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>把构建出来的工件推送到云平台之上，就得到了一个发布版本，发布版本中包含与部署环境相关的配置信息。云原生应用在部署时，通常有开发、测试和生产 3 个环境，在每个环境上的配置信息都不尽相同。发布版本也是不可变的，有唯一的发布号。每一个构建版本都可能对应多个发布版本。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行阶段在云平台之上运行应用，运行的方式取决于云平台，可以是虚拟机或容器。云平台负责管理应用的运行，包括监控应用运行状态、处理失败的情况和动态水平扩展等。</p>
<h2 id="代码、配置和凭据"><a href="#代码、配置和凭据" class="headerlink" title="代码、配置和凭据"></a>代码、配置和凭据</h2><p>代码、配置和凭据是云原生应用开发中创建的三种不同类型的实体。代码包括源代码和相关资源文件；配置是与部署环境相关的配置信息，通常以 XML、YAML、JSON 或属性文件的形式出现，配置中包含的信息包括第三方服务的连接方式、数据库连接信息和应用自身的配置属性等；凭据指的是密码、私钥和 API 密钥等敏感信息。</p>
<p>代码和配置的区别在于，代码不会随着部署环境而变化，而配置则相反。在实践中，应该尽可能把配置从应用中分离出来，进行外部化管理，构建出来的二进制工件中不包含任何配置信息，实际的配置值在部署时根据环境来确定。在运行时，一般使用环境变量来传递配置值，还可以使用类似 Spring Cloud Config 这样的专门配置服务器来管理配置值。凭据都应该从源代码仓库中删除。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志是应用开发中不可或缺的部分。与传统应用不同的是，云原生应用并不需要对日志的输出方式进行很多配置，只是简单地把日志写到标准输出流（stdout）和标准错误流（stderr）。日志的收集和处理由云平台上的其他服务来提供，这把应用开发人员从日志管理相关的任务中解放出来。云平台上的日志管理服务非常多，开源的典型实现包括 Elastic 技术栈（ElasticSearch + LogStash + Kibana）和 Fluentd。</p>
<h2 id="随时可丢弃"><a href="#随时可丢弃" class="headerlink" title="随时可丢弃"></a>随时可丢弃</h2><p>云原生应用的生命周期可能是短暂的，随时可能被终止。云平台可能会随时启动和停止应用的实例，这就要求云原生应用的启动和停止速度都要非常快。当应用的负载突然增大时，可以快速地启动新的实例来处理请求；当应用的实例出现问题时，可以快速启动一个新的实例作为替代。快速停止应用和快速启动应用一样重要，快速停止应用保证了资源可以被及时释放。</p>
<h2 id="支撑服务"><a href="#支撑服务" class="headerlink" title="支撑服务"></a>支撑服务</h2><p>云原生应用的运行离不开支撑服务。支撑服务是一个宽泛的概念，包括数据库、消息中间件、缓存、用户认证和授权、存储等。连接这些支撑服务的配置信息应该被抽离出来，在运行时根据部署环境提供实际值。</p>
<h2 id="环境等同"><a href="#环境等同" class="headerlink" title="环境等同"></a>环境等同</h2><p>云原生应用的不同部署环境应该是等同的。开发、测试和生产环境之间不应该有差异，环境的等同性保证了云原生应用可以快速的进行部署，这一特征与构建工件的不变性是相辅相成的，两者缺一不可。有了这两个特征之后，每一个唯一版本的构建工件可以被依次部署到不同的环境，在测试环境上经过测试的版本，可以直接部署到生产环境。我们可以确定应用在生产环境上的行为与测试环境中一样。</p>
<h2 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h2><p>云原生应用运行中可能会需要执行一些管理任务，比如生成报表或者执行一次性的数据查询等，这些任务通常并不属于业务流程的一部分，更多的是为了管理和运维的需要。这些任务在执行中会用到云原生应用所依赖的支撑服务，对于这些任务，应该创建独立的应用，并在同样的云平台上运行。对于定期执行的任务，可以充分利用云平台的支持，比如，Kubernetes 提供了对定时任务（CronJob）的支持。</p>
<p>以生成报表为例，可以创建一个独立的应用来读取数据库并生成报表，该应用可以有自己独立的容器镜像。如果报表生成是手动触发的，该应用应该独立运行，并提供一个 API 接口来允许外部触发。如果报表生成是定期的，应用部署时可以创建相应的定时任务来运行容器，在容器启动时自动生成报表，生成完毕之后，容器运行结束。下图说明了这两种触发方式的区别，圆角矩形的边框表示应用的边界。</p>
<p><img src="/2020/12/24/%E4%BA%91%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/Cgq2xl56_QSAWystAACJk5oFHN0431.png"></p>
<h2 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h2><p>云原生应用在运行时并不负责管理实际的端口绑定，而是由云平台统一管理。比如，一个基于 Spring Boot 的微服务应用通常在 8080 端口运行 HTTP 服务，当应用运行在云平台上时，这个端口只是虚拟机或容器内的端口，并不是外部用户或其他服务访问时的实际端口。云平台对网络进行统一管理，负责分配实际的端口，云平台同时提供了相应的机制来发现访问服务的实际地址和端口。</p>
<h2 id="无状态进程"><a href="#无状态进程" class="headerlink" title="无状态进程"></a>无状态进程</h2><p>云原生应用应该是无状态的。所有的状态信息都应该从应用中抽离出来，并保存在支撑服务中，比如数据库中。正因为应用是无状态的，才可以由云平台快速的启动和停止，并进行垂直或水平扩展。</p>
<h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><p>云原生应用使用水平扩展来并发运行多个实例，使用负载均衡来把请求分配到某个实例进行处理。</p>
<h2 id="遥测数据"><a href="#遥测数据" class="headerlink" title="遥测数据"></a>遥测数据</h2><p>云原生应用需要收集一系列遥测数据，包括应用性能指标、运行状态和日志等，这些遥测数据，对于云平台和应用来说同等重要。云平台可以用性能指标来进行自动水平扩展，比如，Kubernetes 支持 Pod 的自动水平扩展，当 CPU 的利用率超过预定的阈值时，会自动启动新的 Pod 来处理请求。性能指标分成两类：一类是业务无关的，比如请求的数量、请求的处理速度、以及平均的请求处理时间等；第二类是业务相关的，需要应用根据业务需求进行收集，比如处理的订单数量和不同商品的销售情况等。云原生应用通常会创建仪表盘来实时展示整体的运行状态，方便运维人员进行监控。</p>
<h2 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h2><p>云原生应用应该是安全的，安全应该在应用的设计阶段就充分考虑。在实现中，可以使用基于角色的访问控制（RBAC）来保护 API，已经有大量的开源框架来帮助实现认证和授权。</p>
<p>在理想情况下，云原生应用应该具备上述全部 15 个特征，但是在实际的开发中，不一定能够做到。开发团队可以根据需要，选择对应用最重要的特征来实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fhclk.github.io/2020/12/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.png">
      <meta itemprop="name" content="fhclk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾荒者">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">微服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 10:11:36" itemprop="dateCreated datePublished" datetime="2020-12-12T10:11:36+08:00">2020-12-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h4><p>微服务架构是一种架构风格和架构思想，它倡导我们在传统软件应用架构的基础上，将系统业务按照功能拆分为更加细粒度的服务，所拆分的每一个服务都是一个独立的应用，这些应用对外提供公共的API，可以独立承担对外服务的职责，通过此种思想方式所开发的软件服务实体就是“微服务”，而围绕着微服务思想构建的一系列体系结构(包括开发、测试、部署等)。</p>
<h5 id="微服务优缺点"><a href="#微服务优缺点" class="headerlink" title="微服务优缺点"></a>微服务优缺点</h5><h6 id="微服务特点一：快速响应需求变化"><a href="#微服务特点一：快速响应需求变化" class="headerlink" title="微服务特点一：快速响应需求变化"></a>微服务特点一：快速响应需求变化</h6><p>采用单体巨型非微服务架构有个问题，系统里面的业务模块非常多，大家一 起发布、修改、编译很难进行协调，很难做到敏捷开发、发 布、上线。</p>
<p>微服务本质上是小微程序，相比较来说，很重要的特点是拆分概念。微服务首先是拆分，把大的拆成小的，把整体拆成部分。每个部分单独开发迭代。</p>
<blockquote>
<p>微服务的优点：拆完以后更灵活，各个子系统可以独立开发、独立测试、独立部署、独立进程，最后再集成。</p>
</blockquote>
<p>独立开发拆分以后自主性更强了，独立开发、独立测试、独立部署、独立进程，是 微服务快速响应业务需求变化的重要特点。</p>
<h6 id="微服务特点二：敏捷开发、敏捷运维DevOps"><a href="#微服务特点二：敏捷开发、敏捷运维DevOps" class="headerlink" title="微服务特点二：敏捷开发、敏捷运维DevOps"></a>微服务特点二：敏捷开发、敏捷运维DevOps</h6><blockquote>
<p>微服务的优点：本质上是拆完以后更好开发。</p>
</blockquote>
<p>总结如下：</p>
<ol>
<li>易于替换；</li>
<li>独立部署；</li>
<li>专注某个任务；</li>
<li>高度解耦；</li>
<li>基于功能进行组织：商品、支付、评论、机票、新闻、酒店、游戏等；</li>
<li>服务可以使用不同的语言、系统、平台；</li>
<li>通信使用语言中立的协议，通常是http；</li>
<li>独立技术栈；</li>
<li>易于测试；</li>
</ol>
<h4 id="微服务Microservice的设计原则"><a href="#微服务Microservice的设计原则" class="headerlink" title="微服务Microservice的设计原则"></a>微服务Microservice的设计原则</h4><blockquote>
<p>需求第一</p>
</blockquote>
<p>一定要以需求为出发点。所有的架构好与坏一定是相对的，相对他处的一个需求背景。因为微服务架构能够在某些业务场景中具备优势，所以它相比传统的架构，他有一些优点但是同时也存在着缺点，它不完美。 </p>
<blockquote>
<p>单一职责</p>
</blockquote>
<p>我们的服务尽量是体现单一职责的思想，粒度不是越细越好，也不是越 粗越好。</p>
<blockquote>
<p>协议统一</p>
</blockquote>
<p>尽量去统一协议，目前的协议主要是 rest。</p>
<blockquote>
<p>独立开发</p>
</blockquote>
<p>独立开发一般咱们这里面提到的我们说的是模块拆分以后开发人员一般是独立我们按照模块进行拆分，然后每个人负责一块，每个人熟悉一块代码和逻辑业务逻辑这样的话开发时间都会相对来说高很多。</p>
<blockquote>
<p>独立部署</p>
</blockquote>
<p>独立部署这也是微服架构的很重要的一个原则，微服务架构拆分以后又会出现可能很多程序很多进程，而且每一个模块不是所有的都更新只需要迭代我那一块就行了，就是体现了我们说叫分而治之的这样一个思想，大家一起统一部署。</p>
<h4 id="微服务Microservice的拆分原则"><a href="#微服务Microservice的拆分原则" class="headerlink" title="微服务Microservice的拆分原则"></a>微服务Microservice的拆分原则</h4><ol>
<li><p>按照业务模块拆分</p>
</li>
<li><p>DDD思路可以借鉴，不能照搬</p>
<p>DDD 本身不是架构设计模式，DDD 是一种但是在向对象设计的一个思想或者原则，它是用来解决复杂业务逻辑的一个拆分问题的，它本身并不解决整个架构层次的问题，它是解决业务层的，理解这一点。</p>
</li>
<li><p>单一职责（Single Responsibility）</p>
</li>
</ol>
<h4 id="微服务设计的关注点"><a href="#微服务设计的关注点" class="headerlink" title="微服务设计的关注点"></a>微服务设计的关注点</h4><ol>
<li>并发性</li>
<li>可用性</li>
<li>安全性</li>
<li>密等性</li>
<li>重用性</li>
</ol>
<h4 id="微服务架构设计的5大考量"><a href="#微服务架构设计的5大考量" class="headerlink" title="微服务架构设计的5大考量"></a>微服务架构设计的5大考量</h4><ol>
<li>微服务拆分</li>
<li>微服务高可用</li>
<li>微数据安全</li>
<li>微服务数据同步</li>
<li>微服务监控</li>
</ol>
<h4 id="微服务的经典设计模式"><a href="#微服务的经典设计模式" class="headerlink" title="微服务的经典设计模式"></a>微服务的经典设计模式</h4><h5 id="微服务架构设计模式"><a href="#微服务架构设计模式" class="headerlink" title="微服务架构设计模式"></a>微服务架构设计模式</h5><ol>
<li>业务分解：DDD模式</li>
<li>DataBase PerService 每数据库单服务</li>
<li>API Gateway pattern API网关模式</li>
<li>Client-side 和 Remote Procedure Invocation 模式</li>
<li>Messaging 和 Procedure Invocation 模式</li>
<li>Single Service per Host 和 Multiple Services per Host 模式</li>
<li>AOP: Microservice chassis pattern</li>
<li>Externalized Configuration</li>
<li>Service Component Test 和 Service Integration Contract Test</li>
<li>Circuit Breaker 断路器模式</li>
<li>Access Token 访问令牌模式</li>
<li>观察者模式： Distributed tracing、 Health check API</li>
<li>UI模式：MVC、MVP、MVVM模式</li>
</ol>
<p><img src="/2020/12/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20210820095240441.png" alt="image-20210820095240441"></p>
<p>如图所示，以微服务架构为中心向外发散，有许多设计模式，正下方有两个，一个叫客户端发现，一个叫服务端发现，服务的注册和发现机制也是一个设计模式，微服架构属于更复杂的分布架构，里面也会用到消息通信，通过消息和数据库、其他微服务进行消息补偿。 </p>
<p>网关的微服务太多，只有一个出口，需要给它同一个代理；安全问题，如图中Access token，和令牌相关的；另外还有高并发的熔断限流，circuit breaker 叫断路器模式，熔断相关，分布式日志、分布式加策、追踪、服务拆分模式、单数据库模式、单实例、单数据库模式多服务共享数据库模式、服务编排模式、统一配置模式等等。</p>
<p>这里主要是分布式架构领域相关的设计模式，还有分布式事务模式，一般用的都是补偿的方式。 </p>
<p>服务拆分的一般借鉴 DDD 模式，但不是照搬，不能完全等同。</p>
<h5 id="微服务设计模式分类"><a href="#微服务设计模式分类" class="headerlink" title="微服务设计模式分类"></a>微服务设计模式分类</h5><h6 id="应用架构模式"><a href="#应用架构模式" class="headerlink" title="应用架构模式"></a>应用架构模式</h6><ol>
<li>单点登录</li>
<li>注册发现</li>
<li>熔断限流</li>
<li>断路器</li>
<li>网关模式</li>
<li>消息补偿模式</li>
<li>令牌模式</li>
</ol>
<h6 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h6><ol>
<li>分库 Single Service</li>
<li>共库多 Service</li>
<li>多库同步</li>
<li>事务性补偿</li>
</ol>
<h6 id="日志追踪模式"><a href="#日志追踪模式" class="headerlink" title="日志追踪模式"></a>日志追踪模式</h6><ol>
<li><p>观察者模式 paterns</p>
</li>
<li><p>Log aggregation</p>
</li>
<li><p>Application metrics</p>
</li>
<li><p>Audit logging</p>
</li>
<li><p>Distributed tracing</p>
</li>
<li><p>Exception tracking</p>
</li>
<li><p>Health check API</p>
</li>
<li><p>Log deployments and changes</p>
</li>
<li><p>分布式链路追踪模式</p>
</li>
</ol>
<h6 id="UI模式"><a href="#UI模式" class="headerlink" title="UI模式"></a>UI模式</h6><ol>
<li>MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>Server-side page fragment composition</li>
<li>Client-side UI composition</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  <div>
  
  </div>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fhclk"
      src="/images/avatar1.png">
  <p class="site-author-name" itemprop="name">fhclk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fhclk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fhclk" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fhclk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
</body>
</html>
